<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Portfolio Details - OnePage Bootstrap Template</title>
  <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <link href="assets/img/favicon.png" rel="icon">
  <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="assets/vendor/remixicon/remixicon.css" rel="stylesheet">
  <link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

  <!-- Template Main CSS File -->
  <link href="assets/css/style.css" rel="stylesheet">

  <script>(function() {
    // If window.HTMLWidgets is already defined, then use it; otherwise create a
    // new object. This allows preceding code to set options that affect the
    // initialization process (though none currently exist).
    window.HTMLWidgets = window.HTMLWidgets || {};
  
    // See if we're running in a viewer pane. If not, we're in a web browser.
    var viewerMode = window.HTMLWidgets.viewerMode =
        /\bviewer_pane=1\b/.test(window.location);
  
    // See if we're running in Shiny mode. If not, it's a static document.
    // Note that static widgets can appear in both Shiny and static modes, but
    // obviously, Shiny widgets can only appear in Shiny apps/documents.
    var shinyMode = window.HTMLWidgets.shinyMode =
        typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;
  
    // We can't count on jQuery being available, so we implement our own
    // version if necessary.
    function querySelectorAll(scope, selector) {
      if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
        return scope.find(selector);
      }
      if (scope.querySelectorAll) {
        return scope.querySelectorAll(selector);
      }
    }
  
    function asArray(value) {
      if (value === null)
        return [];
      if ($.isArray(value))
        return value;
      return [value];
    }
  
    // Implement jQuery's extend
    function extend(target /*, ... */) {
      if (arguments.length == 1) {
        return target;
      }
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            target[prop] = source[prop];
          }
        }
      }
      return target;
    }
  
    // IE8 doesn't support Array.forEach.
    function forEach(values, callback, thisArg) {
      if (values.forEach) {
        values.forEach(callback, thisArg);
      } else {
        for (var i = 0; i < values.length; i++) {
          callback.call(thisArg, values[i], i, values);
        }
      }
    }
  
    // Replaces the specified method with the return value of funcSource.
    //
    // Note that funcSource should not BE the new method, it should be a function
    // that RETURNS the new method. funcSource receives a single argument that is
    // the overridden method, it can be called from the new method. The overridden
    // method can be called like a regular function, it has the target permanently
    // bound to it so "this" will work correctly.
    function overrideMethod(target, methodName, funcSource) {
      var superFunc = target[methodName] || function() {};
      var superFuncBound = function() {
        return superFunc.apply(target, arguments);
      };
      target[methodName] = funcSource(superFuncBound);
    }
  
    // Add a method to delegator that, when invoked, calls
    // delegatee.methodName. If there is no such method on
    // the delegatee, but there was one on delegator before
    // delegateMethod was called, then the original version
    // is invoked instead.
    // For example:
    //
    // var a = {
    //   method1: function() { console.log('a1'); }
    //   method2: function() { console.log('a2'); }
    // };
    // var b = {
    //   method1: function() { console.log('b1'); }
    // };
    // delegateMethod(a, b, "method1");
    // delegateMethod(a, b, "method2");
    // a.method1();
    // a.method2();
    //
    // The output would be "b1", "a2".
    function delegateMethod(delegator, delegatee, methodName) {
      var inherited = delegator[methodName];
      delegator[methodName] = function() {
        var target = delegatee;
        var method = delegatee[methodName];
  
        // The method doesn't exist on the delegatee. Instead,
        // call the method on the delegator, if it exists.
        if (!method) {
          target = delegator;
          method = inherited;
        }
  
        if (method) {
          return method.apply(target, arguments);
        }
      };
    }
  
    // Implement a vague facsimilie of jQuery's data method
    function elementData(el, name, value) {
      if (arguments.length == 2) {
        return el["htmlwidget_data_" + name];
      } else if (arguments.length == 3) {
        el["htmlwidget_data_" + name] = value;
        return el;
      } else {
        throw new Error("Wrong number of arguments for elementData: " +
          arguments.length);
      }
    }
  
    // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
    function escapeRegExp(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
  
    function hasClass(el, className) {
      var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
      return re.test(el.className);
    }
  
    // elements - array (or array-like object) of HTML elements
    // className - class name to test for
    // include - if true, only return elements with given className;
    //   if false, only return elements *without* given className
    function filterByClass(elements, className, include) {
      var results = [];
      for (var i = 0; i < elements.length; i++) {
        if (hasClass(elements[i], className) == include)
          results.push(elements[i]);
      }
      return results;
    }
  
    function on(obj, eventName, func) {
      if (obj.addEventListener) {
        obj.addEventListener(eventName, func, false);
      } else if (obj.attachEvent) {
        obj.attachEvent(eventName, func);
      }
    }
  
    function off(obj, eventName, func) {
      if (obj.removeEventListener)
        obj.removeEventListener(eventName, func, false);
      else if (obj.detachEvent) {
        obj.detachEvent(eventName, func);
      }
    }
  
    // Translate array of values to top/right/bottom/left, as usual with
    // the "padding" CSS property
    // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
    function unpackPadding(value) {
      if (typeof(value) === "number")
        value = [value];
      if (value.length === 1) {
        return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
      }
      if (value.length === 2) {
        return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
      }
      if (value.length === 3) {
        return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
      }
      if (value.length === 4) {
        return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
      }
    }
  
    // Convert an unpacked padding object to a CSS value
    function paddingToCss(paddingObj) {
      return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
    }
  
    // Makes a number suitable for CSS
    function px(x) {
      if (typeof(x) === "number")
        return x + "px";
      else
        return x;
    }
  
    // Retrieves runtime widget sizing information for an element.
    // The return value is either null, or an object with fill, padding,
    // defaultWidth, defaultHeight fields.
    function sizingPolicy(el) {
      var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
      if (!sizingEl)
        return null;
      var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
      if (viewerMode) {
        return sp.viewer;
      } else {
        return sp.browser;
      }
    }
  
    // @param tasks Array of strings (or falsy value, in which case no-op).
    //   Each element must be a valid JavaScript expression that yields a
    //   function. Or, can be an array of objects with "code" and "data"
    //   properties; in this case, the "code" property should be a string
    //   of JS that's an expr that yields a function, and "data" should be
    //   an object that will be added as an additional argument when that
    //   function is called.
    // @param target The object that will be "this" for each function
    //   execution.
    // @param args Array of arguments to be passed to the functions. (The
    //   same arguments will be passed to all functions.)
    function evalAndRun(tasks, target, args) {
      if (tasks) {
        forEach(tasks, function(task) {
          var theseArgs = args;
          if (typeof(task) === "object") {
            theseArgs = theseArgs.concat([task.data]);
            task = task.code;
          }
          var taskFunc = tryEval(task);
          if (typeof(taskFunc) !== "function") {
            throw new Error("Task must be a function! Source:\n" + task);
          }
          taskFunc.apply(target, theseArgs);
        });
      }
    }
  
    // Attempt eval() both with and without enclosing in parentheses.
    // Note that enclosing coerces a function declaration into
    // an expression that eval() can parse
    // (otherwise, a SyntaxError is thrown)
    function tryEval(code) {
      var result = null;
      try {
        result = eval("(" + code + ")");
      } catch(error) {
        if (!(error instanceof SyntaxError)) {
          throw error;
        }
        try {
          result = eval(code);
        } catch(e) {
          if (e instanceof SyntaxError) {
            throw error;
          } else {
            throw e;
          }
        }
      }
      return result;
    }
  
    function initSizing(el) {
      var sizing = sizingPolicy(el);
      if (!sizing)
        return;
  
      var cel = document.getElementById("htmlwidget_container");
      if (!cel)
        return;
  
      if (typeof(sizing.padding) !== "undefined") {
        document.body.style.margin = "0";
        document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
      }
  
      if (sizing.fill) {
        document.body.style.overflow = "hidden";
        document.body.style.width = "100%";
        document.body.style.height = "100%";
        document.documentElement.style.width = "100%";
        document.documentElement.style.height = "100%";
        if (cel) {
          cel.style.position = "absolute";
          var pad = unpackPadding(sizing.padding);
          cel.style.top = pad.top + "px";
          cel.style.right = pad.right + "px";
          cel.style.bottom = pad.bottom + "px";
          cel.style.left = pad.left + "px";
          el.style.width = "100%";
          el.style.height = "100%";
        }
  
        return {
          getWidth: function() { return cel.offsetWidth; },
          getHeight: function() { return cel.offsetHeight; }
        };
  
      } else {
        el.style.width = px(sizing.width);
        el.style.height = px(sizing.height);
  
        return {
          getWidth: function() { return el.offsetWidth; },
          getHeight: function() { return el.offsetHeight; }
        };
      }
    }
  
    // Default implementations for methods
    var defaults = {
      find: function(scope) {
        return querySelectorAll(scope, "." + this.name);
      },
      renderError: function(el, err) {
        var $el = $(el);
  
        this.clearError(el);
  
        // Add all these error classes, as Shiny does
        var errClass = "shiny-output-error";
        if (err.type !== null) {
          // use the classes of the error condition as CSS class names
          errClass = errClass + " " + $.map(asArray(err.type), function(type) {
            return errClass + "-" + type;
          }).join(" ");
        }
        errClass = errClass + " htmlwidgets-error";
  
        // Is el inline or block? If inline or inline-block, just display:none it
        // and add an inline error.
        var display = $el.css("display");
        $el.data("restore-display-mode", display);
  
        if (display === "inline" || display === "inline-block") {
          $el.hide();
          if (err.message !== "") {
            var errorSpan = $("<span>").addClass(errClass);
            errorSpan.text(err.message);
            $el.after(errorSpan);
          }
        } else if (display === "block") {
          // If block, add an error just after the el, set visibility:none on the
          // el, and position the error to be on top of the el.
          // Mark it with a unique ID and CSS class so we can remove it later.
          $el.css("visibility", "hidden");
          if (err.message !== "") {
            var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              // setting width can push out the page size, forcing otherwise
              // unnecessary scrollbars to appear and making it impossible for
              // the element to shrink; so use max-width instead
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
            errorDiv.text(err.message);
            $el.after(errorDiv);
  
            // Really dumb way to keep the size/position of the error in sync with
            // the parent element as the window is resized or whatever.
            var intId = setInterval(function() {
              if (!errorDiv[0].parentElement) {
                clearInterval(intId);
                return;
              }
              errorDiv
                .css("top", el.offsetTop)
                .css("left", el.offsetLeft)
                .css("maxWidth", el.offsetWidth)
                .css("height", el.offsetHeight);
            }, 500);
          }
        }
      },
      clearError: function(el) {
        var $el = $(el);
        var display = $el.data("restore-display-mode");
        $el.data("restore-display-mode", null);
  
        if (display === "inline" || display === "inline-block") {
          if (display)
            $el.css("display", display);
          $(el.nextSibling).filter(".htmlwidgets-error").remove();
        } else if (display === "block"){
          $el.css("visibility", "inherit");
          $(el.nextSibling).filter(".htmlwidgets-error").remove();
        }
      },
      sizing: {}
    };
  
    // Called by widget bindings to register a new type of widget. The definition
    // object can contain the following properties:
    // - name (required) - A string indicating the binding name, which will be
    //   used by default as the CSS classname to look for.
    // - initialize (optional) - A function(el) that will be called once per
    //   widget element; if a value is returned, it will be passed as the third
    //   value to renderValue.
    // - renderValue (required) - A function(el, data, initValue) that will be
    //   called with data. Static contexts will cause this to be called once per
    //   element; Shiny apps will cause this to be called multiple times per
    //   element, as the data changes.
    window.HTMLWidgets.widget = function(definition) {
      if (!definition.name) {
        throw new Error("Widget must have a name");
      }
      if (!definition.type) {
        throw new Error("Widget must have a type");
      }
      // Currently we only support output widgets
      if (definition.type !== "output") {
        throw new Error("Unrecognized widget type '" + definition.type + "'");
      }
      // TODO: Verify that .name is a valid CSS classname
  
      // Support new-style instance-bound definitions. Old-style class-bound
      // definitions have one widget "object" per widget per type/class of
      // widget; the renderValue and resize methods on such widget objects
      // take el and instance arguments, because the widget object can't
      // store them. New-style instance-bound definitions have one widget
      // object per widget instance; the definition that's passed in doesn't
      // provide renderValue or resize methods at all, just the single method
      //   factory(el, width, height)
      // which returns an object that has renderValue(x) and resize(w, h).
      // This enables a far more natural programming style for the widget
      // author, who can store per-instance state using either OO-style
      // instance fields or functional-style closure variables (I guess this
      // is in contrast to what can only be called C-style pseudo-OO which is
      // what we required before).
      if (definition.factory) {
        definition = createLegacyDefinitionAdapter(definition);
      }
  
      if (!definition.renderValue) {
        throw new Error("Widget must have a renderValue function");
      }
  
      // For static rendering (non-Shiny), use a simple widget registration
      // scheme. We also use this scheme for Shiny apps/documents that also
      // contain static widgets.
      window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
      // Merge defaults into the definition; don't mutate the original definition.
      var staticBinding = extend({}, defaults, definition);
      overrideMethod(staticBinding, "find", function(superfunc) {
        return function(scope) {
          var results = superfunc(scope);
          // Filter out Shiny outputs, we only want the static kind
          return filterByClass(results, "html-widget-output", false);
        };
      });
      window.HTMLWidgets.widgets.push(staticBinding);
  
      if (shinyMode) {
        // Shiny is running. Register the definition with an output binding.
        // The definition itself will not be the output binding, instead
        // we will make an output binding object that delegates to the
        // definition. This is because we foolishly used the same method
        // name (renderValue) for htmlwidgets definition and Shiny bindings
        // but they actually have quite different semantics (the Shiny
        // bindings receive data that includes lots of metadata that it
        // strips off before calling htmlwidgets renderValue). We can't
        // just ignore the difference because in some widgets it's helpful
        // to call this.renderValue() from inside of resize(), and if
        // we're not delegating, then that call will go to the Shiny
        // version instead of the htmlwidgets version.
  
        // Merge defaults with definition, without mutating either.
        var bindingDef = extend({}, defaults, definition);
  
        // This object will be our actual Shiny binding.
        var shinyBinding = new Shiny.OutputBinding();
  
        // With a few exceptions, we'll want to simply use the bindingDef's
        // version of methods if they are available, otherwise fall back to
        // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
        // methods in the future, and we want them to be overrideable by
        // HTMLWidget binding definitions, then we'll need to add them to this
        // list.
        delegateMethod(shinyBinding, bindingDef, "getId");
        delegateMethod(shinyBinding, bindingDef, "onValueChange");
        delegateMethod(shinyBinding, bindingDef, "onValueError");
        delegateMethod(shinyBinding, bindingDef, "renderError");
        delegateMethod(shinyBinding, bindingDef, "clearError");
        delegateMethod(shinyBinding, bindingDef, "showProgress");
  
        // The find, renderValue, and resize are handled differently, because we
        // want to actually decorate the behavior of the bindingDef methods.
  
        shinyBinding.find = function(scope) {
          var results = bindingDef.find(scope);
  
          // Only return elements that are Shiny outputs, not static ones
          var dynamicResults = results.filter(".html-widget-output");
  
          // It's possible that whatever caused Shiny to think there might be
          // new dynamic outputs, also caused there to be new static outputs.
          // Since there might be lots of different htmlwidgets bindings, we
          // schedule execution for later--no need to staticRender multiple
          // times.
          if (results.length !== dynamicResults.length)
            scheduleStaticRender();
  
          return dynamicResults;
        };
  
        // Wrap renderValue to handle initialization, which unfortunately isn't
        // supported natively by Shiny at the time of this writing.
  
        shinyBinding.renderValue = function(el, data) {
          Shiny.renderDependencies(data.deps);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var i = 0; data.evals && i < data.evals.length; i++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
          }
          if (!bindingDef.renderOnNullValue) {
            if (data.x === null) {
              el.style.visibility = "hidden";
              return;
            } else {
              el.style.visibility = "inherit";
            }
          }
          if (!elementData(el, "initialized")) {
            initSizing(el);
  
            elementData(el, "initialized", true);
            if (bindingDef.initialize) {
              var result = bindingDef.initialize(el, el.offsetWidth,
                el.offsetHeight);
              elementData(el, "init_result", result);
            }
          }
          bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
          evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
        };
  
        // Only override resize if bindingDef implements it
        if (bindingDef.resize) {
          shinyBinding.resize = function(el, width, height) {
            // Shiny can call resize before initialize/renderValue have been
            // called, which doesn't make sense for widgets.
            if (elementData(el, "initialized")) {
              bindingDef.resize(el, width, height, elementData(el, "init_result"));
            }
          };
        }
  
        Shiny.outputBindings.register(shinyBinding, bindingDef.name);
      }
    };
  
    var scheduleStaticRenderTimerId = null;
    function scheduleStaticRender() {
      if (!scheduleStaticRenderTimerId) {
        scheduleStaticRenderTimerId = setTimeout(function() {
          scheduleStaticRenderTimerId = null;
          window.HTMLWidgets.staticRender();
        }, 1);
      }
    }
  
    // Render static widgets after the document finishes loading
    // Statically render all elements that are of this widget's class
    window.HTMLWidgets.staticRender = function() {
      var bindings = window.HTMLWidgets.widgets || [];
      forEach(bindings, function(binding) {
        var matches = binding.find(document.documentElement);
        forEach(matches, function(el) {
          var sizeObj = initSizing(el, binding);
  
          if (hasClass(el, "html-widget-static-bound"))
            return;
          el.className = el.className + " html-widget-static-bound";
  
          var initResult;
          if (binding.initialize) {
            initResult = binding.initialize(el,
              sizeObj ? sizeObj.getWidth() : el.offsetWidth,
              sizeObj ? sizeObj.getHeight() : el.offsetHeight
            );
            elementData(el, "init_result", initResult);
          }
  
          if (binding.resize) {
            var lastSize = {
              w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
              h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
            };
            var resizeHandler = function(e) {
              var size = {
                w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
                h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
              };
              if (size.w === 0 && size.h === 0)
                return;
              if (size.w === lastSize.w && size.h === lastSize.h)
                return;
              lastSize = size;
              binding.resize(el, size.w, size.h, initResult);
            };
  
            on(window, "resize", resizeHandler);
  
            // This is needed for cases where we're running in a Shiny
            // app, but the widget itself is not a Shiny output, but
            // rather a simple static widget. One example of this is
            // an rmarkdown document that has runtime:shiny and widget
            // that isn't in a render function. Shiny only knows to
            // call resize handlers for Shiny outputs, not for static
            // widgets, so we do it ourselves.
            if (window.jQuery) {
              window.jQuery(document).on(
                "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
                resizeHandler
              );
              window.jQuery(document).on(
                "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
                resizeHandler
              );
            }
  
            // This is needed for the specific case of ioslides, which
            // flips slides between display:none and display:block.
            // Ideally we would not have to have ioslide-specific code
            // here, but rather have ioslides raise a generic event,
            // but the rmarkdown package just went to CRAN so the
            // window to getting that fixed may be long.
            if (window.addEventListener) {
              // It's OK to limit this to window.addEventListener
              // browsers because ioslides itself only supports
              // such browsers.
              on(document, "slideenter", resizeHandler);
              on(document, "slideleave", resizeHandler);
            }
          }
  
          var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
          if (scriptData) {
            var data = JSON.parse(scriptData.textContent || scriptData.text);
            // Resolve strings marked as javascript literals to objects
            if (!(data.evals instanceof Array)) data.evals = [data.evals];
            for (var k = 0; data.evals && k < data.evals.length; k++) {
              window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
            }
            binding.renderValue(el, data.x, initResult);
            evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
          }
        });
      });
  
      invokePostRenderHandlers();
    }
  
  
    function has_jQuery3() {
      if (!window.jQuery) {
        return false;
      }
      var $version = window.jQuery.fn.jquery;
      var $major_version = parseInt($version.split(".")[0]);
      return $major_version >= 3;
    }
  
    /*
    / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
    / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
    / really means $(setTimeout(fn)).
    / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
    /
    / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
    / one tick later than it did before, which means staticRender() is
    / called renderValue() earlier than (advanced) widget authors might be expecting.
    / https://github.com/rstudio/shiny/issues/2630
    /
    / For a concrete example, leaflet has some methods (e.g., updateBounds)
    / which reference Shiny methods registered in initShiny (e.g., setInputValue).
    / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
    / delay execution of those methods (until Shiny methods are ready)
    / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
    /
    / Ideally widget authors wouldn't need to use this setTimeout() hack that
    / leaflet uses to call Shiny methods on a staticRender(). In the long run,
    / the logic initShiny should be broken up so that method registration happens
    / right away, but binding happens later.
    */
    function maybeStaticRenderLater() {
      if (shinyMode && has_jQuery3()) {
        window.jQuery(window.HTMLWidgets.staticRender);
      } else {
        window.HTMLWidgets.staticRender();
      }
    }
  
    if (document.addEventListener) {
      document.addEventListener("DOMContentLoaded", function() {
        document.removeEventListener("DOMContentLoaded", arguments.callee, false);
        maybeStaticRenderLater();
      }, false);
    } else if (document.attachEvent) {
      document.attachEvent("onreadystatechange", function() {
        if (document.readyState === "complete") {
          document.detachEvent("onreadystatechange", arguments.callee);
          maybeStaticRenderLater();
        }
      });
    }
  
  
    window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
      // If no key, default to the first item
      if (typeof(key) === "undefined")
        key = 1;
  
      var link = document.getElementById(depname + "-" + key + "-attachment");
      if (!link) {
        throw new Error("Attachment " + depname + "/" + key + " not found in document");
      }
      return link.getAttribute("href");
    };
  
    window.HTMLWidgets.dataframeToD3 = function(df) {
      var names = [];
      var length;
      for (var name in df) {
          if (df.hasOwnProperty(name))
              names.push(name);
          if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
              throw new Error("All fields must be arrays");
          } else if (typeof(length) !== "undefined" && length !== df[name].length) {
              throw new Error("All fields must be arrays of the same length");
          }
          length = df[name].length;
      }
      var results = [];
      var item;
      for (var row = 0; row < length; row++) {
          item = {};
          for (var col = 0; col < names.length; col++) {
              item[names[col]] = df[names[col]][row];
          }
          results.push(item);
      }
      return results;
    };
  
    window.HTMLWidgets.transposeArray2D = function(array) {
        if (array.length === 0) return array;
        var newArray = array[0].map(function(col, i) {
            return array.map(function(row) {
                return row[i]
            })
        });
        return newArray;
    };
    // Split value at splitChar, but allow splitChar to be escaped
    // using escapeChar. Any other characters escaped by escapeChar
    // will be included as usual (including escapeChar itself).
    function splitWithEscape(value, splitChar, escapeChar) {
      var results = [];
      var escapeMode = false;
      var currentResult = "";
      for (var pos = 0; pos < value.length; pos++) {
        if (!escapeMode) {
          if (value[pos] === splitChar) {
            results.push(currentResult);
            currentResult = "";
          } else if (value[pos] === escapeChar) {
            escapeMode = true;
          } else {
            currentResult += value[pos];
          }
        } else {
          currentResult += value[pos];
          escapeMode = false;
        }
      }
      if (currentResult !== "") {
        results.push(currentResult);
      }
      return results;
    }
    // Function authored by Yihui/JJ Allaire
    window.HTMLWidgets.evaluateStringMember = function(o, member) {
      var parts = splitWithEscape(member, '.', '\\');
      for (var i = 0, l = parts.length; i < l; i++) {
        var part = parts[i];
        // part may be a character or 'numeric' member name
        if (o !== null && typeof o === "object" && part in o) {
          if (i == (l - 1)) { // if we are at the end of the line then evalulate
            if (typeof o[part] === "string")
              o[part] = tryEval(o[part]);
          } else { // otherwise continue to next embedded object
            o = o[part];
          }
        }
      }
    };
  
    // Retrieve the HTMLWidget instance (i.e. the return value of an
    // HTMLWidget binding's initialize() or factory() function)
    // associated with an element, or null if none.
    window.HTMLWidgets.getInstance = function(el) {
      return elementData(el, "init_result");
    };
  
    // Finds the first element in the scope that matches the selector,
    // and returns the HTMLWidget instance (i.e. the return value of
    // an HTMLWidget binding's initialize() or factory() function)
    // associated with that element, if any. If no element matches the
    // selector, or the first matching element has no HTMLWidget
    // instance associated with it, then null is returned.
    //
    // The scope argument is optional, and defaults to window.document.
    window.HTMLWidgets.find = function(scope, selector) {
      if (arguments.length == 1) {
        selector = scope;
        scope = document;
      }
  
      var el = scope.querySelector(selector);
      if (el === null) {
        return null;
      } else {
        return window.HTMLWidgets.getInstance(el);
      }
    };
  
    // Finds all elements in the scope that match the selector, and
    // returns the HTMLWidget instances (i.e. the return values of
    // an HTMLWidget binding's initialize() or factory() function)
    // associated with the elements, in an array. If elements that
    // match the selector don't have an associated HTMLWidget
    // instance, the returned array will contain nulls.
    //
    // The scope argument is optional, and defaults to window.document.
    window.HTMLWidgets.findAll = function(scope, selector) {
      if (arguments.length == 1) {
        selector = scope;
        scope = document;
      }
  
      var nodes = scope.querySelectorAll(selector);
      var results = [];
      for (var i = 0; i < nodes.length; i++) {
        results.push(window.HTMLWidgets.getInstance(nodes[i]));
      }
      return results;
    };
  
    var postRenderHandlers = [];
    function invokePostRenderHandlers() {
      while (postRenderHandlers.length) {
        var handler = postRenderHandlers.shift();
        if (handler) {
          handler();
        }
      }
    }
  
    // Register the given callback function to be invoked after the
    // next time static widgets are rendered.
    window.HTMLWidgets.addPostRenderHandler = function(callback) {
      postRenderHandlers.push(callback);
    };
  
    // Takes a new-style instance-bound definition, and returns an
    // old-style class-bound definition. This saves us from having
    // to rewrite all the logic in this file to accomodate both
    // types of definitions.
    function createLegacyDefinitionAdapter(defn) {
      var result = {
        name: defn.name,
        type: defn.type,
        initialize: function(el, width, height) {
          return defn.factory(el, width, height);
        },
        renderValue: function(el, x, instance) {
          return instance.renderValue(x);
        },
        resize: function(el, width, height, instance) {
          return instance.resize(width, height);
        }
      };
  
      if (defn.find)
        result.find = defn.find;
      if (defn.renderError)
        result.renderError = defn.renderError;
      if (defn.clearError)
        result.clearError = defn.clearError;
  
      return result;
    }
  })();
  
  </script>
  <style type="text/css">
  .nvd3 .nv-axis {pointer-events:none;opacity: 1;}.nvd3 .nv-axis path {fill: none;stroke: #000;stroke-opacity: .75;shape-rendering: crispEdges;}.nvd3 .nv-axis path.domain {stroke-opacity: .75;}.nvd3 .nv-axis.nv-x path.domain {stroke-opacity: 0;}.nvd3 .nv-axis line {fill: none;stroke: #e5e5e5;shape-rendering: crispEdges;}.nvd3 .nv-axis .zero line, .nvd3 .nv-axis line.zero {stroke-opacity: .75;}.nvd3 .nv-axis .nv-axisMaxMin text {font-weight: bold;}.nvd3 .x .nv-axis .nv-axisMaxMin text,.nvd3 .x2 .nv-axis .nv-axisMaxMin text,.nvd3 .x3 .nv-axis .nv-axisMaxMin text {text-anchor: middle;}.nvd3 .nv-axis.nv-disabled {opacity: 0;}.nvd3 .nv-bars rect {fill-opacity: .75;transition: fill-opacity 250ms linear;}
  .nvd3 .nv-bars rect.hover {fill-opacity: 1;}.nvd3 .nv-bars .hover rect {fill: lightblue;}.nvd3 .nv-bars text {fill: rgba(0,0,0,0);}.nvd3 .nv-bars .hover text {fill: rgba(0,0,0,1);}.nvd3 .nv-multibar .nv-groups rect,.nvd3 .nv-multibarHorizontal .nv-groups rect,.nvd3 .nv-discretebar .nv-groups rect {stroke-opacity: 0;transition: fill-opacity 250ms linear;}
  .nvd3 .nv-multibar .nv-groups rect:hover,.nvd3 .nv-multibarHorizontal .nv-groups rect:hover,.nvd3 .nv-candlestickBar .nv-ticks rect:hover,.nvd3 .nv-discretebar .nv-groups rect:hover {fill-opacity: 1;}.nvd3 .nv-discretebar .nv-groups text,.nvd3 .nv-multibarHorizontal .nv-groups text {font-weight: bold;fill: rgba(0,0,0,1);stroke: rgba(0,0,0,0);}
  .nvd3 .nv-boxplot circle {
  fill-opacity: 0.5;
  }
  .nvd3 .nv-boxplot circle:hover {
  fill-opacity: 1;
  }
  .nvd3 .nv-boxplot rect:hover {
  fill-opacity: 1;
  }
  .nvd3 line.nv-boxplot-median {
  stroke: black;
  }
  .nv-boxplot-tick:hover {
  stroke-width: 2.5px;
  }
  .nvd3.nv-bullet { font: 10px sans-serif; }.nvd3.nv-bullet .nv-measure { fill-opacity: .8; }.nvd3.nv-bullet .nv-measure:hover { fill-opacity: 1; }.nvd3.nv-bullet .nv-marker { stroke: #000; stroke-width: 2px; }.nvd3.nv-bullet .nv-markerTriangle { stroke: #000; fill: #fff; stroke-width: 1.5px; }.nvd3.nv-bullet .nv-markerLine { stroke: #000; stroke-width: 1.5px; }.nvd3.nv-bullet .nv-tick line { stroke: #666; stroke-width: .5px; }.nvd3.nv-bullet .nv-range.nv-s0 { fill: #eee; }.nvd3.nv-bullet .nv-range.nv-s1 { fill: #ddd; }.nvd3.nv-bullet .nv-range.nv-s2 { fill: #ccc; }.nvd3.nv-bullet .nv-title { font-size: 14px; font-weight: bold; }.nvd3.nv-bullet .nv-subtitle { fill: #999; }.nvd3.nv-bullet .nv-range {
  fill: #bababa;fill-opacity: .4;}
  .nvd3.nv-bullet .nv-range:hover {fill-opacity: .7;}.nvd3.nv-candlestickBar .nv-ticks .nv-tick {stroke-width: 1px;}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.hover {stroke-width: 2px;}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.positive rect {stroke: #2ca02c;fill: #2ca02c;}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.negative rect {stroke: #d62728;fill: #d62728;}.with-transitions .nv-candlestickBar .nv-ticks .nv-tick {transition: stroke-width 250ms linear, stroke-opacity 250ms linear;}
  .nvd3.nv-candlestickBar .nv-ticks line {stroke: #333;}.nv-force-node {
  stroke: #fff;
  stroke-width: 1.5px;
  }
  .nv-force-link {
  stroke: #999;
  stroke-opacity: .6;
  }
  .nv-force-node text {
  stroke-width: 0px;
  }
  .nvd3 .nv-legend .nv-disabled rect {
  
  }
  .nvd3 .nv-check-box .nv-box {
  fill-opacity:0;
  stroke-width:2;
  }
  .nvd3 .nv-check-box .nv-check {
  fill-opacity:0;
  stroke-width:4;
  }
  .nvd3 .nv-series.nv-disabled .nv-check-box .nv-check {
  fill-opacity:0;
  stroke-opacity:0;
  }
  .nvd3 .nv-controlsWrap .nv-legend .nv-check-box .nv-check {
  opacity: 0;
  }
  .nvd3.nv-linePlusBar .nv-bar rect {fill-opacity: .75;}.nvd3.nv-linePlusBar .nv-bar rect:hover {fill-opacity: 1;}
  .nvd3 .nv-groups path.nv-line {fill: none;}.nvd3 .nv-groups path.nv-area {stroke: none;}.nvd3.nv-line .nvd3.nv-scatter .nv-groups .nv-point {fill-opacity: 0;stroke-opacity: 0;}.nvd3.nv-scatter.nv-single-point .nv-groups .nv-point {fill-opacity: .5 !important;stroke-opacity: .5 !important;}.with-transitions .nvd3 .nv-groups .nv-point {transition: stroke-width 250ms linear, stroke-opacity 250ms linear;}
  .nvd3.nv-scatter .nv-groups .nv-point.hover,.nvd3 .nv-groups .nv-point.hover {stroke-width: 7px;fill-opacity: .95 !important;stroke-opacity: .95 !important;}.nvd3 .nv-point-paths path {stroke: #aaa;stroke-opacity: 0;fill: #eee;fill-opacity: 0;}.nvd3 .nv-indexLine {
  cursor: ew-resize;}svg.nvd3-svg {-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;
  display: block;width:100%;height:100%;}.nvtooltip.with-3d-shadow, .with-3d-shadow .nvtooltip {box-shadow: 0 5px 10px rgba(0,0,0,.2);
  border-radius: 5px;
  }.nvd3 text {font: normal 12px Arial, sans-serif;}.nvd3 .title {font: bold 14px Arial, sans-serif;}.nvd3 .nv-background {fill: white;fill-opacity: 0;}.nvd3.nv-noData {font-size: 18px;font-weight: bold;}.nv-brush .extent {fill-opacity: .125;shape-rendering: crispEdges;}.nv-brush .resize path {fill: #eee;stroke: #666;}.nvd3 .nv-legend .nv-series {cursor: pointer;}.nvd3 .nv-legend .nv-disabled circle {fill-opacity: 0;}.nvd3 .nv-brush .extent {fill-opacity: 0 !important;}.nvd3 .nv-brushBackground rect {stroke: #000;stroke-width: .4;fill: #fff;fill-opacity: .7;}@media print {.nvd3 text {
  stroke-width: 0;
  fill-opacity: 1;
  }
  }.nvd3.nv-ohlcBar .nv-ticks .nv-tick {stroke-width: 1px;}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.hover {stroke-width: 2px;}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.positive {stroke: #2ca02c;}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.negative {stroke: #d62728;}.nvd3 .background path {fill: none;stroke: #EEE;stroke-opacity: .4;shape-rendering: crispEdges;}.nvd3 .foreground path {fill: none;stroke-opacity: .7;}.nvd3 .nv-parallelCoordinates-brush .extent {
  fill: #fff;fill-opacity: .6;stroke: gray;shape-rendering: crispEdges;}.nvd3 .nv-parallelCoordinates .hover {fill-opacity: 1;stroke-width: 3px;}.nvd3 .missingValuesline line {fill: none;stroke: black;stroke-width: 1;stroke-opacity: 1;stroke-dasharray: 5, 5;
  }
  .nvd3.nv-pie path {stroke-opacity: 0;transition: fill-opacity 250ms linear, stroke-width 250ms linear, stroke-opacity 250ms linear;}
  .nvd3.nv-pie .nv-pie-title {font-size: 24px;fill: rgba(19, 196, 249, 0.59);}.nvd3.nv-pie .nv-slice text {stroke: #000;stroke-width: 0;}.nvd3.nv-pie path {stroke: #fff;stroke-width: 1px;stroke-opacity: 1;}.nvd3.nv-pie path {fill-opacity: .7;}
  .nvd3.nv-pie .hover path {fill-opacity: 1;}.nvd3.nv-pie .nv-label {
  pointer-events: none;}.nvd3.nv-pie .nv-label rect {
  fill-opacity: 0;stroke-opacity: 0;}.nvd3 .nv-groups .nv-point.hover {stroke-width: 20px;stroke-opacity: .5;}.nvd3 .nv-scatter .nv-point.hover {fill-opacity: 1;}
  .nv-noninteractive {pointer-events: none;}.nv-distx, .nv-disty {pointer-events: none;}.nvd3.nv-sparkline path {fill: none;}.nvd3.nv-sparklineplus g.nv-hoverValue {pointer-events: none;}.nvd3.nv-sparklineplus .nv-hoverValue line {stroke: #333;stroke-width: 1.5px;}.nvd3.nv-sparklineplus,.nvd3.nv-sparklineplus g {pointer-events: all;}.nvd3 .nv-hoverArea {fill-opacity: 0;stroke-opacity: 0;}.nvd3.nv-sparklineplus .nv-xValue,.nvd3.nv-sparklineplus .nv-yValue {stroke-width: 0;font-size: .9em;font-weight: normal;}.nvd3.nv-sparklineplus .nv-yValue {stroke: #f66;}.nvd3.nv-sparklineplus .nv-maxValue {stroke: #2ca02c;fill: #2ca02c;}.nvd3.nv-sparklineplus .nv-minValue {stroke: #d62728;fill: #d62728;}.nvd3.nv-sparklineplus .nv-currentValue {font-weight: bold;font-size: 1.1em;}
  .nvd3.nv-stackedarea path.nv-area {fill-opacity: .7;stroke-opacity: 0;transition: fill-opacity 250ms linear, stroke-opacity 250ms linear;}
  .nvd3.nv-stackedarea path.nv-area.hover {fill-opacity: .9;}.nvd3.nv-stackedarea .nv-groups .nv-point {stroke-opacity: 0;fill-opacity: 0;}
  .nvtooltip {
  position: absolute;background-color: rgba(255,255,255,1.0);color: rgba(0,0,0,1.0);padding: 1px;border: 1px solid rgba(0,0,0,.2);z-index: 10000;display: block;font-family: Arial, sans-serif;font-size: 13px;text-align: left;pointer-events: none;white-space: nowrap;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;
  }
  .nvtooltip {background: rgba(255,255,255, 0.8);border: 1px solid rgba(0,0,0,0.5);border-radius: 4px;}.nvtooltip.with-transitions, .with-transitions .nvtooltip {transition: opacity 50ms linear;transition-delay: 200ms;
  }
  .nvtooltip.x-nvtooltip,.nvtooltip.y-nvtooltip {padding: 8px;}.nvtooltip h3 {margin: 0;padding: 4px 14px;line-height: 18px;font-weight: normal;background-color: rgba(247,247,247,0.75);color: rgba(0,0,0,1.0);text-align: center;border-bottom: 1px solid #ebebeb;border-radius: 5px 5px 0 0;
  }.nvtooltip p {margin: 0;padding: 5px 14px;text-align: center;}.nvtooltip span {display: inline-block;margin: 2px 0;}.nvtooltip table {margin: 6px;border-spacing:0;}.nvtooltip table td {padding: 2px 9px 2px 0;vertical-align: middle;}.nvtooltip table td.key {font-weight: normal;}
  .nvtooltip table td.key.total {font-weight: bold;}.nvtooltip table td.value {
  text-align: right;font-weight: bold;}.nvtooltip table td.percent {color: darkgray;}.nvtooltip table tr.highlight td {padding: 1px 9px 1px 0;border-bottom-style: solid;border-bottom-width: 1px;border-top-style: solid;border-top-width: 1px;}.nvtooltip table td.legend-color-guide div {width: 8px;height: 8px;vertical-align: middle;}.nvtooltip table td.legend-color-guide div {width: 12px;height: 12px;border: 1px solid #999;}.nvtooltip .footer {padding: 3px;text-align: center;}.nvtooltip-pending-removal {pointer-events: none;display: none;}.nvd3 .nv-interactiveGuideLine {pointer-events:none;}
  .nvd3 line.nv-guideline {stroke: #ccc;}</style>
  <script>!function(){function n(n,t){return t>n?-1:n>t?1:n>=t?0:0/0}function t(n){return null===n?0/0:+n}function e(n){return!isNaN(n)}function r(n){return{left:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n(t[i],e)<0?r=i+1:u=i}return r},right:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n(t[i],e)>0?u=i:r=i+1}return r}}}function u(n){return n.length}function i(n){for(var t=1;n*t%1;)t*=10;return t}function o(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function a(){this._=Object.create(null)}function c(n){return(n+="")===da||n[0]===ma?ma+n:n}function l(n){return(n+="")[0]===ma?n.slice(1):n}function s(n){return c(n)in this._}function f(n){return(n=c(n))in this._&&delete this._[n]}function h(){var n=[];for(var t in this._)n.push(l(t));return n}function g(){var n=0;for(var t in this._)++n;return n}function p(){for(var n in this._)return!1;return!0}function v(){this._=Object.create(null)}function d(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function m(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=ya.length;r>e;++e){var u=ya[e]+t;if(u in n)return u}}function y(){}function M(){}function x(n){function t(){for(var t,r=e,u=-1,i=r.length;++u<i;)(t=r[u].on)&&t.apply(this,arguments);return n}var e=[],r=new a;return t.on=function(t,u){var i,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,i=e.indexOf(o)).concat(e.slice(i+1)),r.remove(t)),u&&e.push(r.set(t,{on:u})),n)},t}function b(){ta.event.preventDefault()}function _(){for(var n,t=ta.event;n=t.sourceEvent;)t=n;return t}function w(n){for(var t=new M,e=0,r=arguments.length;++e<r;)t[arguments[e]]=x(t);return t.of=function(e,r){return function(u){try{var i=u.sourceEvent=ta.event;u.target=n,ta.event=u,t[u.type].apply(e,r)}finally{ta.event=i}}},t}function S(n){return xa(n,ka),n}function k(n){return"function"==typeof n?n:function(){return ba(n,this)}}function E(n){return"function"==typeof n?n:function(){return _a(n,this)}}function A(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function u(){this.setAttribute(n,t)}function i(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ta.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?i:u}function N(n){return n.trim().replace(/\s+/g," ")}function C(n){return new RegExp("(?:^|\\s+)"+ta.requote(n)+"(?:\\s+|$)","g")}function z(n){return(n+"").trim().split(/^|\s+/)}function q(n,t){function e(){for(var e=-1;++e<u;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<u;)n[e](this,r)}n=z(n).map(L);var u=n.length;return"function"==typeof t?r:e}function L(n){var t=C(n);return function(e,r){if(u=e.classList)return r?u.add(n):u.remove(n);var u=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(u)||e.setAttribute("class",N(u+" "+n))):e.setAttribute("class",N(u.replace(t," ")))}}function T(n,t,e){function r(){this.style.removeProperty(n)}function u(){this.style.setProperty(n,t,e)}function i(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?i:u}function R(n,t){function e(){delete this[n]}function r(){this[n]=t}function u(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?u:r}function D(n){return"function"==typeof n?n:(n=ta.ns.qualify(n)).local?function(){return this.ownerDocument.createElementNS(n.space,n.local)}:function(){return this.ownerDocument.createElementNS(this.namespaceURI,n)}}function P(){var n=this.parentNode;n&&n.removeChild(this)}function U(n){return{__data__:n}}function j(n){return function(){return Sa(this,n)}}function F(t){return arguments.length||(t=n),function(n,e){return n&&e?t(n.__data__,e.__data__):!n-!e}}function H(n,t){for(var e=0,r=n.length;r>e;e++)for(var u,i=n[e],o=0,a=i.length;a>o;o++)(u=i[o])&&t(u,o,e);return n}function O(n){return xa(n,Aa),n}function Y(n){var t,e;return function(r,u,i){var o,a=n[i].update,c=a.length;for(i!=e&&(e=i,t=0),u>=t&&(t=u+1);!(o=a[t])&&++t<c;);return o}}function I(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function u(){var u=c(t,ra(arguments));r.call(this),this.addEventListener(n,this[o]=u,u.$=e),u._=t}function i(){var t,e=new RegExp("^__on([^.]+)"+ta.requote(n)+"$");for(var r in this)if(t=r.match(e)){var u=this[r];this.removeEventListener(t[1],u,u.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),c=Z;a>0&&(n=n.slice(0,a));var l=Ca.get(n);return l&&(n=l,c=V),a?t?u:r:t?y:i}function Z(n,t){return function(e){var r=ta.event;ta.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ta.event=r}}}function V(n,t){var e=Z(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function X(){var n=".dragsuppress-"+ ++qa,t="click"+n,e=ta.select(oa).on("touchmove"+n,b).on("dragstart"+n,b).on("selectstart"+n,b);if(za){var r=ia.style,u=r[za];r[za]="none"}return function(i){if(e.on(n,null),za&&(r[za]=u),i){var o=function(){e.on(t,null)};e.on(t,function(){b(),o()},!0),setTimeout(o,0)}}}function $(n,t){t.changedTouches&&(t=t.changedTouches[0]);var e=n.ownerSVGElement||n;if(e.createSVGPoint){var r=e.createSVGPoint();if(0>La&&(oa.scrollX||oa.scrollY)){e=ta.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var u=e[0][0].getScreenCTM();La=!(u.f||u.e),e.remove()}return La?(r.x=t.pageX,r.y=t.pageY):(r.x=t.clientX,r.y=t.clientY),r=r.matrixTransform(n.getScreenCTM().inverse()),[r.x,r.y]}var i=n.getBoundingClientRect();return[t.clientX-i.left-n.clientLeft,t.clientY-i.top-n.clientTop]}function B(){return ta.event.changedTouches[0].identifier}function W(){return ta.event.target}function J(){return oa}function G(n){return n>0?1:0>n?-1:0}function K(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function Q(n){return n>1?0:-1>n?Da:Math.acos(n)}function nt(n){return n>1?ja:-1>n?-ja:Math.asin(n)}function tt(n){return((n=Math.exp(n))-1/n)/2}function et(n){return((n=Math.exp(n))+1/n)/2}function rt(n){return((n=Math.exp(2*n))-1)/(n+1)}function ut(n){return(n=Math.sin(n/2))*n}function it(){}function ot(n,t,e){return this instanceof ot?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof ot?new ot(n.h,n.s,n.l):xt(""+n,bt,ot):new ot(n,t,e)}function at(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?i+(o-i)*n/60:180>n?o:240>n?i+(o-i)*(240-n)/60:i}function u(n){return Math.round(255*r(n))}var i,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,i=2*e-o,new dt(u(n+120),u(n),u(n-120))}function ct(n,t,e){return this instanceof ct?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof ct?new ct(n.h,n.c,n.l):n instanceof st?ht(n.l,n.a,n.b):ht((n=_t((n=ta.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new ct(n,t,e)}function lt(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new st(e,Math.cos(n*=Fa)*t,Math.sin(n)*t)}function st(n,t,e){return this instanceof st?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof st?new st(n.l,n.a,n.b):n instanceof ct?lt(n.h,n.c,n.l):_t((n=dt(n)).r,n.g,n.b):new st(n,t,e)}function ft(n,t,e){var r=(n+16)/116,u=r+t/500,i=r-e/200;return u=gt(u)*Ja,r=gt(r)*Ga,i=gt(i)*Ka,new dt(vt(3.2404542*u-1.5371385*r-.4985314*i),vt(-.969266*u+1.8760108*r+.041556*i),vt(.0556434*u-.2040259*r+1.0572252*i))}function ht(n,t,e){return n>0?new ct(Math.atan2(e,t)*Ha,Math.sqrt(t*t+e*e),n):new ct(0/0,0/0,n)}function gt(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function pt(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function vt(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function dt(n,t,e){return this instanceof dt?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof dt?new dt(n.r,n.g,n.b):xt(""+n,dt,at):new dt(n,t,e)}function mt(n){return new dt(n>>16,255&n>>8,255&n)}function yt(n){return mt(n)+""}function Mt(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function xt(n,t,e){var r,u,i,o=0,a=0,c=0;if(r=/([a-z]+)\((.*)\)/i.exec(n))switch(u=r[2].split(","),r[1]){case"hsl":return e(parseFloat(u[0]),parseFloat(u[1])/100,parseFloat(u[2])/100);case"rgb":return t(St(u[0]),St(u[1]),St(u[2]))}return(i=tc.get(n))?t(i.r,i.g,i.b):(null==n||"#"!==n.charAt(0)||isNaN(i=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&i)>>4,o=o>>4|o,a=240&i,a=a>>4|a,c=15&i,c=c<<4|c):7===n.length&&(o=(16711680&i)>>16,a=(65280&i)>>8,c=255&i)),t(o,a,c))}function bt(n,t,e){var r,u,i=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-i,c=(o+i)/2;return a?(u=.5>c?a/(o+i):a/(2-o-i),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=0/0,u=c>0&&1>c?0:r),new ot(r,u,c)}function _t(n,t,e){n=wt(n),t=wt(t),e=wt(e);var r=pt((.4124564*n+.3575761*t+.1804375*e)/Ja),u=pt((.2126729*n+.7151522*t+.072175*e)/Ga),i=pt((.0193339*n+.119192*t+.9503041*e)/Ka);return st(116*u-16,500*(r-u),200*(u-i))}function wt(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function St(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function kt(n){return"function"==typeof n?n:function(){return n}}function Et(n){return n}function At(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Nt(t,e,n,r)}}function Nt(n,t,e,r){function u(){var n,t=c.status;if(!t&&zt(c)||t>=200&&300>t||304===t){try{n=e.call(i,c)}catch(r){return o.error.call(i,r),void 0}o.load.call(i,n)}else o.error.call(i,c)}var i={},o=ta.dispatch("beforesend","progress","load","error"),a={},c=new XMLHttpRequest,l=null;return!oa.XDomainRequest||"withCredentials"in c||!/^(http(s)?:)?\/\//.test(n)||(c=new XDomainRequest),"onload"in c?c.onload=c.onerror=u:c.onreadystatechange=function(){c.readyState>3&&u()},c.onprogress=function(n){var t=ta.event;ta.event=n;try{o.progress.call(i,c)}finally{ta.event=t}},i.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",i)},i.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",i):t},i.responseType=function(n){return arguments.length?(l=n,i):l},i.response=function(n){return e=n,i},["get","post"].forEach(function(n){i[n]=function(){return i.send.apply(i,[n].concat(ra(arguments)))}}),i.send=function(e,r,u){if(2===arguments.length&&"function"==typeof r&&(u=r,r=null),c.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),c.setRequestHeader)for(var s in a)c.setRequestHeader(s,a[s]);return null!=t&&c.overrideMimeType&&c.overrideMimeType(t),null!=l&&(c.responseType=l),null!=u&&i.on("error",u).on("load",function(n){u(null,n)}),o.beforesend.call(i,c),c.send(null==r?null:r),i},i.abort=function(){return c.abort(),i},ta.rebind(i,o,"on"),null==r?i:i.get(Ct(r))}function Ct(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function zt(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qt(){var n=Lt(),t=Tt()-n;t>24?(isFinite(t)&&(clearTimeout(ic),ic=setTimeout(qt,t)),uc=0):(uc=1,ac(qt))}function Lt(){var n=Date.now();for(oc=ec;oc;)n>=oc.t&&(oc.f=oc.c(n-oc.t)),oc=oc.n;return n}function Tt(){for(var n,t=ec,e=1/0;t;)t.f?t=n?n.n=t.n:ec=t.n:(t.t<e&&(e=t.t),t=(n=t).n);return rc=n,e}function Rt(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Dt(n,t){var e=Math.pow(10,3*va(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function Pt(n){var t=n.decimal,e=n.thousands,r=n.grouping,u=n.currency,i=r&&e?function(n,t){for(var u=n.length,i=[],o=0,a=r[0],c=0;u>0&&a>0&&(c+a+1>t&&(a=Math.max(1,t-c)),i.push(n.substring(u-=a,u+a)),!((c+=a+1)>t));)a=r[o=(o+1)%r.length];return i.reverse().join(e)}:Et;return function(n){var e=lc.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",c=e[4]||"",l=e[5],s=+e[6],f=e[7],h=e[8],g=e[9],p=1,v="",d="",m=!1,y=!0;switch(h&&(h=+h.substring(1)),(l||"0"===r&&"="===o)&&(l=r="0",o="="),g){case"n":f=!0,g="g";break;case"%":p=100,d="%",g="f";break;case"p":p=100,d="%",g="r";break;case"b":case"o":case"x":case"X":"#"===c&&(v="0"+g.toLowerCase());case"c":y=!1;case"d":m=!0,h=0;break;case"s":p=-1,g="r"}"$"===c&&(v=u[0],d=u[1]),"r"!=g||h||(g="g"),null!=h&&("g"==g?h=Math.max(1,Math.min(21,h)):("e"==g||"f"==g)&&(h=Math.max(0,Math.min(20,h)))),g=sc.get(g)||Ut;var M=l&&f;return function(n){var e=d;if(m&&n%1)return"";var u=0>n||0===n&&0>1/n?(n=-n,"-"):"-"===a?"":a;if(0>p){var c=ta.formatPrefix(n,h);n=c.scale(n),e=c.symbol+d}else n*=p;n=g(n,h);var x,b,_=n.lastIndexOf(".");if(0>_){var w=y?n.lastIndexOf("e"):-1;0>w?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!l&&f&&(x=i(x,1/0));var S=v.length+x.length+b.length+(M?0:u.length),k=s>S?new Array(S=s-S+1).join(r):"";return M&&(x=i(k+x,k.length?s-b.length:1/0)),u+=v,n=x+b,("<"===o?u+n+k:">"===o?k+u+n:"^"===o?k.substring(0,S>>=1)+u+n+k.substring(S):u+(M?n:k+n))+e}}}function Ut(n){return n+""}function jt(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function Ft(n,t,e){function r(t){var e=n(t),r=i(e,1);return r-t>t-e?e:r}function u(e){return t(e=n(new hc(e-1)),1),e}function i(n,e){return t(n=new hc(+n),e),n}function o(n,r,i){var o=u(n),a=[];if(i>1)for(;r>o;)e(o)%i||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{hc=jt;var r=new jt;return r._=n,o(r,t,e)}finally{hc=Date}}n.floor=n,n.round=r,n.ceil=u,n.offset=i,n.range=o;var c=n.utc=Ht(n);return c.floor=c,c.round=Ht(r),c.ceil=Ht(u),c.offset=Ht(i),c.range=a,n}function Ht(n){return function(t,e){try{hc=jt;var r=new jt;return r._=t,n(r,e)._}finally{hc=Date}}}function Ot(n){function t(n){function t(t){for(var e,u,i,o=[],a=-1,c=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(c,a)),null!=(u=pc[e=n.charAt(++a)])&&(e=n.charAt(++a)),(i=N[e])&&(e=i(t,null==u?"e"===e?" ":"0":u)),o.push(e),c=a+1);return o.push(n.slice(c,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},u=e(r,n,t,0);if(u!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var i=null!=r.Z&&hc!==jt,o=new(i?jt:hc);return"j"in r?o.setFullYear(r.y,0,r.j):"w"in r&&("W"in r||"U"in r)?(o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(0|r.Z/100),r.M+r.Z%100,r.S,r.L),i?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var u,i,o,a=0,c=t.length,l=e.length;c>a;){if(r>=l)return-1;if(u=t.charCodeAt(a++),37===u){if(o=t.charAt(a++),i=C[o in pc?t.charAt(a++):o],!i||(r=i(n,e,r))<0)return-1}else if(u!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){E.lastIndex=0;var r=E.exec(t.slice(e));return r?(n.m=A.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,N.c.toString(),t,r)}function c(n,t,r){return e(n,N.x.toString(),t,r)}function l(n,t,r){return e(n,N.X.toString(),t,r)}function s(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var f=n.dateTime,h=n.date,g=n.time,p=n.periods,v=n.days,d=n.shortDays,m=n.months,y=n.shortMonths;t.utc=function(n){function e(n){try{hc=jt;var t=new hc;return t._=n,r(t)}finally{hc=Date}}var r=t(n);return e.parse=function(n){try{hc=jt;var t=r.parse(n);return t&&t._}finally{hc=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ae;var M=ta.map(),x=It(v),b=Zt(v),_=It(d),w=Zt(d),S=It(m),k=Zt(m),E=It(y),A=Zt(y);p.forEach(function(n,t){M.set(n.toLowerCase(),t)});var N={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return y[n.getMonth()]},B:function(n){return m[n.getMonth()]},c:t(f),d:function(n,t){return Yt(n.getDate(),t,2)},e:function(n,t){return Yt(n.getDate(),t,2)},H:function(n,t){return Yt(n.getHours(),t,2)},I:function(n,t){return Yt(n.getHours()%12||12,t,2)},j:function(n,t){return Yt(1+fc.dayOfYear(n),t,3)},L:function(n,t){return Yt(n.getMilliseconds(),t,3)},m:function(n,t){return Yt(n.getMonth()+1,t,2)},M:function(n,t){return Yt(n.getMinutes(),t,2)},p:function(n){return p[+(n.getHours()>=12)]},S:function(n,t){return Yt(n.getSeconds(),t,2)},U:function(n,t){return Yt(fc.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Yt(fc.mondayOfYear(n),t,2)},x:t(h),X:t(g),y:function(n,t){return Yt(n.getFullYear()%100,t,2)},Y:function(n,t){return Yt(n.getFullYear()%1e4,t,4)},Z:ie,"%":function(){return"%"}},C={a:r,A:u,b:i,B:o,c:a,d:Qt,e:Qt,H:te,I:te,j:ne,L:ue,m:Kt,M:ee,p:s,S:re,U:Xt,w:Vt,W:$t,x:c,X:l,y:Wt,Y:Bt,Z:Jt,"%":oe};return t}function Yt(n,t,e){var r=0>n?"-":"",u=(r?-n:n)+"",i=u.length;return r+(e>i?new Array(e-i+1).join(t)+u:u)}function It(n){return new RegExp("^(?:"+n.map(ta.requote).join("|")+")","i")}function Zt(n){for(var t=new a,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function Vt(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Xt(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function $t(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Bt(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Wt(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+2));return r?(n.y=Gt(+r[0]),e+r[0].length):-1}function Jt(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Gt(n){return n+(n>68?1900:2e3)}function Kt(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function Qt(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function ne(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function te(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function ee(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function re(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ue(n,t,e){vc.lastIndex=0;var r=vc.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function ie(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=0|va(t)/60,u=va(t)%60;return e+Yt(r,"0",2)+Yt(u,"0",2)}function oe(n,t,e){dc.lastIndex=0;var r=dc.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ae(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ce(){}function le(n,t,e){var r=e.s=n+t,u=r-n,i=r-u;e.t=n-i+(t-u)}function se(n,t){n&&xc.hasOwnProperty(n.type)&&xc[n.type](n,t)}function fe(n,t,e){var r,u=-1,i=n.length-e;for(t.lineStart();++u<i;)r=n[u],t.point(r[0],r[1],r[2]);t.lineEnd()}function he(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)fe(n[e],t,1);t.polygonEnd()}function ge(){function n(n,t){n*=Fa,t=t*Fa/2+Da/4;var e=n-r,o=e>=0?1:-1,a=o*e,c=Math.cos(t),l=Math.sin(t),s=i*l,f=u*c+s*Math.cos(a),h=s*o*Math.sin(a);_c.add(Math.atan2(h,f)),r=n,u=c,i=l}var t,e,r,u,i;wc.point=function(o,a){wc.point=n,r=(t=o)*Fa,u=Math.cos(a=(e=a)*Fa/2+Da/4),i=Math.sin(a)},wc.lineEnd=function(){n(t,e)}}function pe(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function ve(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function de(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function me(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function ye(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function Me(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function xe(n){return[Math.atan2(n[1],n[0]),nt(n[2])]}function be(n,t){return va(n[0]-t[0])<Ta&&va(n[1]-t[1])<Ta}function _e(n,t){n*=Fa;var e=Math.cos(t*=Fa);we(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function we(n,t,e){++Sc,Ec+=(n-Ec)/Sc,Ac+=(t-Ac)/Sc,Nc+=(e-Nc)/Sc}function Se(){function n(n,u){n*=Fa;var i=Math.cos(u*=Fa),o=i*Math.cos(n),a=i*Math.sin(n),c=Math.sin(u),l=Math.atan2(Math.sqrt((l=e*c-r*a)*l+(l=r*o-t*c)*l+(l=t*a-e*o)*l),t*o+e*a+r*c);kc+=l,Cc+=l*(t+(t=o)),zc+=l*(e+(e=a)),qc+=l*(r+(r=c)),we(t,e,r)}var t,e,r;Dc.point=function(u,i){u*=Fa;var o=Math.cos(i*=Fa);t=o*Math.cos(u),e=o*Math.sin(u),r=Math.sin(i),Dc.point=n,we(t,e,r)}}function ke(){Dc.point=_e}function Ee(){function n(n,t){n*=Fa;var e=Math.cos(t*=Fa),o=e*Math.cos(n),a=e*Math.sin(n),c=Math.sin(t),l=u*c-i*a,s=i*o-r*c,f=r*a-u*o,h=Math.sqrt(l*l+s*s+f*f),g=r*o+u*a+i*c,p=h&&-Q(g)/h,v=Math.atan2(h,g);Lc+=p*l,Tc+=p*s,Rc+=p*f,kc+=v,Cc+=v*(r+(r=o)),zc+=v*(u+(u=a)),qc+=v*(i+(i=c)),we(r,u,i)}var t,e,r,u,i;Dc.point=function(o,a){t=o,e=a,Dc.point=n,o*=Fa;var c=Math.cos(a*=Fa);r=c*Math.cos(o),u=c*Math.sin(o),i=Math.sin(a),we(r,u,i)},Dc.lineEnd=function(){n(t,e),Dc.lineEnd=ke,Dc.point=_e}}function Ae(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function Ne(){return!0}function Ce(n,t,e,r,u){var i=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(be(e,r)){u.lineStart();for(var a=0;t>a;++a)u.point((e=n[a])[0],e[1]);return u.lineEnd(),void 0}var c=new qe(e,n,null,!0),l=new qe(e,null,c,!1);c.o=l,i.push(c),o.push(l),c=new qe(r,n,null,!1),l=new qe(r,null,c,!0),c.o=l,i.push(c),o.push(l)}}),o.sort(t),ze(i),ze(o),i.length){for(var a=0,c=e,l=o.length;l>a;++a)o[a].e=c=!c;for(var s,f,h=i[0];;){for(var g=h,p=!0;g.v;)if((g=g.n)===h)return;s=g.z,u.lineStart();do{if(g.v=g.o.v=!0,g.e){if(p)for(var a=0,l=s.length;l>a;++a)u.point((f=s[a])[0],f[1]);else r(g.x,g.n.x,1,u);g=g.n}else{if(p){s=g.p.z;for(var a=s.length-1;a>=0;--a)u.point((f=s[a])[0],f[1])}else r(g.x,g.p.x,-1,u);g=g.p}g=g.o,s=g.z,p=!p}while(!g.v);u.lineEnd()}}}function ze(n){if(t=n.length){for(var t,e,r=0,u=n[0];++r<t;)u.n=e=n[r],e.p=u,u=e;u.n=e=n[0],e.p=u}}function qe(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Le(n,t,e,r){return function(u,i){function o(t,e){var r=u(t,e);n(t=r[0],e=r[1])&&i.point(t,e)}function a(n,t){var e=u(n,t);d.point(e[0],e[1])}function c(){y.point=a,d.lineStart()}function l(){y.point=o,d.lineEnd()}function s(n,t){v.push([n,t]);var e=u(n,t);x.point(e[0],e[1])}function f(){x.lineStart(),v=[]}function h(){s(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),p.push(v),v=null,r)if(1&t){n=e[0];var u,r=n.length-1,o=-1;if(r>0){for(b||(i.polygonStart(),b=!0),i.lineStart();++o<r;)i.point((u=n[o])[0],u[1]);i.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),g.push(e.filter(Te))}var g,p,v,d=t(i),m=u.invert(r[0],r[1]),y={point:o,lineStart:c,lineEnd:l,polygonStart:function(){y.point=s,y.lineStart=f,y.lineEnd=h,g=[],p=[]},polygonEnd:function(){y.point=o,y.lineStart=c,y.lineEnd=l,g=ta.merge(g);var n=Fe(m,p);g.length?(b||(i.polygonStart(),b=!0),Ce(g,De,n,e,i)):n&&(b||(i.polygonStart(),b=!0),i.lineStart(),e(null,null,1,i),i.lineEnd()),b&&(i.polygonEnd(),b=!1),g=p=null},sphere:function(){i.polygonStart(),i.lineStart(),e(null,null,1,i),i.lineEnd(),i.polygonEnd()}},M=Re(),x=t(M),b=!1;return y}}function Te(n){return n.length>1}function Re(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:y,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function De(n,t){return((n=n.x)[0]<0?n[1]-ja-Ta:ja-n[1])-((t=t.x)[0]<0?t[1]-ja-Ta:ja-t[1])}function Pe(n){var t,e=0/0,r=0/0,u=0/0;return{lineStart:function(){n.lineStart(),t=1},point:function(i,o){var a=i>0?Da:-Da,c=va(i-e);va(c-Da)<Ta?(n.point(e,r=(r+o)/2>0?ja:-ja),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(i,r),t=0):u!==a&&c>=Da&&(va(e-u)<Ta&&(e-=u*Ta),va(i-a)<Ta&&(i-=a*Ta),r=Ue(e,r,i,o),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=i,r=o),u=a},lineEnd:function(){n.lineEnd(),e=r=0/0},clean:function(){return 2-t}}}function Ue(n,t,e,r){var u,i,o=Math.sin(n-e);return va(o)>Ta?Math.atan((Math.sin(t)*(i=Math.cos(r))*Math.sin(e)-Math.sin(r)*(u=Math.cos(t))*Math.sin(n))/(u*i*o)):(t+r)/2}function je(n,t,e,r){var u;if(null==n)u=e*ja,r.point(-Da,u),r.point(0,u),r.point(Da,u),r.point(Da,0),r.point(Da,-u),r.point(0,-u),r.point(-Da,-u),r.point(-Da,0),r.point(-Da,u);else if(va(n[0]-t[0])>Ta){var i=n[0]<t[0]?Da:-Da;u=e*i/2,r.point(-i,u),r.point(0,u),r.point(i,u)}else r.point(t[0],t[1])}function Fe(n,t){var e=n[0],r=n[1],u=[Math.sin(e),-Math.cos(e),0],i=0,o=0;_c.reset();for(var a=0,c=t.length;c>a;++a){var l=t[a],s=l.length;if(s)for(var f=l[0],h=f[0],g=f[1]/2+Da/4,p=Math.sin(g),v=Math.cos(g),d=1;;){d===s&&(d=0),n=l[d];var m=n[0],y=n[1]/2+Da/4,M=Math.sin(y),x=Math.cos(y),b=m-h,_=b>=0?1:-1,w=_*b,S=w>Da,k=p*M;if(_c.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),i+=S?b+_*Pa:b,S^h>=e^m>=e){var E=de(pe(f),pe(n));Me(E);var A=de(u,E);Me(A);var N=(S^b>=0?-1:1)*nt(A[2]);(r>N||r===N&&(E[0]||E[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=m,p=M,v=x,f=n}}return(-Ta>i||Ta>i&&0>_c)^1&o}function He(n){function t(n,t){return Math.cos(n)*Math.cos(t)>i}function e(n){var e,i,c,l,s;return{lineStart:function(){l=c=!1,s=1},point:function(f,h){var g,p=[f,h],v=t(f,h),d=o?v?0:u(f,h):v?u(f+(0>f?Da:-Da),h):0;if(!e&&(l=c=v)&&n.lineStart(),v!==c&&(g=r(e,p),(be(e,g)||be(p,g))&&(p[0]+=Ta,p[1]+=Ta,v=t(p[0],p[1]))),v!==c)s=0,v?(n.lineStart(),g=r(p,e),n.point(g[0],g[1])):(g=r(e,p),n.point(g[0],g[1]),n.lineEnd()),e=g;else if(a&&e&&o^v){var m;d&i||!(m=r(p,e,!0))||(s=0,o?(n.lineStart(),n.point(m[0][0],m[0][1]),n.point(m[1][0],m[1][1]),n.lineEnd()):(n.point(m[1][0],m[1][1]),n.lineEnd(),n.lineStart(),n.point(m[0][0],m[0][1])))}!v||e&&be(e,p)||n.point(p[0],p[1]),e=p,c=v,i=d},lineEnd:function(){c&&n.lineEnd(),e=null},clean:function(){return s|(l&&c)<<1}}}function r(n,t,e){var r=pe(n),u=pe(t),o=[1,0,0],a=de(r,u),c=ve(a,a),l=a[0],s=c-l*l;if(!s)return!e&&n;var f=i*c/s,h=-i*l/s,g=de(o,a),p=ye(o,f),v=ye(a,h);me(p,v);var d=g,m=ve(p,d),y=ve(d,d),M=m*m-y*(ve(p,p)-1);if(!(0>M)){var x=Math.sqrt(M),b=ye(d,(-m-x)/y);if(me(b,p),b=xe(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],E=t[1];w>S&&(_=w,w=S,S=_);var A=S-w,N=va(A-Da)<Ta,C=N||Ta>A;if(!N&&k>E&&(_=k,k=E,E=_),C?N?k+E>0^b[1]<(va(b[0]-w)<Ta?k:E):k<=b[1]&&b[1]<=E:A>Da^(w<=b[0]&&b[0]<=S)){var z=ye(d,(-m+x)/y);return me(z,p),[b,xe(z)]}}}function u(t,e){var r=o?n:Da-n,u=0;return-r>t?u|=1:t>r&&(u|=2),-r>e?u|=4:e>r&&(u|=8),u}var i=Math.cos(n),o=i>0,a=va(i)>Ta,c=gr(n,6*Fa);return Le(t,e,c,o?[0,-n]:[-Da,n-Da])}function Oe(n,t,e,r){return function(u){var i,o=u.a,a=u.b,c=o.x,l=o.y,s=a.x,f=a.y,h=0,g=1,p=s-c,v=f-l;if(i=n-c,p||!(i>0)){if(i/=p,0>p){if(h>i)return;g>i&&(g=i)}else if(p>0){if(i>g)return;i>h&&(h=i)}if(i=e-c,p||!(0>i)){if(i/=p,0>p){if(i>g)return;i>h&&(h=i)}else if(p>0){if(h>i)return;g>i&&(g=i)}if(i=t-l,v||!(i>0)){if(i/=v,0>v){if(h>i)return;g>i&&(g=i)}else if(v>0){if(i>g)return;i>h&&(h=i)}if(i=r-l,v||!(0>i)){if(i/=v,0>v){if(i>g)return;i>h&&(h=i)}else if(v>0){if(h>i)return;g>i&&(g=i)}return h>0&&(u.a={x:c+h*p,y:l+h*v}),1>g&&(u.b={x:c+g*p,y:l+g*v}),u}}}}}}function Ye(n,t,e,r){function u(r,u){return va(r[0]-n)<Ta?u>0?0:3:va(r[0]-e)<Ta?u>0?2:1:va(r[1]-t)<Ta?u>0?1:0:u>0?3:2}function i(n,t){return o(n.x,t.x)}function o(n,t){var e=u(n,1),r=u(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function c(n){for(var t=0,e=d.length,r=n[1],u=0;e>u;++u)for(var i,o=1,a=d[u],c=a.length,l=a[0];c>o;++o)i=a[o],l[1]<=r?i[1]>r&&K(l,i,n)>0&&++t:i[1]<=r&&K(l,i,n)<0&&--t,l=i;return 0!==t}function l(i,a,c,l){var s=0,f=0;if(null==i||(s=u(i,c))!==(f=u(a,c))||o(i,a)<0^c>0){do l.point(0===s||3===s?n:e,s>1?r:t);while((s=(s+c+4)%4)!==f)}else l.point(a[0],a[1])}function s(u,i){return u>=n&&e>=u&&i>=t&&r>=i}function f(n,t){s(n,t)&&a.point(n,t)}function h(){C.point=p,d&&d.push(m=[]),S=!0,w=!1,b=_=0/0}function g(){v&&(p(y,M),x&&w&&A.rejoin(),v.push(A.buffer())),C.point=f,w&&a.lineEnd()}function p(n,t){n=Math.max(-Uc,Math.min(Uc,n)),t=Math.max(-Uc,Math.min(Uc,t));var e=s(n,t);if(d&&m.push([n,t]),S)y=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};N(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,m,y,M,x,b,_,w,S,k,E=a,A=Re(),N=Oe(n,t,e,r),C={point:f,lineStart:h,lineEnd:g,polygonStart:function(){a=A,v=[],d=[],k=!0},polygonEnd:function(){a=E,v=ta.merge(v);var t=c([n,r]),e=k&&t,u=v.length;(e||u)&&(a.polygonStart(),e&&(a.lineStart(),l(null,null,1,a),a.lineEnd()),u&&Ce(v,i,t,l,a),a.polygonEnd()),v=d=m=null}};return C}}function Ie(n){var t=0,e=Da/3,r=ir(n),u=r(t,e);return u.parallels=function(n){return arguments.length?r(t=n[0]*Da/180,e=n[1]*Da/180):[180*(t/Da),180*(e/Da)]},u}function Ze(n,t){function e(n,t){var e=Math.sqrt(i-2*u*Math.sin(t))/u;return[e*Math.sin(n*=u),o-e*Math.cos(n)]}var r=Math.sin(n),u=(r+Math.sin(t))/2,i=1+r*(2*u-r),o=Math.sqrt(i)/u;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/u,nt((i-(n*n+e*e)*u*u)/(2*u))]},e}function Ve(){function n(n,t){Fc+=u*n-r*t,r=n,u=t}var t,e,r,u;Zc.point=function(i,o){Zc.point=n,t=r=i,e=u=o},Zc.lineEnd=function(){n(t,e)}}function Xe(n,t){Hc>n&&(Hc=n),n>Yc&&(Yc=n),Oc>t&&(Oc=t),t>Ic&&(Ic=t)}function $e(){function n(n,t){o.push("M",n,",",t,i)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function u(){o.push("Z")}var i=Be(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return i=Be(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Be(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function We(n,t){Ec+=n,Ac+=t,++Nc}function Je(){function n(n,r){var u=n-t,i=r-e,o=Math.sqrt(u*u+i*i);Cc+=o*(t+n)/2,zc+=o*(e+r)/2,qc+=o,We(t=n,e=r)}var t,e;Xc.point=function(r,u){Xc.point=n,We(t=r,e=u)}}function Ge(){Xc.point=We}function Ke(){function n(n,t){var e=n-r,i=t-u,o=Math.sqrt(e*e+i*i);Cc+=o*(r+n)/2,zc+=o*(u+t)/2,qc+=o,o=u*n-r*t,Lc+=o*(r+n),Tc+=o*(u+t),Rc+=3*o,We(r=n,u=t)}var t,e,r,u;Xc.point=function(i,o){Xc.point=n,We(t=r=i,e=u=o)},Xc.lineEnd=function(){n(t,e)}}function Qe(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,Pa)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function u(){a.point=t}function i(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:u,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=u,a.point=t},pointRadius:function(n){return o=n,a},result:y};return a}function nr(n){function t(n){return(a?r:e)(n)}function e(t){return rr(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=0/0,S.point=i,t.lineStart()}function i(e,r){var i=pe([e,r]),o=n(e,r);u(M,x,y,b,_,w,M=o[0],x=o[1],y=e,b=i[0],_=i[1],w=i[2],a,t),t.point(M,x)}function o(){S.point=e,t.lineEnd()}function c(){r(),S.point=l,S.lineEnd=s}function l(n,t){i(f=n,h=t),g=M,p=x,v=b,d=_,m=w,S.point=i}function s(){u(M,x,y,b,_,w,g,p,f,v,d,m,a,t),S.lineEnd=o,o()}var f,h,g,p,v,d,m,y,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=c},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function u(t,e,r,a,c,l,s,f,h,g,p,v,d,m){var y=s-t,M=f-e,x=y*y+M*M;if(x>4*i&&d--){var b=a+g,_=c+p,w=l+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),E=va(va(w)-1)<Ta||va(r-h)<Ta?(r+h)/2:Math.atan2(_,b),A=n(E,k),N=A[0],C=A[1],z=N-t,q=C-e,L=M*z-y*q;
  (L*L/x>i||va((y*z+M*q)/x-.5)>.3||o>a*g+c*p+l*v)&&(u(t,e,r,a,c,l,N,C,E,b/=S,_/=S,w,d,m),m.point(N,C),u(N,C,E,b,_,w,s,f,h,g,p,v,d,m))}}var i=.5,o=Math.cos(30*Fa),a=16;return t.precision=function(n){return arguments.length?(a=(i=n*n)>0&&16,t):Math.sqrt(i)},t}function tr(n){var t=nr(function(t,e){return n([t*Ha,e*Ha])});return function(n){return or(t(n))}}function er(n){this.stream=n}function rr(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function ur(n){return ir(function(){return n})()}function ir(n){function t(n){return n=a(n[0]*Fa,n[1]*Fa),[n[0]*h+c,l-n[1]*h]}function e(n){return n=a.invert((n[0]-c)/h,(l-n[1])/h),n&&[n[0]*Ha,n[1]*Ha]}function r(){a=Ae(o=lr(m,y,M),i);var n=i(v,d);return c=g-n[0]*h,l=p+n[1]*h,u()}function u(){return s&&(s.valid=!1,s=null),t}var i,o,a,c,l,s,f=nr(function(n,t){return n=i(n,t),[n[0]*h+c,l-n[1]*h]}),h=150,g=480,p=250,v=0,d=0,m=0,y=0,M=0,x=Pc,b=Et,_=null,w=null;return t.stream=function(n){return s&&(s.valid=!1),s=or(x(o,f(b(n)))),s.valid=!0,s},t.clipAngle=function(n){return arguments.length?(x=null==n?(_=n,Pc):He((_=+n)*Fa),u()):_},t.clipExtent=function(n){return arguments.length?(w=n,b=n?Ye(n[0][0],n[0][1],n[1][0],n[1][1]):Et,u()):w},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(g=+n[0],p=+n[1],r()):[g,p]},t.center=function(n){return arguments.length?(v=n[0]%360*Fa,d=n[1]%360*Fa,r()):[v*Ha,d*Ha]},t.rotate=function(n){return arguments.length?(m=n[0]%360*Fa,y=n[1]%360*Fa,M=n.length>2?n[2]%360*Fa:0,r()):[m*Ha,y*Ha,M*Ha]},ta.rebind(t,f,"precision"),function(){return i=n.apply(this,arguments),t.invert=i.invert&&e,r()}}function or(n){return rr(n,function(t,e){n.point(t*Fa,e*Fa)})}function ar(n,t){return[n,t]}function cr(n,t){return[n>Da?n-Pa:-Da>n?n+Pa:n,t]}function lr(n,t,e){return n?t||e?Ae(fr(n),hr(t,e)):fr(n):t||e?hr(t,e):cr}function sr(n){return function(t,e){return t+=n,[t>Da?t-Pa:-Da>t?t+Pa:t,e]}}function fr(n){var t=sr(n);return t.invert=sr(-n),t}function hr(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,l=Math.sin(t),s=l*r+a*u;return[Math.atan2(c*i-s*o,a*r-l*u),nt(s*i+c*o)]}var r=Math.cos(n),u=Math.sin(n),i=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,l=Math.sin(t),s=l*i-c*o;return[Math.atan2(c*i+l*o,a*r+s*u),nt(s*r-a*u)]},e}function gr(n,t){var e=Math.cos(n),r=Math.sin(n);return function(u,i,o,a){var c=o*t;null!=u?(u=pr(e,u),i=pr(e,i),(o>0?i>u:u>i)&&(u+=o*Pa)):(u=n+o*Pa,i=n-.5*c);for(var l,s=u;o>0?s>i:i>s;s-=c)a.point((l=xe([e,-r*Math.cos(s),-r*Math.sin(s)]))[0],l[1])}}function pr(n,t){var e=pe(t);e[0]-=n,Me(e);var r=Q(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Ta)%(2*Math.PI)}function vr(n,t,e){var r=ta.range(n,t-Ta,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function dr(n,t,e){var r=ta.range(n,t-Ta,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function mr(n){return n.source}function yr(n){return n.target}function Mr(n,t,e,r){var u=Math.cos(t),i=Math.sin(t),o=Math.cos(r),a=Math.sin(r),c=u*Math.cos(n),l=u*Math.sin(n),s=o*Math.cos(e),f=o*Math.sin(e),h=2*Math.asin(Math.sqrt(ut(r-t)+u*o*ut(e-n))),g=1/Math.sin(h),p=h?function(n){var t=Math.sin(n*=h)*g,e=Math.sin(h-n)*g,r=e*c+t*s,u=e*l+t*f,o=e*i+t*a;return[Math.atan2(u,r)*Ha,Math.atan2(o,Math.sqrt(r*r+u*u))*Ha]}:function(){return[n*Ha,t*Ha]};return p.distance=h,p}function xr(){function n(n,u){var i=Math.sin(u*=Fa),o=Math.cos(u),a=va((n*=Fa)-t),c=Math.cos(a);$c+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*i-e*o*c)*a),e*i+r*o*c),t=n,e=i,r=o}var t,e,r;Bc.point=function(u,i){t=u*Fa,e=Math.sin(i*=Fa),r=Math.cos(i),Bc.point=n},Bc.lineEnd=function(){Bc.point=Bc.lineEnd=y}}function br(n,t){function e(t,e){var r=Math.cos(t),u=Math.cos(e),i=n(r*u);return[i*u*Math.sin(t),i*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),u=t(r),i=Math.sin(u),o=Math.cos(u);return[Math.atan2(n*i,r*o),Math.asin(r&&e*i/r)]},e}function _r(n,t){function e(n,t){o>0?-ja+Ta>t&&(t=-ja+Ta):t>ja-Ta&&(t=ja-Ta);var e=o/Math.pow(u(t),i);return[e*Math.sin(i*n),o-e*Math.cos(i*n)]}var r=Math.cos(n),u=function(n){return Math.tan(Da/4+n/2)},i=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(u(t)/u(n)),o=r*Math.pow(u(n),i)/i;return i?(e.invert=function(n,t){var e=o-t,r=G(i)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/i,2*Math.atan(Math.pow(o/r,1/i))-ja]},e):Sr}function wr(n,t){function e(n,t){var e=i-t;return[e*Math.sin(u*n),i-e*Math.cos(u*n)]}var r=Math.cos(n),u=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),i=r/u+n;return va(u)<Ta?ar:(e.invert=function(n,t){var e=i-t;return[Math.atan2(n,e)/u,i-G(u)*Math.sqrt(n*n+e*e)]},e)}function Sr(n,t){return[n,Math.log(Math.tan(Da/4+t/2))]}function kr(n){var t,e=ur(n),r=e.scale,u=e.translate,i=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=u.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=i.apply(e,arguments);if(o===e){if(t=null==n){var a=Da*r(),c=u();i([[c[0]-a,c[1]-a],[c[0]+a,c[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Er(n,t){return[Math.log(Math.tan(Da/4+t/2)),-n]}function Ar(n){return n[0]}function Nr(n){return n[1]}function Cr(n){for(var t=n.length,e=[0,1],r=2,u=2;t>u;u++){for(;r>1&&K(n[e[r-2]],n[e[r-1]],n[u])<=0;)--r;e[r++]=u}return e.slice(0,r)}function zr(n,t){return n[0]-t[0]||n[1]-t[1]}function qr(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Lr(n,t,e,r){var u=n[0],i=e[0],o=t[0]-u,a=r[0]-i,c=n[1],l=e[1],s=t[1]-c,f=r[1]-l,h=(a*(c-l)-f*(u-i))/(f*o-a*s);return[u+h*o,c+h*s]}function Tr(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Rr(){tu(this),this.edge=this.site=this.circle=null}function Dr(n){var t=ol.pop()||new Rr;return t.site=n,t}function Pr(n){Xr(n),rl.remove(n),ol.push(n),tu(n)}function Ur(n){var t=n.circle,e=t.x,r=t.cy,u={x:e,y:r},i=n.P,o=n.N,a=[n];Pr(n);for(var c=i;c.circle&&va(e-c.circle.x)<Ta&&va(r-c.circle.cy)<Ta;)i=c.P,a.unshift(c),Pr(c),c=i;a.unshift(c),Xr(c);for(var l=o;l.circle&&va(e-l.circle.x)<Ta&&va(r-l.circle.cy)<Ta;)o=l.N,a.push(l),Pr(l),l=o;a.push(l),Xr(l);var s,f=a.length;for(s=1;f>s;++s)l=a[s],c=a[s-1],Kr(l.edge,c.site,l.site,u);c=a[0],l=a[f-1],l.edge=Jr(c.site,l.site,null,u),Vr(c),Vr(l)}function jr(n){for(var t,e,r,u,i=n.x,o=n.y,a=rl._;a;)if(r=Fr(a,o)-i,r>Ta)a=a.L;else{if(u=i-Hr(a,o),!(u>Ta)){r>-Ta?(t=a.P,e=a):u>-Ta?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var c=Dr(n);if(rl.insert(t,c),t||e){if(t===e)return Xr(t),e=Dr(t.site),rl.insert(c,e),c.edge=e.edge=Jr(t.site,c.site),Vr(t),Vr(e),void 0;if(!e)return c.edge=Jr(t.site,c.site),void 0;Xr(t),Xr(e);var l=t.site,s=l.x,f=l.y,h=n.x-s,g=n.y-f,p=e.site,v=p.x-s,d=p.y-f,m=2*(h*d-g*v),y=h*h+g*g,M=v*v+d*d,x={x:(d*y-g*M)/m+s,y:(h*M-v*y)/m+f};Kr(e.edge,l,p,x),c.edge=Jr(l,n,null,x),e.edge=Jr(n,p,null,x),Vr(t),Vr(e)}}function Fr(n,t){var e=n.site,r=e.x,u=e.y,i=u-t;if(!i)return r;var o=n.P;if(!o)return-1/0;e=o.site;var a=e.x,c=e.y,l=c-t;if(!l)return a;var s=a-r,f=1/i-1/l,h=s/l;return f?(-h+Math.sqrt(h*h-2*f*(s*s/(-2*l)-c+l/2+u-i/2)))/f+r:(r+a)/2}function Hr(n,t){var e=n.N;if(e)return Fr(e,t);var r=n.site;return r.y===t?r.x:1/0}function Or(n){this.site=n,this.edges=[]}function Yr(n){for(var t,e,r,u,i,o,a,c,l,s,f=n[0][0],h=n[1][0],g=n[0][1],p=n[1][1],v=el,d=v.length;d--;)if(i=v[d],i&&i.prepare())for(a=i.edges,c=a.length,o=0;c>o;)s=a[o].end(),r=s.x,u=s.y,l=a[++o%c].start(),t=l.x,e=l.y,(va(r-t)>Ta||va(u-e)>Ta)&&(a.splice(o,0,new Qr(Gr(i.site,s,va(r-f)<Ta&&p-u>Ta?{x:f,y:va(t-f)<Ta?e:p}:va(u-p)<Ta&&h-r>Ta?{x:va(e-p)<Ta?t:h,y:p}:va(r-h)<Ta&&u-g>Ta?{x:h,y:va(t-h)<Ta?e:g}:va(u-g)<Ta&&r-f>Ta?{x:va(e-g)<Ta?t:f,y:g}:null),i.site,null)),++c)}function Ir(n,t){return t.angle-n.angle}function Zr(){tu(this),this.x=this.y=this.arc=this.site=this.cy=null}function Vr(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,u=n.site,i=e.site;if(r!==i){var o=u.x,a=u.y,c=r.x-o,l=r.y-a,s=i.x-o,f=i.y-a,h=2*(c*f-l*s);if(!(h>=-Ra)){var g=c*c+l*l,p=s*s+f*f,v=(f*g-l*p)/h,d=(c*p-s*g)/h,f=d+a,m=al.pop()||new Zr;m.arc=n,m.site=u,m.x=v+o,m.y=f+Math.sqrt(v*v+d*d),m.cy=f,n.circle=m;for(var y=null,M=il._;M;)if(m.y<M.y||m.y===M.y&&m.x<=M.x){if(!M.L){y=M.P;break}M=M.L}else{if(!M.R){y=M;break}M=M.R}il.insert(y,m),y||(ul=m)}}}}function Xr(n){var t=n.circle;t&&(t.P||(ul=t.N),il.remove(t),al.push(t),tu(t),n.circle=null)}function $r(n){for(var t,e=tl,r=Oe(n[0][0],n[0][1],n[1][0],n[1][1]),u=e.length;u--;)t=e[u],(!Br(t,n)||!r(t)||va(t.a.x-t.b.x)<Ta&&va(t.a.y-t.b.y)<Ta)&&(t.a=t.b=null,e.splice(u,1))}function Br(n,t){var e=n.b;if(e)return!0;var r,u,i=n.a,o=t[0][0],a=t[1][0],c=t[0][1],l=t[1][1],s=n.l,f=n.r,h=s.x,g=s.y,p=f.x,v=f.y,d=(h+p)/2,m=(g+v)/2;if(v===g){if(o>d||d>=a)return;if(h>p){if(i){if(i.y>=l)return}else i={x:d,y:c};e={x:d,y:l}}else{if(i){if(i.y<c)return}else i={x:d,y:l};e={x:d,y:c}}}else if(r=(h-p)/(v-g),u=m-r*d,-1>r||r>1)if(h>p){if(i){if(i.y>=l)return}else i={x:(c-u)/r,y:c};e={x:(l-u)/r,y:l}}else{if(i){if(i.y<c)return}else i={x:(l-u)/r,y:l};e={x:(c-u)/r,y:c}}else if(v>g){if(i){if(i.x>=a)return}else i={x:o,y:r*o+u};e={x:a,y:r*a+u}}else{if(i){if(i.x<o)return}else i={x:a,y:r*a+u};e={x:o,y:r*o+u}}return n.a=i,n.b=e,!0}function Wr(n,t){this.l=n,this.r=t,this.a=this.b=null}function Jr(n,t,e,r){var u=new Wr(n,t);return tl.push(u),e&&Kr(u,n,t,e),r&&Kr(u,t,n,r),el[n.i].edges.push(new Qr(u,n,t)),el[t.i].edges.push(new Qr(u,t,n)),u}function Gr(n,t,e){var r=new Wr(n,null);return r.a=t,r.b=e,tl.push(r),r}function Kr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function Qr(n,t,e){var r=n.a,u=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(u.x-r.x,r.y-u.y):Math.atan2(r.x-u.x,u.y-r.y)}function nu(){this._=null}function tu(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function eu(n,t){var e=t,r=t.R,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ru(n,t){var e=t,r=t.L,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function uu(n){for(;n.L;)n=n.L;return n}function iu(n,t){var e,r,u,i=n.sort(ou).pop();for(tl=[],el=new Array(n.length),rl=new nu,il=new nu;;)if(u=ul,i&&(!u||i.y<u.y||i.y===u.y&&i.x<u.x))(i.x!==e||i.y!==r)&&(el[i.i]=new Or(i),jr(i),e=i.x,r=i.y),i=n.pop();else{if(!u)break;Ur(u.arc)}t&&($r(t),Yr(t));var o={cells:el,edges:tl};return rl=il=tl=el=null,o}function ou(n,t){return t.y-n.y||t.x-n.x}function au(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function cu(n){return n.x}function lu(n){return n.y}function su(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function fu(n,t,e,r,u,i){if(!n(t,e,r,u,i)){var o=.5*(e+u),a=.5*(r+i),c=t.nodes;c[0]&&fu(n,c[0],e,r,o,a),c[1]&&fu(n,c[1],o,r,u,a),c[2]&&fu(n,c[2],e,a,o,i),c[3]&&fu(n,c[3],o,a,u,i)}}function hu(n,t,e,r,u,i,o){var a,c=1/0;return function l(n,s,f,h,g){if(!(s>i||f>o||r>h||u>g)){if(p=n.point){var p,v=t-p[0],d=e-p[1],m=v*v+d*d;if(c>m){var y=Math.sqrt(c=m);r=t-y,u=e-y,i=t+y,o=e+y,a=p}}for(var M=n.nodes,x=.5*(s+h),b=.5*(f+g),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;k>S;++S)if(n=M[3&S])switch(3&S){case 0:l(n,s,f,x,b);break;case 1:l(n,x,f,h,b);break;case 2:l(n,s,b,x,g);break;case 3:l(n,x,b,h,g)}}}(n,r,u,i,o),a}function gu(n,t){n=ta.rgb(n),t=ta.rgb(t);var e=n.r,r=n.g,u=n.b,i=t.r-e,o=t.g-r,a=t.b-u;return function(n){return"#"+Mt(Math.round(e+i*n))+Mt(Math.round(r+o*n))+Mt(Math.round(u+a*n))}}function pu(n,t){var e,r={},u={};for(e in n)e in t?r[e]=mu(n[e],t[e]):u[e]=n[e];for(e in t)e in n||(u[e]=t[e]);return function(n){for(e in r)u[e]=r[e](n);return u}}function vu(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function du(n,t){var e,r,u,i=ll.lastIndex=sl.lastIndex=0,o=-1,a=[],c=[];for(n+="",t+="";(e=ll.exec(n))&&(r=sl.exec(t));)(u=r.index)>i&&(u=t.slice(i,u),a[o]?a[o]+=u:a[++o]=u),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,c.push({i:o,x:vu(e,r)})),i=sl.lastIndex;return i<t.length&&(u=t.slice(i),a[o]?a[o]+=u:a[++o]=u),a.length<2?c[0]?(t=c[0].x,function(n){return t(n)+""}):function(){return t}:(t=c.length,function(n){for(var e,r=0;t>r;++r)a[(e=c[r]).i]=e.x(n);return a.join("")})}function mu(n,t){for(var e,r=ta.interpolators.length;--r>=0&&!(e=ta.interpolators[r](n,t)););return e}function yu(n,t){var e,r=[],u=[],i=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(mu(n[e],t[e]));for(;i>e;++e)u[e]=n[e];for(;o>e;++e)u[e]=t[e];return function(n){for(e=0;a>e;++e)u[e]=r[e](n);return u}}function Mu(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function xu(n){return function(t){return 1-n(1-t)}}function bu(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function _u(n){return n*n}function wu(n){return n*n*n}function Su(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function ku(n){return function(t){return Math.pow(t,n)}}function Eu(n){return 1-Math.cos(n*ja)}function Au(n){return Math.pow(2,10*(n-1))}function Nu(n){return 1-Math.sqrt(1-n*n)}function Cu(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/Pa*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Pa/t)}}function zu(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function qu(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Lu(n,t){n=ta.hcl(n),t=ta.hcl(t);var e=n.h,r=n.c,u=n.l,i=t.h-e,o=t.c-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return lt(e+i*n,r+o*n,u+a*n)+""}}function Tu(n,t){n=ta.hsl(n),t=ta.hsl(t);var e=n.h,r=n.s,u=n.l,i=t.h-e,o=t.s-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return at(e+i*n,r+o*n,u+a*n)+""}}function Ru(n,t){n=ta.lab(n),t=ta.lab(t);var e=n.l,r=n.a,u=n.b,i=t.l-e,o=t.a-r,a=t.b-u;return function(n){return ft(e+i*n,r+o*n,u+a*n)+""}}function Du(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function Pu(n){var t=[n.a,n.b],e=[n.c,n.d],r=ju(t),u=Uu(t,e),i=ju(Fu(e,t,-u))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,u*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Ha,this.translate=[n.e,n.f],this.scale=[r,i],this.skew=i?Math.atan2(u,i)*Ha:0}function Uu(n,t){return n[0]*t[0]+n[1]*t[1]}function ju(n){var t=Math.sqrt(Uu(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Fu(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Hu(n,t){var e,r=[],u=[],i=ta.transform(n),o=ta.transform(t),a=i.translate,c=o.translate,l=i.rotate,s=o.rotate,f=i.skew,h=o.skew,g=i.scale,p=o.scale;return a[0]!=c[0]||a[1]!=c[1]?(r.push("translate(",null,",",null,")"),u.push({i:1,x:vu(a[0],c[0])},{i:3,x:vu(a[1],c[1])})):c[0]||c[1]?r.push("translate("+c+")"):r.push(""),l!=s?(l-s>180?s+=360:s-l>180&&(l+=360),u.push({i:r.push(r.pop()+"rotate(",null,")")-2,x:vu(l,s)})):s&&r.push(r.pop()+"rotate("+s+")"),f!=h?u.push({i:r.push(r.pop()+"skewX(",null,")")-2,x:vu(f,h)}):h&&r.push(r.pop()+"skewX("+h+")"),g[0]!=p[0]||g[1]!=p[1]?(e=r.push(r.pop()+"scale(",null,",",null,")"),u.push({i:e-4,x:vu(g[0],p[0])},{i:e-2,x:vu(g[1],p[1])})):(1!=p[0]||1!=p[1])&&r.push(r.pop()+"scale("+p+")"),e=u.length,function(n){for(var t,i=-1;++i<e;)r[(t=u[i]).i]=t.x(n);return r.join("")}}function Ou(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Yu(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Iu(n){for(var t=n.source,e=n.target,r=Vu(t,e),u=[t];t!==r;)t=t.parent,u.push(t);for(var i=u.length;e!==r;)u.splice(i,0,e),e=e.parent;return u}function Zu(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Vu(n,t){if(n===t)return n;for(var e=Zu(n),r=Zu(t),u=e.pop(),i=r.pop(),o=null;u===i;)o=u,u=e.pop(),i=r.pop();return o}function Xu(n){n.fixed|=2}function $u(n){n.fixed&=-7}function Bu(n){n.fixed|=4,n.px=n.x,n.py=n.y}function Wu(n){n.fixed&=-5}function Ju(n,t,e){var r=0,u=0;if(n.charge=0,!n.leaf)for(var i,o=n.nodes,a=o.length,c=-1;++c<a;)i=o[c],null!=i&&(Ju(i,t,e),n.charge+=i.charge,r+=i.charge*i.cx,u+=i.charge*i.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var l=t*e[n.point.index];n.charge+=n.pointCharge=l,r+=l*n.point.x,u+=l*n.point.y}n.cx=r/n.charge,n.cy=u/n.charge}function Gu(n,t){return ta.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=ri,n}function Ku(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(u=n.children)&&(r=u.length))for(var r,u;--r>=0;)e.push(u[r])}function Qu(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(i=n.children)&&(u=i.length))for(var u,i,o=-1;++o<u;)e.push(i[o]);for(;null!=(n=r.pop());)t(n)}function ni(n){return n.children}function ti(n){return n.value}function ei(n,t){return t.value-n.value}function ri(n){return ta.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function ui(n){return n.x}function ii(n){return n.y}function oi(n,t,e){n.y0=t,n.y=e}function ai(n){return ta.range(n.length)}function ci(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function li(n){for(var t,e=1,r=0,u=n[0][1],i=n.length;i>e;++e)(t=n[e][1])>u&&(r=e,u=t);return r}function si(n){return n.reduce(fi,0)}function fi(n,t){return n+t[1]}function hi(n,t){return gi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function gi(n,t){for(var e=-1,r=+n[0],u=(n[1]-r)/t,i=[];++e<=t;)i[e]=u*e+r;return i}function pi(n){return[ta.min(n),ta.max(n)]}function vi(n,t){return n.value-t.value}function di(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function mi(n,t){n._pack_next=t,t._pack_prev=n}function yi(n,t){var e=t.x-n.x,r=t.y-n.y,u=n.r+t.r;return.999*u*u>e*e+r*r}function Mi(n){function t(n){s=Math.min(n.x-n.r,s),f=Math.max(n.x+n.r,f),h=Math.min(n.y-n.r,h),g=Math.max(n.y+n.r,g)}if((e=n.children)&&(l=e.length)){var e,r,u,i,o,a,c,l,s=1/0,f=-1/0,h=1/0,g=-1/0;if(e.forEach(xi),r=e[0],r.x=-r.r,r.y=0,t(r),l>1&&(u=e[1],u.x=u.r,u.y=0,t(u),l>2))for(i=e[2],wi(r,u,i),t(i),di(r,i),r._pack_prev=i,di(i,u),u=r._pack_next,o=3;l>o;o++){wi(r,u,i=e[o]);var p=0,v=1,d=1;for(a=u._pack_next;a!==u;a=a._pack_next,v++)if(yi(a,i)){p=1;break}if(1==p)for(c=r._pack_prev;c!==a._pack_prev&&!yi(c,i);c=c._pack_prev,d++);p?(d>v||v==d&&u.r<r.r?mi(r,u=a):mi(r=c,u),o--):(di(r,i),u=i,t(i))}var m=(s+f)/2,y=(h+g)/2,M=0;for(o=0;l>o;o++)i=e[o],i.x-=m,i.y-=y,M=Math.max(M,i.r+Math.sqrt(i.x*i.x+i.y*i.y));n.r=M,e.forEach(bi)}}function xi(n){n._pack_next=n._pack_prev=n}function bi(n){delete n._pack_next,delete n._pack_prev}function _i(n,t,e,r){var u=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,u)for(var i=-1,o=u.length;++i<o;)_i(u[i],t,e,r)}function wi(n,t,e){var r=n.r+e.r,u=t.x-n.x,i=t.y-n.y;if(r&&(u||i)){var o=t.r+e.r,a=u*u+i*i;o*=o,r*=r;var c=.5+(r-o)/(2*a),l=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+c*u+l*i,e.y=n.y+c*i-l*u}else e.x=n.x+r,e.y=n.y}function Si(n,t){return n.parent==t.parent?1:2}function ki(n){var t=n.children;return t.length?t[0]:n.t}function Ei(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ai(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Ni(n){for(var t,e=0,r=0,u=n.children,i=u.length;--i>=0;)t=u[i],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Ci(n,t,e){return n.a.parent===t.parent?n.a:e}function zi(n){return 1+ta.max(n,function(n){return n.y})}function qi(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Li(n){var t=n.children;return t&&t.length?Li(t[0]):n}function Ti(n){var t,e=n.children;return e&&(t=e.length)?Ti(e[t-1]):n}function Ri(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Di(n,t){var e=n.x+t[3],r=n.y+t[0],u=n.dx-t[1]-t[3],i=n.dy-t[0]-t[2];return 0>u&&(e+=u/2,u=0),0>i&&(r+=i/2,i=0),{x:e,y:r,dx:u,dy:i}}function Pi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Ui(n){return n.rangeExtent?n.rangeExtent():Pi(n.range())}function ji(n,t,e,r){var u=e(n[0],n[1]),i=r(t[0],t[1]);return function(n){return i(u(n))}}function Fi(n,t){var e,r=0,u=n.length-1,i=n[r],o=n[u];return i>o&&(e=r,r=u,u=e,e=i,i=o,o=e),n[r]=t.floor(i),n[u]=t.ceil(o),n}function Hi(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:bl}function Oi(n,t,e,r){var u=[],i=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)u.push(e(n[o-1],n[o])),i.push(r(t[o-1],t[o]));return function(t){var e=ta.bisect(n,t,1,a)-1;return i[e](u[e](t))}}function Yi(n,t,e,r){function u(){var u=Math.min(n.length,t.length)>2?Oi:ji,c=r?Yu:Ou;return o=u(n,t,c,e),a=u(t,n,c,mu),i}function i(n){return o(n)}var o,a;return i.invert=function(n){return a(n)},i.domain=function(t){return arguments.length?(n=t.map(Number),u()):n},i.range=function(n){return arguments.length?(t=n,u()):t},i.rangeRound=function(n){return i.range(n).interpolate(Du)},i.clamp=function(n){return arguments.length?(r=n,u()):r},i.interpolate=function(n){return arguments.length?(e=n,u()):e},i.ticks=function(t){return Xi(n,t)},i.tickFormat=function(t,e){return $i(n,t,e)},i.nice=function(t){return Zi(n,t),u()},i.copy=function(){return Yi(n,t,e,r)},u()}function Ii(n,t){return ta.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Zi(n,t){return Fi(n,Hi(Vi(n,t)[2]))}function Vi(n,t){null==t&&(t=10);var e=Pi(n),r=e[1]-e[0],u=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),i=t/r*u;return.15>=i?u*=10:.35>=i?u*=5:.75>=i&&(u*=2),e[0]=Math.ceil(e[0]/u)*u,e[1]=Math.floor(e[1]/u)*u+.5*u,e[2]=u,e}function Xi(n,t){return ta.range.apply(ta,Vi(n,t))}function $i(n,t,e){var r=Vi(n,t);if(e){var u=lc.exec(e);if(u.shift(),"s"===u[8]){var i=ta.formatPrefix(Math.max(va(r[0]),va(r[1])));return u[7]||(u[7]="."+Bi(i.scale(r[2]))),u[8]="f",e=ta.format(u.join("")),function(n){return e(i.scale(n))+i.symbol}}u[7]||(u[7]="."+Wi(u[8],r)),e=u.join("")}else e=",."+Bi(r[2])+"f";return ta.format(e)}function Bi(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function Wi(n,t){var e=Bi(t[2]);return n in _l?Math.abs(e-Bi(Math.max(va(t[0]),va(t[1]))))+ +("e"!==n):e-2*("%"===n)}function Ji(n,t,e,r){function u(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function i(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(u(t))}return o.invert=function(t){return i(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(u)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(u)),o):t},o.nice=function(){var t=Fi(r.map(u),e?Math:Sl);return n.domain(t),r=t.map(i),o},o.ticks=function(){var n=Pi(r),o=[],a=n[0],c=n[1],l=Math.floor(u(a)),s=Math.ceil(u(c)),f=t%1?2:t;if(isFinite(s-l)){if(e){for(;s>l;l++)for(var h=1;f>h;h++)o.push(i(l)*h);o.push(i(l))}else for(o.push(i(l));l++<s;)for(var h=f-1;h>0;h--)o.push(i(l)*h);for(l=0;o[l]<a;l++);for(s=o.length;o[s-1]>c;s--);o=o.slice(l,s)}return o},o.tickFormat=function(n,t){if(!arguments.length)return wl;arguments.length<2?t=wl:"function"!=typeof t&&(t=ta.format(t));var r,a=Math.max(.1,n/o.ticks().length),c=e?(r=1e-12,Math.ceil):(r=-1e-12,Math.floor);return function(n){return n/i(c(u(n)+r))<=a?t(n):""}},o.copy=function(){return Ji(n.copy(),t,e,r)},Ii(o,n)}function Gi(n,t,e){function r(t){return n(u(t))}var u=Ki(t),i=Ki(1/t);return r.invert=function(t){return i(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(u)),r):e},r.ticks=function(n){return Xi(e,n)},r.tickFormat=function(n,t){return $i(e,n,t)},r.nice=function(n){return r.domain(Zi(e,n))},r.exponent=function(o){return arguments.length?(u=Ki(t=o),i=Ki(1/t),n.domain(e.map(u)),r):t},r.copy=function(){return Gi(n.copy(),t,e)},Ii(r,n)}function Ki(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function Qi(n,t){function e(e){return i[((u.get(e)||("range"===t.t?u.set(e,n.push(e)):0/0))-1)%i.length]}function r(t,e){return ta.range(n.length).map(function(n){return t+e*n})}var u,i,o;return e.domain=function(r){if(!arguments.length)return n;n=[],u=new a;for(var i,o=-1,c=r.length;++o<c;)u.has(i=r[o])||u.set(i,n.push(i));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(i=n,o=0,t={t:"range",a:arguments},e):i},e.rangePoints=function(u,a){arguments.length<2&&(a=0);var c=u[0],l=u[1],s=n.length<2?(c=(c+l)/2,0):(l-c)/(n.length-1+a);return i=r(c+s*a/2,s),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(u,a){arguments.length<2&&(a=0);var c=u[0],l=u[1],s=n.length<2?(c=l=Math.round((c+l)/2),0):0|(l-c)/(n.length-1+a);return i=r(c+Math.round(s*a/2+(l-c-(n.length-1+a)*s)/2),s),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(u,a,c){arguments.length<2&&(a=0),arguments.length<3&&(c=a);var l=u[1]<u[0],s=u[l-0],f=u[1-l],h=(f-s)/(n.length-a+2*c);return i=r(s+h*c,h),l&&i.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(u,a,c){arguments.length<2&&(a=0),arguments.length<3&&(c=a);var l=u[1]<u[0],s=u[l-0],f=u[1-l],h=Math.floor((f-s)/(n.length-a+2*c));return i=r(s+Math.round((f-s-(n.length-a)*h)/2),h),l&&i.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Pi(t.a[0])},e.copy=function(){return Qi(n,t)},e.domain(n)}function no(r,u){function i(){var n=0,t=u.length;for(a=[];++n<t;)a[n-1]=ta.quantile(r,n/t);return o}function o(n){return isNaN(n=+n)?void 0:u[ta.bisect(a,n)]}var a;return o.domain=function(u){return arguments.length?(r=u.map(t).filter(e).sort(n),i()):r},o.range=function(n){return arguments.length?(u=n,i()):u},o.quantiles=function(){return a},o.invertExtent=function(n){return n=u.indexOf(n),0>n?[0/0,0/0]:[n>0?a[n-1]:r[0],n<a.length?a[n]:r[r.length-1]]},o.copy=function(){return no(r,u)},i()}function to(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(i*(t-n))))]}function u(){return i=e.length/(t-n),o=e.length-1,r}var i,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],u()):[n,t]},r.range=function(n){return arguments.length?(e=n,u()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?0/0:t/i+n,[t,t+1/i]},r.copy=function(){return to(n,t,e)},u()}function eo(n,t){function e(e){return e>=e?t[ta.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return eo(n,t)},e}function ro(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Xi(n,t)},t.tickFormat=function(t,e){return $i(n,t,e)},t.copy=function(){return ro(n)},t}function uo(){return 0}function io(n){return n.innerRadius}function oo(n){return n.outerRadius}function ao(n){return n.startAngle}function co(n){return n.endAngle}function lo(n){return n&&n.padAngle}function so(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function fo(n,t,e,r,u){var i=n[0]-t[0],o=n[1]-t[1],a=(u?r:-r)/Math.sqrt(i*i+o*o),c=a*o,l=-a*i,s=n[0]+c,f=n[1]+l,h=t[0]+c,g=t[1]+l,p=(s+h)/2,v=(f+g)/2,d=h-s,m=g-f,y=d*d+m*m,M=e-r,x=s*g-h*f,b=(0>m?-1:1)*Math.sqrt(M*M*y-x*x),_=(x*m-d*b)/y,w=(-x*d-m*b)/y,S=(x*m+d*b)/y,k=(-x*d+m*b)/y,E=_-p,A=w-v,N=S-p,C=k-v;return E*E+A*A>N*N+C*C&&(_=S,w=k),[[_-c,w-l],[_*e/M,w*e/M]]}function ho(n){function t(t){function o(){l.push("M",i(n(s),a))}for(var c,l=[],s=[],f=-1,h=t.length,g=kt(e),p=kt(r);++f<h;)u.call(this,c=t[f],f)?s.push([+g.call(this,c,f),+p.call(this,c,f)]):s.length&&(o(),s=[]);return s.length&&o(),l.length?l.join(""):null}var e=Ar,r=Nr,u=Ne,i=go,o=i.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(u=n,t):u},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?i=n:(i=zl.get(n)||go).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function go(n){return n.join("L")}function po(n){return go(n)+"Z"}function vo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&u.push("H",r[0]),u.join("")}function mo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("V",(r=n[t])[1],"H",r[0]);return u.join("")}function yo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r=n[t])[0],"V",r[1]);return u.join("")}function Mo(n,t){return n.length<4?go(n):n[1]+_o(n.slice(1,-1),wo(n,t))}function xo(n,t){return n.length<3?go(n):n[0]+_o((n.push(n[0]),n),wo([n[n.length-2]].concat(n,[n[1]]),t))}function bo(n,t){return n.length<3?go(n):n[0]+_o(n,wo(n,t))}function _o(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return go(n);var e=n.length!=t.length,r="",u=n[0],i=n[1],o=t[0],a=o,c=1;if(e&&(r+="Q"+(i[0]-2*o[0]/3)+","+(i[1]-2*o[1]/3)+","+i[0]+","+i[1],u=n[1],c=2),t.length>1){a=t[1],i=n[c],c++,r+="C"+(u[0]+o[0])+","+(u[1]+o[1])+","+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1];for(var l=2;l<t.length;l++,c++)i=n[c],a=t[l],r+="S"+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1]}if(e){var s=n[c];r+="Q"+(i[0]+2*a[0]/3)+","+(i[1]+2*a[1]/3)+","+s[0]+","+s[1]}return r}function wo(n,t){for(var e,r=[],u=(1-t)/2,i=n[0],o=n[1],a=1,c=n.length;++a<c;)e=i,i=o,o=n[a],r.push([u*(o[0]-e[0]),u*(o[1]-e[1])]);return r}function So(n){if(n.length<3)return go(n);var t=1,e=n.length,r=n[0],u=r[0],i=r[1],o=[u,u,u,(r=n[1])[0]],a=[i,i,i,r[1]],c=[u,",",i,"L",No(Tl,o),",",No(Tl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Co(c,o,a);return n.pop(),c.push("L",r),c.join("")}function ko(n){if(n.length<4)return go(n);for(var t,e=[],r=-1,u=n.length,i=[0],o=[0];++r<3;)t=n[r],i.push(t[0]),o.push(t[1]);for(e.push(No(Tl,i)+","+No(Tl,o)),--r;++r<u;)t=n[r],i.shift(),i.push(t[0]),o.shift(),o.push(t[1]),Co(e,i,o);return e.join("")}function Eo(n){for(var t,e,r=-1,u=n.length,i=u+4,o=[],a=[];++r<4;)e=n[r%u],o.push(e[0]),a.push(e[1]);for(t=[No(Tl,o),",",No(Tl,a)],--r;++r<i;)e=n[r%u],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Co(t,o,a);return t.join("")}function Ao(n,t){var e=n.length-1;if(e)for(var r,u,i=n[0][0],o=n[0][1],a=n[e][0]-i,c=n[e][1]-o,l=-1;++l<=e;)r=n[l],u=l/e,r[0]=t*r[0]+(1-t)*(i+u*a),r[1]=t*r[1]+(1-t)*(o+u*c);return So(n)}function No(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Co(n,t,e){n.push("C",No(ql,t),",",No(ql,e),",",No(Ll,t),",",No(Ll,e),",",No(Tl,t),",",No(Tl,e))}function zo(n,t){return(t[1]-n[1])/(t[0]-n[0])}function qo(n){for(var t=0,e=n.length-1,r=[],u=n[0],i=n[1],o=r[0]=zo(u,i);++t<e;)r[t]=(o+(o=zo(u=i,i=n[t+1])))/2;return r[t]=o,r}function Lo(n){for(var t,e,r,u,i=[],o=qo(n),a=-1,c=n.length-1;++a<c;)t=zo(n[a],n[a+1]),va(t)<Ta?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,u=e*e+r*r,u>9&&(u=3*t/Math.sqrt(u),o[a]=u*e,o[a+1]=u*r));for(a=-1;++a<=c;)u=(n[Math.min(c,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),i.push([u||0,o[a]*u||0]);return i}function To(n){return n.length<3?go(n):n[0]+_o(n,Lo(n))}function Ro(n){for(var t,e,r,u=-1,i=n.length;++u<i;)t=n[u],e=t[0],r=t[1]-ja,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Do(n){function t(t){function c(){v.push("M",a(n(m),f),s,l(n(d.reverse()),f),"Z")}for(var h,g,p,v=[],d=[],m=[],y=-1,M=t.length,x=kt(e),b=kt(u),_=e===r?function(){return g}:kt(r),w=u===i?function(){return p}:kt(i);++y<M;)o.call(this,h=t[y],y)?(d.push([g=+x.call(this,h,y),p=+b.call(this,h,y)]),m.push([+_.call(this,h,y),+w.call(this,h,y)])):d.length&&(c(),d=[],m=[]);return d.length&&c(),v.length?v.join(""):null}var e=Ar,r=Ar,u=0,i=Nr,o=Ne,a=go,c=a.key,l=a,s="L",f=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(u=i=n,t):i},t.y0=function(n){return arguments.length?(u=n,t):u},t.y1=function(n){return arguments.length?(i=n,t):i},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(c="function"==typeof n?a=n:(a=zl.get(n)||go).key,l=a.reverse||a,s=a.closed?"M":"L",t):c
  },t.tension=function(n){return arguments.length?(f=n,t):f},t}function Po(n){return n.radius}function Uo(n){return[n.x,n.y]}function jo(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-ja;return[e*Math.cos(r),e*Math.sin(r)]}}function Fo(){return 64}function Ho(){return"circle"}function Oo(n){var t=Math.sqrt(n/Da);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Yo(n){return function(){var t,e;(t=this[n])&&(e=t[t.active])&&(--t.count?(delete t[t.active],t.active+=.5):delete this[n],e.event&&e.event.interrupt.call(this,this.__data__,e.index))}}function Io(n,t,e){return xa(n,Hl),n.namespace=t,n.id=e,n}function Zo(n,t,e,r){var u=n.id,i=n.namespace;return H(n,"function"==typeof e?function(n,o,a){n[i][u].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[i][u].tween.set(t,e)}))}function Vo(n){return null==n&&(n=""),function(){this.textContent=n}}function Xo(n){return null==n?"__transition__":"__transition_"+n+"__"}function $o(n,t,e,r,u){var i=n[e]||(n[e]={active:0,count:0}),o=i[r];if(!o){var c=u.time;o=i[r]={tween:new a,time:c,delay:u.delay,duration:u.duration,ease:u.ease,index:t},u=null,++i.count,ta.timer(function(u){function a(e){if(i.active>r)return s();var u=i[i.active];u&&(--i.count,delete i[i.active],u.event&&u.event.interrupt.call(n,n.__data__,u.index)),i.active=r,o.event&&o.event.start.call(n,n.__data__,t),o.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&v.push(r)}),h=o.ease,f=o.duration,ta.timer(function(){return p.c=l(e||1)?Ne:l,1},0,c)}function l(e){if(i.active!==r)return 1;for(var u=e/f,a=h(u),c=v.length;c>0;)v[--c].call(n,a);return u>=1?(o.event&&o.event.end.call(n,n.__data__,t),s()):void 0}function s(){return--i.count?delete i[r]:delete n[e],1}var f,h,g=o.delay,p=oc,v=[];return p.t=g+c,u>=g?a(u-g):(p.c=a,void 0)},0,c)}}function Bo(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function Wo(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function Jo(n){return n.toISOString()}function Go(n,t,e){function r(t){return n(t)}function u(n,e){var r=n[1]-n[0],u=r/e,i=ta.bisect(Wl,u);return i==Wl.length?[t.year,Vi(n.map(function(n){return n/31536e6}),e)[2]]:i?t[u/Wl[i-1]<Wl[i]/u?i-1:i]:[Kl,Vi(n,e)[2]]}return r.invert=function(t){return Ko(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(Ko)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,Ko(+e+1),t).length}var i=r.domain(),o=Pi(i),a=null==n?u(o,10):"number"==typeof n&&u(o,n);return a&&(n=a[0],t=a[1]),r.domain(Fi(i,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=Ko(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=Ko(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Pi(r.domain()),i=null==n?u(e,10):"number"==typeof n?u(e,n):!n.range&&[{range:n},t];return i&&(n=i[0],t=i[1]),n.range(e[0],Ko(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return Go(n.copy(),t,e)},Ii(r,n)}function Ko(n){return new Date(n)}function Qo(n){return JSON.parse(n.responseText)}function na(n){var t=ua.createRange();return t.selectNode(ua.body),t.createContextualFragment(n.responseText)}var ta={version:"3.5.2"};Date.now||(Date.now=function(){return+new Date});var ea=[].slice,ra=function(n){return ea.call(n)},ua=document,ia=ua.documentElement,oa=window;try{ra(ia.childNodes)[0].nodeType}catch(aa){ra=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}try{ua.createElement("div").style.setProperty("opacity",0,"")}catch(ca){var la=oa.Element.prototype,sa=la.setAttribute,fa=la.setAttributeNS,ha=oa.CSSStyleDeclaration.prototype,ga=ha.setProperty;la.setAttribute=function(n,t){sa.call(this,n,t+"")},la.setAttributeNS=function(n,t,e){fa.call(this,n,t,e+"")},ha.setProperty=function(n,t,e){ga.call(this,n,t+"",e)}}ta.ascending=n,ta.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:0/0},ta.min=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i;)if(null!=(r=n[u])&&r>=r){e=r;break}for(;++u<i;)null!=(r=n[u])&&e>r&&(e=r)}else{for(;++u<i;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=r;break}for(;++u<i;)null!=(r=t.call(n,n[u],u))&&e>r&&(e=r)}return e},ta.max=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i;)if(null!=(r=n[u])&&r>=r){e=r;break}for(;++u<i;)null!=(r=n[u])&&r>e&&(e=r)}else{for(;++u<i;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=r;break}for(;++u<i;)null!=(r=t.call(n,n[u],u))&&r>e&&(e=r)}return e},ta.extent=function(n,t){var e,r,u,i=-1,o=n.length;if(1===arguments.length){for(;++i<o;)if(null!=(r=n[i])&&r>=r){e=u=r;break}for(;++i<o;)null!=(r=n[i])&&(e>r&&(e=r),r>u&&(u=r))}else{for(;++i<o;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=u=r;break}for(;++i<o;)null!=(r=t.call(n,n[i],i))&&(e>r&&(e=r),r>u&&(u=r))}return[e,u]},ta.sum=function(n,t){var r,u=0,i=n.length,o=-1;if(1===arguments.length)for(;++o<i;)e(r=+n[o])&&(u+=r);else for(;++o<i;)e(r=+t.call(n,n[o],o))&&(u+=r);return u},ta.mean=function(n,r){var u,i=0,o=n.length,a=-1,c=o;if(1===arguments.length)for(;++a<o;)e(u=t(n[a]))?i+=u:--c;else for(;++a<o;)e(u=t(r.call(n,n[a],a)))?i+=u:--c;return c?i/c:void 0},ta.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),u=+n[r-1],i=e-r;return i?u+i*(n[r]-u):u},ta.median=function(r,u){var i,o=[],a=r.length,c=-1;if(1===arguments.length)for(;++c<a;)e(i=t(r[c]))&&o.push(i);else for(;++c<a;)e(i=t(u.call(r,r[c],c)))&&o.push(i);return o.length?ta.quantile(o.sort(n),.5):void 0},ta.variance=function(n,r){var u,i,o=n.length,a=0,c=0,l=-1,s=0;if(1===arguments.length)for(;++l<o;)e(u=t(n[l]))&&(i=u-a,a+=i/++s,c+=i*(u-a));else for(;++l<o;)e(u=t(r.call(n,n[l],l)))&&(i=u-a,a+=i/++s,c+=i*(u-a));return s>1?c/(s-1):void 0},ta.deviation=function(){var n=ta.variance.apply(this,arguments);return n?Math.sqrt(n):n};var pa=r(n);ta.bisectLeft=pa.left,ta.bisect=ta.bisectRight=pa.right,ta.bisector=function(t){return r(1===t.length?function(e,r){return n(t(e),r)}:t)},ta.shuffle=function(n,t,e){(i=arguments.length)<3&&(e=n.length,2>i&&(t=0));for(var r,u,i=e-t;i;)u=0|Math.random()*i--,r=n[i+t],n[i+t]=n[u+t],n[u+t]=r;return n},ta.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ta.pairs=function(n){for(var t,e=0,r=n.length-1,u=n[0],i=new Array(0>r?0:r);r>e;)i[e]=[t=u,u=n[++e]];return i},ta.zip=function(){if(!(r=arguments.length))return[];for(var n=-1,t=ta.min(arguments,u),e=new Array(t);++n<t;)for(var r,i=-1,o=e[n]=new Array(r);++i<r;)o[i]=arguments[i][n];return e},ta.transpose=function(n){return ta.zip.apply(ta,n)},ta.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ta.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ta.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ta.merge=function(n){for(var t,e,r,u=n.length,i=-1,o=0;++i<u;)o+=n[i].length;for(e=new Array(o);--u>=0;)for(r=n[u],t=r.length;--t>=0;)e[--o]=r[t];return e};var va=Math.abs;ta.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),1/0===(t-n)/e)throw new Error("infinite range");var r,u=[],o=i(va(e)),a=-1;if(n*=o,t*=o,e*=o,0>e)for(;(r=n+e*++a)>t;)u.push(r/o);else for(;(r=n+e*++a)<t;)u.push(r/o);return u},ta.map=function(n,t){var e=new a;if(n instanceof a)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,u=-1,i=n.length;if(1===arguments.length)for(;++u<i;)e.set(u,n[u]);else for(;++u<i;)e.set(t.call(n,r=n[u],u),r)}else for(var o in n)e.set(o,n[o]);return e};var da="__proto__",ma="\x00";o(a,{has:s,get:function(n){return this._[c(n)]},set:function(n,t){return this._[c(n)]=t},remove:f,keys:h,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:l(t),value:this._[t]});return n},size:g,empty:p,forEach:function(n){for(var t in this._)n.call(this,l(t),this._[t])}}),ta.nest=function(){function n(t,o,c){if(c>=i.length)return r?r.call(u,o):e?o.sort(e):o;for(var l,s,f,h,g=-1,p=o.length,v=i[c++],d=new a;++g<p;)(h=d.get(l=v(s=o[g])))?h.push(s):d.set(l,[s]);return t?(s=t(),f=function(e,r){s.set(e,n(t,r,c))}):(s={},f=function(e,r){s[e]=n(t,r,c)}),d.forEach(f),s}function t(n,e){if(e>=i.length)return n;var r=[],u=o[e++];return n.forEach(function(n,u){r.push({key:n,values:t(u,e)})}),u?r.sort(function(n,t){return u(n.key,t.key)}):r}var e,r,u={},i=[],o=[];return u.map=function(t,e){return n(e,t,0)},u.entries=function(e){return t(n(ta.map,e,0),0)},u.key=function(n){return i.push(n),u},u.sortKeys=function(n){return o[i.length-1]=n,u},u.sortValues=function(n){return e=n,u},u.rollup=function(n){return r=n,u},u},ta.set=function(n){var t=new v;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},o(v,{has:s,add:function(n){return this._[c(n+="")]=!0,n},remove:f,values:h,size:g,empty:p,forEach:function(n){for(var t in this._)n.call(this,l(t))}}),ta.behavior={},ta.rebind=function(n,t){for(var e,r=1,u=arguments.length;++r<u;)n[e=arguments[r]]=d(n,t,t[e]);return n};var ya=["webkit","ms","moz","Moz","o","O"];ta.dispatch=function(){for(var n=new M,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=x(n);return n},M.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ta.event=null,ta.requote=function(n){return n.replace(Ma,"\\$&")};var Ma=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,xa={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},ba=function(n,t){return t.querySelector(n)},_a=function(n,t){return t.querySelectorAll(n)},wa=ia.matches||ia[m(ia,"matchesSelector")],Sa=function(n,t){return wa.call(n,t)};"function"==typeof Sizzle&&(ba=function(n,t){return Sizzle(n,t)[0]||null},_a=Sizzle,Sa=Sizzle.matchesSelector),ta.selection=function(){return Na};var ka=ta.selection.prototype=[];ka.select=function(n){var t,e,r,u,i=[];n=k(n);for(var o=-1,a=this.length;++o<a;){i.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var c=-1,l=r.length;++c<l;)(u=r[c])?(t.push(e=n.call(u,u.__data__,c,o)),e&&"__data__"in u&&(e.__data__=u.__data__)):t.push(null)}return S(i)},ka.selectAll=function(n){var t,e,r=[];n=E(n);for(var u=-1,i=this.length;++u<i;)for(var o=this[u],a=-1,c=o.length;++a<c;)(e=o[a])&&(r.push(t=ra(n.call(e,e.__data__,a,u))),t.parentNode=e);return S(r)};var Ea={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ta.ns={prefix:Ea,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&(e=n.slice(0,t),n=n.slice(t+1)),Ea.hasOwnProperty(e)?{space:Ea[e],local:n}:n}},ka.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ta.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(A(t,n[t]));return this}return this.each(A(n,t))},ka.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=z(n)).length,u=-1;if(t=e.classList){for(;++u<r;)if(!t.contains(n[u]))return!1}else for(t=e.getAttribute("class");++u<r;)if(!C(n[u]).test(t))return!1;return!0}for(t in n)this.each(q(t,n[t]));return this}return this.each(q(n,t))},ka.style=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t="");for(e in n)this.each(T(e,n[e],t));return this}if(2>r)return oa.getComputedStyle(this.node(),null).getPropertyValue(n);e=""}return this.each(T(n,t,e))},ka.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},ka.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},ka.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},ka.append=function(n){return n=D(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},ka.insert=function(n,t){return n=D(n),t=k(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},ka.remove=function(){return this.each(P)},ka.data=function(n,t){function e(n,e){var r,u,i,o=n.length,f=e.length,h=Math.min(o,f),g=new Array(f),p=new Array(f),v=new Array(o);if(t){var d,m=new a,y=new Array(o);for(r=-1;++r<o;)m.has(d=t.call(u=n[r],u.__data__,r))?v[r]=u:m.set(d,u),y[r]=d;for(r=-1;++r<f;)(u=m.get(d=t.call(e,i=e[r],r)))?u!==!0&&(g[r]=u,u.__data__=i):p[r]=U(i),m.set(d,!0);for(r=-1;++r<o;)m.get(y[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)u=n[r],i=e[r],u?(u.__data__=i,g[r]=u):p[r]=U(i);for(;f>r;++r)p[r]=U(e[r]);for(;o>r;++r)v[r]=n[r]}p.update=g,p.parentNode=g.parentNode=v.parentNode=n.parentNode,c.push(p),l.push(g),s.push(v)}var r,u,i=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++i<o;)(u=r[i])&&(n[i]=u.__data__);return n}var c=O([]),l=S([]),s=S([]);if("function"==typeof n)for(;++i<o;)e(r=this[i],n.call(r,r.parentNode.__data__,i));else for(;++i<o;)e(r=this[i],n);return l.enter=function(){return c},l.exit=function(){return s},l},ka.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},ka.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=j(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]),t.parentNode=(e=this[i]).parentNode;for(var a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return S(u)},ka.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],u=r.length-1,i=r[u];--u>=0;)(e=r[u])&&(i&&i!==e.nextSibling&&i.parentNode.insertBefore(e,i),i=e);return this},ka.sort=function(n){n=F.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},ka.each=function(n){return H(this,function(t,e,r){n.call(t,t.__data__,e,r)})},ka.call=function(n){var t=ra(arguments);return n.apply(t[0]=this,t),this},ka.empty=function(){return!this.node()},ka.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,u=e.length;u>r;r++){var i=e[r];if(i)return i}return null},ka.size=function(){var n=0;return H(this,function(){++n}),n};var Aa=[];ta.selection.enter=O,ta.selection.enter.prototype=Aa,Aa.append=ka.append,Aa.empty=ka.empty,Aa.node=ka.node,Aa.call=ka.call,Aa.size=ka.size,Aa.select=function(n){for(var t,e,r,u,i,o=[],a=-1,c=this.length;++a<c;){r=(u=this[a]).update,o.push(t=[]),t.parentNode=u.parentNode;for(var l=-1,s=u.length;++l<s;)(i=u[l])?(t.push(r[l]=e=n.call(u.parentNode,i.__data__,l,a)),e.__data__=i.__data__):t.push(null)}return S(o)},Aa.insert=function(n,t){return arguments.length<2&&(t=Y(this)),ka.insert.call(this,n,t)},ta.select=function(n){var t=["string"==typeof n?ba(n,ua):n];return t.parentNode=ia,S([t])},ta.selectAll=function(n){var t=ra("string"==typeof n?_a(n,ua):n);return t.parentNode=ia,S([t])};var Na=ta.select(ia);ka.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(I(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(I(n,t,e))};var Ca=ta.map({mouseenter:"mouseover",mouseleave:"mouseout"});Ca.forEach(function(n){"on"+n in ua&&Ca.remove(n)});var za="onselectstart"in ua?null:m(ia.style,"userSelect"),qa=0;ta.mouse=function(n){return $(n,_())};var La=/WebKit/.test(oa.navigator.userAgent)?-1:0;ta.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=_().changedTouches),t)for(var r,u=0,i=t.length;i>u;++u)if((r=t[u]).identifier===e)return $(n,r)},ta.behavior.drag=function(){function n(){this.on("mousedown.drag",u).on("touchstart.drag",i)}function t(n,t,u,i,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],p|=n|e,M=r,g({type:"drag",x:r[0]+l[0],y:r[1]+l[1],dx:n,dy:e}))}function c(){t(h,v)&&(m.on(i+d,null).on(o+d,null),y(p&&ta.event.target===f),g({type:"dragend"}))}var l,s=this,f=ta.event.target,h=s.parentNode,g=e.of(s,arguments),p=0,v=n(),d=".drag"+(null==v?"":"-"+v),m=ta.select(u()).on(i+d,a).on(o+d,c),y=X(),M=t(h,v);r?(l=r.apply(s,arguments),l=[l.x-M[0],l.y-M[1]]):l=[0,0],g({type:"dragstart"})}}var e=w(n,"drag","dragstart","dragend"),r=null,u=t(y,ta.mouse,J,"mousemove","mouseup"),i=t(B,ta.touch,W,"touchmove","touchend");return n.origin=function(t){return arguments.length?(r=t,n):r},ta.rebind(n,e,"on")},ta.touches=function(n,t){return arguments.length<2&&(t=_().touches),t?ra(t).map(function(t){var e=$(n,t);return e.identifier=t.identifier,e}):[]};var Ta=1e-6,Ra=Ta*Ta,Da=Math.PI,Pa=2*Da,Ua=Pa-Ta,ja=Da/2,Fa=Da/180,Ha=180/Da,Oa=Math.SQRT2,Ya=2,Ia=4;ta.interpolateZoom=function(n,t){function e(n){var t=n*y;if(m){var e=et(v),o=i/(Ya*h)*(e*rt(Oa*t+v)-tt(v));return[r+o*l,u+o*s,i*e/et(Oa*t+v)]}return[r+n*l,u+n*s,i*Math.exp(Oa*t)]}var r=n[0],u=n[1],i=n[2],o=t[0],a=t[1],c=t[2],l=o-r,s=a-u,f=l*l+s*s,h=Math.sqrt(f),g=(c*c-i*i+Ia*f)/(2*i*Ya*h),p=(c*c-i*i-Ia*f)/(2*c*Ya*h),v=Math.log(Math.sqrt(g*g+1)-g),d=Math.log(Math.sqrt(p*p+1)-p),m=d-v,y=(m||Math.log(c/i))/Oa;return e.duration=1e3*y,e},ta.behavior.zoom=function(){function n(n){n.on(z,s).on(Xa+".zoom",h).on("dblclick.zoom",g).on(T,f)}function t(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function e(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function r(n){k.k=Math.max(A[0],Math.min(A[1],n))}function u(n,t){t=e(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function i(t,e,i,o){t.__chart__={x:k.x,y:k.y,k:k.k},r(Math.pow(2,o)),u(v=e,i),t=ta.select(t),N>0&&(t=t.transition().duration(N)),t.call(n.event)}function o(){x&&x.domain(M.range().map(function(n){return(n-k.x)/k.k}).map(M.invert)),S&&S.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function a(n){C++||n({type:"zoomstart"})}function c(n){o(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function l(n){--C||n({type:"zoomend"}),v=null}function s(){function n(){s=1,u(ta.mouse(r),h),c(o)}function e(){f.on(q,null).on(L,null),g(s&&ta.event.target===i),l(o)}var r=this,i=ta.event.target,o=R.of(r,arguments),s=0,f=ta.select(oa).on(q,n).on(L,e),h=t(ta.mouse(r)),g=X();Fl.call(r),a(o)}function f(){function n(){var n=ta.touches(p);return g=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=t(n))}),n}function e(){var t=ta.event.target;ta.select(t).on(x,o).on(_,h),w.push(t);for(var e=ta.event.changedTouches,r=0,u=e.length;u>r;++r)d[e[r].identifier]=null;var a=n(),c=Date.now();if(1===a.length){if(500>c-y){var l=a[0];i(p,l,d[l.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),b()}y=c}else if(a.length>1){var l=a[0],s=a[1],f=l[0]-s[0],g=l[1]-s[1];m=f*f+g*g}}function o(){var n,t,e,i,o=ta.touches(p);Fl.call(p);for(var a=0,l=o.length;l>a;++a,i=null)if(e=o[a],i=d[e.identifier]){if(t)break;n=e,t=i}if(i){var s=(s=e[0]-n[0])*s+(s=e[1]-n[1])*s,f=m&&Math.sqrt(s/m);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+i[0])/2,(t[1]+i[1])/2],r(f*g)}y=null,u(n,t),c(v)}function h(){if(ta.event.touches.length){for(var t=ta.event.changedTouches,e=0,r=t.length;r>e;++e)delete d[t[e].identifier];for(var u in d)return void n()}ta.selectAll(w).on(M,null),S.on(z,s).on(T,f),E(),l(v)}var g,p=this,v=R.of(p,arguments),d={},m=0,M=".zoom-"+ta.event.changedTouches[0].identifier,x="touchmove"+M,_="touchend"+M,w=[],S=ta.select(p),E=X();e(),a(v),S.on(z,null).on(T,e)}function h(){var n=R.of(this,arguments);m?clearTimeout(m):(p=t(v=d||ta.mouse(this)),Fl.call(this),a(n)),m=setTimeout(function(){m=null,l(n)},50),b(),r(Math.pow(2,.002*Za())*k.k),u(v,p),c(n)}function g(){var n=ta.mouse(this),e=Math.log(k.k)/Math.LN2;i(this,n,t(n),ta.event.shiftKey?Math.ceil(e)-1:Math.floor(e)+1)}var p,v,d,m,y,M,x,_,S,k={x:0,y:0,k:1},E=[960,500],A=Va,N=250,C=0,z="mousedown.zoom",q="mousemove.zoom",L="mouseup.zoom",T="touchstart.zoom",R=w(n,"zoomstart","zoom","zoomend");return n.event=function(n){n.each(function(){var n=R.of(this,arguments),t=k;Ul?ta.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},a(n)}).tween("zoom:zoom",function(){var e=E[0],r=E[1],u=v?v[0]:e/2,i=v?v[1]:r/2,o=ta.interpolateZoom([(u-k.x)/k.k,(i-k.y)/k.k,e/k.k],[(u-t.x)/t.k,(i-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:u-r[0]*a,y:i-r[1]*a,k:a},c(n)}}).each("interrupt.zoom",function(){l(n)}).each("end.zoom",function(){l(n)}):(this.__chart__=k,a(n),c(n),l(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},o(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:+t},o(),n):k.k},n.scaleExtent=function(t){return arguments.length?(A=null==t?Va:[+t[0],+t[1]],n):A},n.center=function(t){return arguments.length?(d=t&&[+t[0],+t[1]],n):d},n.size=function(t){return arguments.length?(E=t&&[+t[0],+t[1]],n):E},n.duration=function(t){return arguments.length?(N=+t,n):N},n.x=function(t){return arguments.length?(x=t,M=t.copy(),k={x:0,y:0,k:1},n):x},n.y=function(t){return arguments.length?(S=t,_=t.copy(),k={x:0,y:0,k:1},n):S},ta.rebind(n,R,"on")};var Za,Va=[0,1/0],Xa="onwheel"in ua?(Za=function(){return-ta.event.deltaY*(ta.event.deltaMode?120:1)},"wheel"):"onmousewheel"in ua?(Za=function(){return ta.event.wheelDelta},"mousewheel"):(Za=function(){return-ta.event.detail},"MozMousePixelScroll");ta.color=it,it.prototype.toString=function(){return this.rgb()+""},ta.hsl=ot;var $a=ot.prototype=new it;$a.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new ot(this.h,this.s,this.l/n)},$a.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new ot(this.h,this.s,n*this.l)},$a.rgb=function(){return at(this.h,this.s,this.l)},ta.hcl=ct;var Ba=ct.prototype=new it;Ba.brighter=function(n){return new ct(this.h,this.c,Math.min(100,this.l+Wa*(arguments.length?n:1)))},Ba.darker=function(n){return new ct(this.h,this.c,Math.max(0,this.l-Wa*(arguments.length?n:1)))},Ba.rgb=function(){return lt(this.h,this.c,this.l).rgb()},ta.lab=st;var Wa=18,Ja=.95047,Ga=1,Ka=1.08883,Qa=st.prototype=new it;Qa.brighter=function(n){return new st(Math.min(100,this.l+Wa*(arguments.length?n:1)),this.a,this.b)},Qa.darker=function(n){return new st(Math.max(0,this.l-Wa*(arguments.length?n:1)),this.a,this.b)},Qa.rgb=function(){return ft(this.l,this.a,this.b)},ta.rgb=dt;var nc=dt.prototype=new it;nc.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,u=30;return t||e||r?(t&&u>t&&(t=u),e&&u>e&&(e=u),r&&u>r&&(r=u),new dt(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new dt(u,u,u)},nc.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new dt(n*this.r,n*this.g,n*this.b)},nc.hsl=function(){return bt(this.r,this.g,this.b)},nc.toString=function(){return"#"+Mt(this.r)+Mt(this.g)+Mt(this.b)};var tc=ta.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});tc.forEach(function(n,t){tc.set(n,mt(t))}),ta.functor=kt,ta.xhr=At(Et),ta.dsv=function(n,t){function e(n,e,i){arguments.length<3&&(i=e,e=null);var o=Nt(n,t,null==e?r:u(e),i);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:u(n)):e},o}function r(n){return e.parse(n.responseText)}function u(n){return function(t){return e.parse(t.responseText,n)}}function i(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),c=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var u=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(u(n),e)}:u})},e.parseRows=function(n,t){function e(){if(s>=l)return o;if(u)return u=!1,i;var t=s;if(34===n.charCodeAt(t)){for(var e=t;e++<l;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}s=e+2;var r=n.charCodeAt(e+1);return 13===r?(u=!0,10===n.charCodeAt(e+2)&&++s):10===r&&(u=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;l>s;){var r=n.charCodeAt(s++),a=1;if(10===r)u=!0;else if(13===r)u=!0,10===n.charCodeAt(s)&&(++s,++a);else if(r!==c)continue;return n.slice(t,s-a)}return n.slice(t)}for(var r,u,i={},o={},a=[],l=n.length,s=0,f=0;(r=e())!==o;){for(var h=[];r!==i&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,f++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new v,u=[];return t.forEach(function(n){for(var t in n)r.has(t)||u.push(r.add(t))}),[u.map(o).join(n)].concat(t.map(function(t){return u.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(i).join("\n")},e},ta.csv=ta.dsv(",","text/csv"),ta.tsv=ta.dsv("	","text/tab-separated-values");var ec,rc,uc,ic,oc,ac=oa[m(oa,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ta.timer=function(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var u=e+t,i={c:n,t:u,f:!1,n:null};rc?rc.n=i:ec=i,rc=i,uc||(ic=clearTimeout(ic),uc=1,ac(qt))},ta.timer.flush=function(){Lt(),Tt()},ta.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var cc=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Dt);ta.formatPrefix=function(n,t){var e=0;return n&&(0>n&&(n*=-1),t&&(n=ta.round(n,Rt(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),cc[8+e/3]};var lc=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,sc=ta.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ta.round(n,Rt(n,t))).toFixed(Math.max(0,Math.min(20,Rt(n*(1+1e-15),t))))}}),fc=ta.time={},hc=Date;jt.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){gc.setUTCDate.apply(this._,arguments)},setDay:function(){gc.setUTCDay.apply(this._,arguments)},setFullYear:function(){gc.setUTCFullYear.apply(this._,arguments)},setHours:function(){gc.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){gc.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){gc.setUTCMinutes.apply(this._,arguments)},setMonth:function(){gc.setUTCMonth.apply(this._,arguments)},setSeconds:function(){gc.setUTCSeconds.apply(this._,arguments)},setTime:function(){gc.setTime.apply(this._,arguments)}};var gc=Date.prototype;fc.year=Ft(function(n){return n=fc.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),fc.years=fc.year.range,fc.years.utc=fc.year.utc.range,fc.day=Ft(function(n){var t=new hc(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),fc.days=fc.day.range,fc.days.utc=fc.day.utc.range,fc.dayOfYear=function(n){var t=fc.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=fc[n]=Ft(function(n){return(n=fc.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=fc.year(n).getDay();return Math.floor((fc.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});fc[n+"s"]=e.range,fc[n+"s"].utc=e.utc.range,fc[n+"OfYear"]=function(n){var e=fc.year(n).getDay();return Math.floor((fc.dayOfYear(n)+(e+t)%7)/7)}}),fc.week=fc.sunday,fc.weeks=fc.sunday.range,fc.weeks.utc=fc.sunday.utc.range,fc.weekOfYear=fc.sundayOfYear;var pc={"-":"",_:" ",0:"0"},vc=/^\s*\d+/,dc=/^%/;ta.locale=function(n){return{numberFormat:Pt(n),timeFormat:Ot(n)}};var mc=ta.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ta.format=mc.numberFormat,ta.geo={},ce.prototype={s:0,t:0,add:function(n){le(n,this.t,yc),le(yc.s,this.s,this),this.s?this.t+=yc.t:this.s=yc.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var yc=new ce;ta.geo.stream=function(n,t){n&&Mc.hasOwnProperty(n.type)?Mc[n.type](n,t):se(n,t)};var Mc={Feature:function(n,t){se(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,u=e.length;++r<u;)se(e[r].geometry,t)}},xc={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)n=e[r],t.point(n[0],n[1],n[2])
  },LineString:function(n,t){fe(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)fe(e[r],t,0)},Polygon:function(n,t){he(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)he(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,u=e.length;++r<u;)se(e[r],t)}};ta.geo.area=function(n){return bc=0,ta.geo.stream(n,wc),bc};var bc,_c=new ce,wc={sphere:function(){bc+=4*Da},point:y,lineStart:y,lineEnd:y,polygonStart:function(){_c.reset(),wc.lineStart=ge},polygonEnd:function(){var n=2*_c;bc+=0>n?4*Da+n:n,wc.lineStart=wc.lineEnd=wc.point=y}};ta.geo.bounds=function(){function n(n,t){M.push(x=[s=n,h=n]),f>t&&(f=t),t>g&&(g=t)}function t(t,e){var r=pe([t*Fa,e*Fa]);if(m){var u=de(m,r),i=[u[1],-u[0],0],o=de(i,u);Me(o),o=xe(o);var c=t-p,l=c>0?1:-1,v=o[0]*Ha*l,d=va(c)>180;if(d^(v>l*p&&l*t>v)){var y=o[1]*Ha;y>g&&(g=y)}else if(v=(v+360)%360-180,d^(v>l*p&&l*t>v)){var y=-o[1]*Ha;f>y&&(f=y)}else f>e&&(f=e),e>g&&(g=e);d?p>t?a(s,t)>a(s,h)&&(h=t):a(t,h)>a(s,h)&&(s=t):h>=s?(s>t&&(s=t),t>h&&(h=t)):t>p?a(s,t)>a(s,h)&&(h=t):a(t,h)>a(s,h)&&(s=t)}else n(t,e);m=r,p=t}function e(){b.point=t}function r(){x[0]=s,x[1]=h,b.point=n,m=null}function u(n,e){if(m){var r=n-p;y+=va(r)>180?r+(r>0?360:-360):r}else v=n,d=e;wc.point(n,e),t(n,e)}function i(){wc.lineStart()}function o(){u(v,d),wc.lineEnd(),va(y)>Ta&&(s=-(h=180)),x[0]=s,x[1]=h,m=null}function a(n,t){return(t-=n)<0?t+360:t}function c(n,t){return n[0]-t[0]}function l(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var s,f,h,g,p,v,d,m,y,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=u,b.lineStart=i,b.lineEnd=o,y=0,wc.polygonStart()},polygonEnd:function(){wc.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,0>_c?(s=-(h=180),f=-(g=90)):y>Ta?g=90:-Ta>y&&(f=-90),x[0]=s,x[1]=h}};return function(n){g=h=-(s=f=1/0),M=[],ta.geo.stream(n,b);var t=M.length;if(t){M.sort(c);for(var e,r=1,u=M[0],i=[u];t>r;++r)e=M[r],l(e[0],u)||l(e[1],u)?(a(u[0],e[1])>a(u[0],u[1])&&(u[1]=e[1]),a(e[0],u[1])>a(u[0],u[1])&&(u[0]=e[0])):i.push(u=e);for(var o,e,p=-1/0,t=i.length-1,r=0,u=i[t];t>=r;u=e,++r)e=i[r],(o=a(u[1],e[0]))>p&&(p=o,s=e[0],h=u[1])}return M=x=null,1/0===s||1/0===f?[[0/0,0/0],[0/0,0/0]]:[[s,f],[h,g]]}}(),ta.geo.centroid=function(n){Sc=kc=Ec=Ac=Nc=Cc=zc=qc=Lc=Tc=Rc=0,ta.geo.stream(n,Dc);var t=Lc,e=Tc,r=Rc,u=t*t+e*e+r*r;return Ra>u&&(t=Cc,e=zc,r=qc,Ta>kc&&(t=Ec,e=Ac,r=Nc),u=t*t+e*e+r*r,Ra>u)?[0/0,0/0]:[Math.atan2(e,t)*Ha,nt(r/Math.sqrt(u))*Ha]};var Sc,kc,Ec,Ac,Nc,Cc,zc,qc,Lc,Tc,Rc,Dc={sphere:y,point:_e,lineStart:Se,lineEnd:ke,polygonStart:function(){Dc.lineStart=Ee},polygonEnd:function(){Dc.lineStart=Se}},Pc=Le(Ne,Pe,je,[-Da,-Da/2]),Uc=1e9;ta.geo.clipExtent=function(){var n,t,e,r,u,i,o={stream:function(n){return u&&(u.valid=!1),u=i(n),u.valid=!0,u},extent:function(a){return arguments.length?(i=Ye(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),u&&(u.valid=!1,u=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ta.geo.conicEqualArea=function(){return Ie(Ze)}).raw=Ze,ta.geo.albers=function(){return ta.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ta.geo.albersUsa=function(){function n(n){var i=n[0],o=n[1];return t=null,e(i,o),t||(r(i,o),t)||u(i,o),t}var t,e,r,u,i=ta.geo.albers(),o=ta.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ta.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),c={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=i.scale(),e=i.translate(),r=(n[0]-e[0])/t,u=(n[1]-e[1])/t;return(u>=.12&&.234>u&&r>=-.425&&-.214>r?o:u>=.166&&.234>u&&r>=-.214&&-.115>r?a:i).invert(n)},n.stream=function(n){var t=i.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,u){t.point(n,u),e.point(n,u),r.point(n,u)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(i.precision(t),o.precision(t),a.precision(t),n):i.precision()},n.scale=function(t){return arguments.length?(i.scale(t),o.scale(.35*t),a.scale(t),n.translate(i.translate())):i.scale()},n.translate=function(t){if(!arguments.length)return i.translate();var l=i.scale(),s=+t[0],f=+t[1];return e=i.translate(t).clipExtent([[s-.455*l,f-.238*l],[s+.455*l,f+.238*l]]).stream(c).point,r=o.translate([s-.307*l,f+.201*l]).clipExtent([[s-.425*l+Ta,f+.12*l+Ta],[s-.214*l-Ta,f+.234*l-Ta]]).stream(c).point,u=a.translate([s-.205*l,f+.212*l]).clipExtent([[s-.214*l+Ta,f+.166*l+Ta],[s-.115*l-Ta,f+.234*l-Ta]]).stream(c).point,n},n.scale(1070)};var jc,Fc,Hc,Oc,Yc,Ic,Zc={point:y,lineStart:y,lineEnd:y,polygonStart:function(){Fc=0,Zc.lineStart=Ve},polygonEnd:function(){Zc.lineStart=Zc.lineEnd=Zc.point=y,jc+=va(Fc/2)}},Vc={point:Xe,lineStart:y,lineEnd:y,polygonStart:y,polygonEnd:y},Xc={point:We,lineStart:Je,lineEnd:Ge,polygonStart:function(){Xc.lineStart=Ke},polygonEnd:function(){Xc.point=We,Xc.lineStart=Je,Xc.lineEnd=Ge}};ta.geo.path=function(){function n(n){return n&&("function"==typeof a&&i.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=u(i)),ta.geo.stream(n,o)),i.result()}function t(){return o=null,n}var e,r,u,i,o,a=4.5;return n.area=function(n){return jc=0,ta.geo.stream(n,u(Zc)),jc},n.centroid=function(n){return Ec=Ac=Nc=Cc=zc=qc=Lc=Tc=Rc=0,ta.geo.stream(n,u(Xc)),Rc?[Lc/Rc,Tc/Rc]:qc?[Cc/qc,zc/qc]:Nc?[Ec/Nc,Ac/Nc]:[0/0,0/0]},n.bounds=function(n){return Yc=Ic=-(Hc=Oc=1/0),ta.geo.stream(n,u(Vc)),[[Hc,Oc],[Yc,Ic]]},n.projection=function(n){return arguments.length?(u=(e=n)?n.stream||tr(n):Et,t()):e},n.context=function(n){return arguments.length?(i=null==(r=n)?new $e:new Qe(n),"function"!=typeof a&&i.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(i.pointRadius(+t),+t),n):a},n.projection(ta.geo.albersUsa()).context(null)},ta.geo.transform=function(n){return{stream:function(t){var e=new er(t);for(var r in n)e[r]=n[r];return e}}},er.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ta.geo.projection=ur,ta.geo.projectionMutator=ir,(ta.geo.equirectangular=function(){return ur(ar)}).raw=ar.invert=ar,ta.geo.rotation=function(n){function t(t){return t=n(t[0]*Fa,t[1]*Fa),t[0]*=Ha,t[1]*=Ha,t}return n=lr(n[0]%360*Fa,n[1]*Fa,n.length>2?n[2]*Fa:0),t.invert=function(t){return t=n.invert(t[0]*Fa,t[1]*Fa),t[0]*=Ha,t[1]*=Ha,t},t},cr.invert=ar,ta.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=lr(-n[0]*Fa,-n[1]*Fa,0).invert,u=[];return e(null,null,1,{point:function(n,e){u.push(n=t(n,e)),n[0]*=Ha,n[1]*=Ha}}),{type:"Polygon",coordinates:[u]}}var t,e,r=[0,0],u=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=gr((t=+r)*Fa,u*Fa),n):t},n.precision=function(r){return arguments.length?(e=gr(t*Fa,(u=+r)*Fa),n):u},n.angle(90)},ta.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Fa,u=n[1]*Fa,i=t[1]*Fa,o=Math.sin(r),a=Math.cos(r),c=Math.sin(u),l=Math.cos(u),s=Math.sin(i),f=Math.cos(i);return Math.atan2(Math.sqrt((e=f*o)*e+(e=l*s-c*f*a)*e),c*s+l*f*a)},ta.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ta.range(Math.ceil(i/d)*d,u,d).map(h).concat(ta.range(Math.ceil(l/m)*m,c,m).map(g)).concat(ta.range(Math.ceil(r/p)*p,e,p).filter(function(n){return va(n%d)>Ta}).map(s)).concat(ta.range(Math.ceil(a/v)*v,o,v).filter(function(n){return va(n%m)>Ta}).map(f))}var e,r,u,i,o,a,c,l,s,f,h,g,p=10,v=p,d=90,m=360,y=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(i).concat(g(c).slice(1),h(u).reverse().slice(1),g(l).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(i=+t[0][0],u=+t[1][0],l=+t[0][1],c=+t[1][1],i>u&&(t=i,i=u,u=t),l>c&&(t=l,l=c,c=t),n.precision(y)):[[i,l],[u,c]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(y)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],m=+t[1],n):[d,m]},n.minorStep=function(t){return arguments.length?(p=+t[0],v=+t[1],n):[p,v]},n.precision=function(t){return arguments.length?(y=+t,s=vr(a,o,90),f=dr(r,e,y),h=vr(l,c,90),g=dr(i,u,y),n):y},n.majorExtent([[-180,-90+Ta],[180,90-Ta]]).minorExtent([[-180,-80-Ta],[180,80+Ta]])},ta.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||u.apply(this,arguments)]}}var t,e,r=mr,u=yr;return n.distance=function(){return ta.geo.distance(t||r.apply(this,arguments),e||u.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(u=t,e="function"==typeof t?null:t,n):u},n.precision=function(){return arguments.length?n:0},n},ta.geo.interpolate=function(n,t){return Mr(n[0]*Fa,n[1]*Fa,t[0]*Fa,t[1]*Fa)},ta.geo.length=function(n){return $c=0,ta.geo.stream(n,Bc),$c};var $c,Bc={sphere:y,point:y,lineStart:xr,lineEnd:y,polygonStart:y,polygonEnd:y},Wc=br(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ta.geo.azimuthalEqualArea=function(){return ur(Wc)}).raw=Wc;var Jc=br(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},Et);(ta.geo.azimuthalEquidistant=function(){return ur(Jc)}).raw=Jc,(ta.geo.conicConformal=function(){return Ie(_r)}).raw=_r,(ta.geo.conicEquidistant=function(){return Ie(wr)}).raw=wr;var Gc=br(function(n){return 1/n},Math.atan);(ta.geo.gnomonic=function(){return ur(Gc)}).raw=Gc,Sr.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-ja]},(ta.geo.mercator=function(){return kr(Sr)}).raw=Sr;var Kc=br(function(){return 1},Math.asin);(ta.geo.orthographic=function(){return ur(Kc)}).raw=Kc;var Qc=br(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ta.geo.stereographic=function(){return ur(Qc)}).raw=Qc,Er.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-ja]},(ta.geo.transverseMercator=function(){var n=kr(Er),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Er,ta.geom={},ta.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,u=kt(e),i=kt(r),o=n.length,a=[],c=[];for(t=0;o>t;t++)a.push([+u.call(this,n[t],t),+i.call(this,n[t],t),t]);for(a.sort(zr),t=0;o>t;t++)c.push([a[t][0],-a[t][1]]);var l=Cr(a),s=Cr(c),f=s[0]===l[0],h=s[s.length-1]===l[l.length-1],g=[];for(t=l.length-1;t>=0;--t)g.push(n[a[l[t]][2]]);for(t=+f;t<s.length-h;++t)g.push(n[a[s[t]][2]]);return g}var e=Ar,r=Nr;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ta.geom.polygon=function(n){return xa(n,nl),n};var nl=ta.geom.polygon.prototype=[];nl.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],u=0;++t<e;)n=r,r=this[t],u+=n[1]*r[0]-n[0]*r[1];return.5*u},nl.centroid=function(n){var t,e,r=-1,u=this.length,i=0,o=0,a=this[u-1];for(arguments.length||(n=-1/(6*this.area()));++r<u;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],i+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[i*n,o*n]},nl.clip=function(n){for(var t,e,r,u,i,o,a=Tr(n),c=-1,l=this.length-Tr(this),s=this[l-1];++c<l;){for(t=n.slice(),n.length=0,u=this[c],i=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],qr(o,s,u)?(qr(i,s,u)||n.push(Lr(i,o,s,u)),n.push(o)):qr(i,s,u)&&n.push(Lr(i,o,s,u)),i=o;a&&n.push(n[0]),s=u}return n};var tl,el,rl,ul,il,ol=[],al=[];Or.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Ir),t.length},Qr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},nu.prototype={insert:function(n,t){var e,r,u;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=uu(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(u=r.R,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.R&&(eu(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ru(this,r))):(u=r.L,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.L&&(ru(this,e),n=e,e=n.U),e.C=!1,r.C=!0,eu(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,u=n.U,i=n.L,o=n.R;if(e=i?o?uu(o):i:o,u?u.L===n?u.L=e:u.R=e:this._=e,i&&o?(r=e.C,e.C=n.C,e.L=i,i.U=e,e!==o?(u=e.U,e.U=n.U,n=e.R,u.L=n,e.R=o,o.U=e):(e.U=u,u=e,n=e.R)):(r=n.C,n=e),n&&(n.U=u),!r){if(n&&n.C)return n.C=!1,void 0;do{if(n===this._)break;if(n===u.L){if(t=u.R,t.C&&(t.C=!1,u.C=!0,eu(this,u),t=u.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ru(this,t),t=u.R),t.C=u.C,u.C=t.R.C=!1,eu(this,u),n=this._;break}}else if(t=u.L,t.C&&(t.C=!1,u.C=!0,ru(this,u),t=u.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,eu(this,t),t=u.L),t.C=u.C,u.C=t.L.C=!1,ru(this,u),n=this._;break}t.C=!0,n=u,u=u.U}while(!n.C);n&&(n.C=!1)}}},ta.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],u=a[0][1],i=a[1][0],o=a[1][1];return iu(e(n),a).cells.forEach(function(e,a){var c=e.edges,l=e.site,s=t[a]=c.length?c.map(function(n){var t=n.start();return[t.x,t.y]}):l.x>=r&&l.x<=i&&l.y>=u&&l.y<=o?[[r,o],[i,o],[i,u],[r,u]]:[];s.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(i(n,t)/Ta)*Ta,y:Math.round(o(n,t)/Ta)*Ta,i:t}})}var r=Ar,u=Nr,i=r,o=u,a=cl;return n?t(n):(t.links=function(n){return iu(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return iu(e(n)).cells.forEach(function(e,r){for(var u,i,o=e.site,a=e.edges.sort(Ir),c=-1,l=a.length,s=a[l-1].edge,f=s.l===o?s.r:s.l;++c<l;)u=s,i=f,s=a[c].edge,f=s.l===o?s.r:s.l,r<i.i&&r<f.i&&au(o,i,f)<0&&t.push([n[r],n[i.i],n[f.i]])}),t},t.x=function(n){return arguments.length?(i=kt(r=n),t):r},t.y=function(n){return arguments.length?(o=kt(u=n),t):u},t.clipExtent=function(n){return arguments.length?(a=null==n?cl:n,t):a===cl?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===cl?null:a&&a[1]},t)};var cl=[[-1e6,-1e6],[1e6,1e6]];ta.geom.delaunay=function(n){return ta.geom.voronoi().triangles(n)},ta.geom.quadtree=function(n,t,e,r,u){function i(n){function i(n,t,e,r,u,i,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var c=n.x,s=n.y;if(null!=c)if(va(c-e)+va(s-r)<.01)l(n,t,e,r,u,i,o,a);else{var f=n.point;n.x=n.y=n.point=null,l(n,f,c,s,u,i,o,a),l(n,t,e,r,u,i,o,a)}else n.x=e,n.y=r,n.point=t}else l(n,t,e,r,u,i,o,a)}function l(n,t,e,r,u,o,a,c){var l=.5*(u+a),s=.5*(o+c),f=e>=l,h=r>=s,g=h<<1|f;n.leaf=!1,n=n.nodes[g]||(n.nodes[g]=su()),f?u=l:a=l,h?o=s:c=s,i(n,t,e,r,u,o,a,c)}var s,f,h,g,p,v,d,m,y,M=kt(a),x=kt(c);if(null!=t)v=t,d=e,m=r,y=u;else if(m=y=-(v=d=1/0),f=[],h=[],p=n.length,o)for(g=0;p>g;++g)s=n[g],s.x<v&&(v=s.x),s.y<d&&(d=s.y),s.x>m&&(m=s.x),s.y>y&&(y=s.y),f.push(s.x),h.push(s.y);else for(g=0;p>g;++g){var b=+M(s=n[g],g),_=+x(s,g);v>b&&(v=b),d>_&&(d=_),b>m&&(m=b),_>y&&(y=_),f.push(b),h.push(_)}var w=m-v,S=y-d;w>S?y=d+w:m=v+S;var k=su();if(k.add=function(n){i(k,n,+M(n,++g),+x(n,g),v,d,m,y)},k.visit=function(n){fu(n,k,v,d,m,y)},k.find=function(n){return hu(k,n[0],n[1],v,d,m,y)},g=-1,null==t){for(;++g<p;)i(k,n[g],f[g],h[g],v,d,m,y);--g}else n.forEach(k.add);return f=h=n=s=null,k}var o,a=Ar,c=Nr;return(o=arguments.length)?(a=cu,c=lu,3===o&&(u=e,r=t,e=t=0),i(n)):(i.x=function(n){return arguments.length?(a=n,i):a},i.y=function(n){return arguments.length?(c=n,i):c},i.extent=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],u=+n[1][1]),i):null==t?null:[[t,e],[r,u]]},i.size=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=e=0,r=+n[0],u=+n[1]),i):null==t?null:[r-t,u-e]},i)},ta.interpolateRgb=gu,ta.interpolateObject=pu,ta.interpolateNumber=vu,ta.interpolateString=du;var ll=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,sl=new RegExp(ll.source,"g");ta.interpolate=mu,ta.interpolators=[function(n,t){var e=typeof t;return("string"===e?tc.has(t)||/^(#|rgb\(|hsl\()/.test(t)?gu:du:t instanceof it?gu:Array.isArray(t)?yu:"object"===e&&isNaN(t)?pu:vu)(n,t)}],ta.interpolateArray=yu;var fl=function(){return Et},hl=ta.map({linear:fl,poly:ku,quad:function(){return _u},cubic:function(){return wu},sin:function(){return Eu},exp:function(){return Au},circle:function(){return Nu},elastic:Cu,back:zu,bounce:function(){return qu}}),gl=ta.map({"in":Et,out:xu,"in-out":bu,"out-in":function(n){return bu(xu(n))}});ta.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=hl.get(e)||fl,r=gl.get(r)||Et,Mu(r(e.apply(null,ea.call(arguments,1))))},ta.interpolateHcl=Lu,ta.interpolateHsl=Tu,ta.interpolateLab=Ru,ta.interpolateRound=Du,ta.transform=function(n){var t=ua.createElementNS(ta.ns.prefix.svg,"g");return(ta.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new Pu(e?e.matrix:pl)})(n)},Pu.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var pl={a:1,b:0,c:0,d:1,e:0,f:0};ta.interpolateTransform=Hu,ta.layout={},ta.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Iu(n[e]));return t}},ta.layout.chord=function(){function n(){var n,l,f,h,g,p={},v=[],d=ta.range(i),m=[];for(e=[],r=[],n=0,h=-1;++h<i;){for(l=0,g=-1;++g<i;)l+=u[h][g];v.push(l),m.push(ta.range(i)),n+=l}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&m.forEach(function(n,t){n.sort(function(n,e){return a(u[t][n],u[t][e])})}),n=(Pa-s*i)/n,l=0,h=-1;++h<i;){for(f=l,g=-1;++g<i;){var y=d[h],M=m[y][g],x=u[y][M],b=l,_=l+=x*n;p[y+"-"+M]={index:y,subindex:M,startAngle:b,endAngle:_,value:x}}r[y]={index:y,startAngle:f,endAngle:l,value:(l-f)/n},l+=s}for(h=-1;++h<i;)for(g=h-1;++g<i;){var w=p[h+"-"+g],S=p[g+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}c&&t()}function t(){e.sort(function(n,t){return c((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,u,i,o,a,c,l={},s=0;return l.matrix=function(n){return arguments.length?(i=(u=n)&&u.length,e=r=null,l):u},l.padding=function(n){return arguments.length?(s=n,e=r=null,l):s},l.sortGroups=function(n){return arguments.length?(o=n,e=r=null,l):o},l.sortSubgroups=function(n){return arguments.length?(a=n,e=null,l):a},l.sortChords=function(n){return arguments.length?(c=n,e&&t(),l):c},l.chords=function(){return e||n(),e},l.groups=function(){return r||n(),r},l},ta.layout.force=function(){function n(n){return function(t,e,r,u){if(t.point!==n){var i=t.cx-n.x,o=t.cy-n.y,a=u-e,c=i*i+o*o;if(c>a*a/d){if(p>c){var l=t.charge/c;n.px-=i*l,n.py-=o*l}return!0}if(t.point&&c&&p>c){var l=t.pointCharge/c;n.px-=i*l,n.py-=o*l}}return!t.charge}}function t(n){n.px=ta.event.x,n.py=ta.event.y,a.resume()}var e,r,u,i,o,a={},c=ta.dispatch("start","tick","end"),l=[1,1],s=.9,f=vl,h=dl,g=-30,p=ml,v=.1,d=.64,m=[],y=[];return a.tick=function(){if((r*=.99)<.005)return c.end({type:"end",alpha:r=0}),!0;var t,e,a,f,h,p,d,M,x,b=m.length,_=y.length;for(e=0;_>e;++e)a=y[e],f=a.source,h=a.target,M=h.x-f.x,x=h.y-f.y,(p=M*M+x*x)&&(p=r*i[e]*((p=Math.sqrt(p))-u[e])/p,M*=p,x*=p,h.x-=M*(d=f.weight/(h.weight+f.weight)),h.y-=x*d,f.x+=M*(d=1-d),f.y+=x*d);if((d=r*v)&&(M=l[0]/2,x=l[1]/2,e=-1,d))for(;++e<b;)a=m[e],a.x+=(M-a.x)*d,a.y+=(x-a.y)*d;if(g)for(Ju(t=ta.geom.quadtree(m),r,o),e=-1;++e<b;)(a=m[e]).fixed||t.visit(n(a));for(e=-1;++e<b;)a=m[e],a.fixed?(a.x=a.px,a.y=a.py):(a.x-=(a.px-(a.px=a.x))*s,a.y-=(a.py-(a.py=a.y))*s);c.tick({type:"tick",alpha:r})},a.nodes=function(n){return arguments.length?(m=n,a):m},a.links=function(n){return arguments.length?(y=n,a):y},a.size=function(n){return arguments.length?(l=n,a):l},a.linkDistance=function(n){return arguments.length?(f="function"==typeof n?n:+n,a):f},a.distance=a.linkDistance,a.linkStrength=function(n){return arguments.length?(h="function"==typeof n?n:+n,a):h},a.friction=function(n){return arguments.length?(s=+n,a):s},a.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,a):g},a.chargeDistance=function(n){return arguments.length?(p=n*n,a):Math.sqrt(p)},a.gravity=function(n){return arguments.length?(v=+n,a):v},a.theta=function(n){return arguments.length?(d=n*n,a):Math.sqrt(d)},a.alpha=function(n){return arguments.length?(n=+n,r?r=n>0?n:0:n>0&&(c.start({type:"start",alpha:r=n}),ta.timer(a.tick)),a):r},a.start=function(){function n(n,r){if(!e){for(e=new Array(c),a=0;c>a;++a)e[a]=[];for(a=0;l>a;++a){var u=y[a];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var i,o=e[t],a=-1,l=o.length;++a<l;)if(!isNaN(i=o[a][n]))return i;return Math.random()*r}var t,e,r,c=m.length,s=y.length,p=l[0],v=l[1];for(t=0;c>t;++t)(r=m[t]).index=t,r.weight=0;for(t=0;s>t;++t)r=y[t],"number"==typeof r.source&&(r.source=m[r.source]),"number"==typeof r.target&&(r.target=m[r.target]),++r.source.weight,++r.target.weight;for(t=0;c>t;++t)r=m[t],isNaN(r.x)&&(r.x=n("x",p)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof f)for(t=0;s>t;++t)u[t]=+f.call(this,y[t],t);else for(t=0;s>t;++t)u[t]=f;if(i=[],"function"==typeof h)for(t=0;s>t;++t)i[t]=+h.call(this,y[t],t);else for(t=0;s>t;++t)i[t]=h;if(o=[],"function"==typeof g)for(t=0;c>t;++t)o[t]=+g.call(this,m[t],t);else for(t=0;c>t;++t)o[t]=g;return a.resume()},a.resume=function(){return a.alpha(.1)},a.stop=function(){return a.alpha(0)},a.drag=function(){return e||(e=ta.behavior.drag().origin(Et).on("dragstart.force",Xu).on("drag.force",t).on("dragend.force",$u)),arguments.length?(this.on("mouseover.force",Bu).on("mouseout.force",Wu).call(e),void 0):e},ta.rebind(a,c,"on")};var vl=20,dl=1,ml=1/0;ta.layout.hierarchy=function(){function n(u){var i,o=[u],a=[];for(u.depth=0;null!=(i=o.pop());)if(a.push(i),(l=e.call(n,i,i.depth))&&(c=l.length)){for(var c,l,s;--c>=0;)o.push(s=l[c]),s.parent=i,s.depth=i.depth+1;r&&(i.value=0),i.children=l}else r&&(i.value=+r.call(n,i,i.depth)||0),delete i.children;return Qu(u,function(n){var e,u;t&&(e=n.children)&&e.sort(t),r&&(u=n.parent)&&(u.value+=n.value)}),a}var t=ei,e=ni,r=ti;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(Ku(t,function(n){n.children&&(n.value=0)}),Qu(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ta.layout.partition=function(){function n(t,e,r,u){var i=t.children;if(t.x=e,t.y=t.depth*u,t.dx=r,t.dy=u,i&&(o=i.length)){var o,a,c,l=-1;for(r=t.value?r/t.value:0;++l<o;)n(a=i[l],e,c=a.value*r,u),e+=c}}function t(n){var e=n.children,r=0;if(e&&(u=e.length))for(var u,i=-1;++i<u;)r=Math.max(r,t(e[i]));return 1+r}function e(e,i){var o=r.call(this,e,i);return n(o[0],0,u[0],u[1]/t(o[0])),o}var r=ta.layout.hierarchy(),u=[1,1];return e.size=function(n){return arguments.length?(u=n,e):u},Gu(e,r)},ta.layout.pie=function(){function n(o){var a,c=o.length,l=o.map(function(e,r){return+t.call(n,e,r)}),s=+("function"==typeof r?r.apply(this,arguments):r),f=("function"==typeof u?u.apply(this,arguments):u)-s,h=Math.min(Math.abs(f)/c,+("function"==typeof i?i.apply(this,arguments):i)),g=h*(0>f?-1:1),p=(f-c*g)/ta.sum(l),v=ta.range(c),d=[];return null!=e&&v.sort(e===yl?function(n,t){return l[t]-l[n]}:function(n,t){return e(o[n],o[t])}),v.forEach(function(n){d[n]={data:o[n],value:a=l[n],startAngle:s,endAngle:s+=a*p+g,padAngle:h}}),d}var t=Number,e=yl,r=0,u=Pa,i=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(u=t,n):u},n.padAngle=function(t){return arguments.length?(i=t,n):i},n};var yl={};ta.layout.stack=function(){function n(a,c){if(!(h=a.length))return a;var l=a.map(function(e,r){return t.call(n,e,r)}),s=l.map(function(t){return t.map(function(t,e){return[i.call(n,t,e),o.call(n,t,e)]})}),f=e.call(n,s,c);l=ta.permute(l,f),s=ta.permute(s,f);var h,g,p,v,d=r.call(n,s,c),m=l[0].length;for(p=0;m>p;++p)for(u.call(n,l[0][p],v=d[p],s[0][p][1]),g=1;h>g;++g)u.call(n,l[g][p],v+=s[g-1][p][1],s[g][p][1]);return a}var t=Et,e=ai,r=ci,u=oi,i=ui,o=ii;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:Ml.get(t)||ai,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:xl.get(t)||ci,n):r},n.x=function(t){return arguments.length?(i=t,n):i},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(u=t,n):u},n};var Ml=ta.map({"inside-out":function(n){var t,e,r=n.length,u=n.map(li),i=n.map(si),o=ta.range(r).sort(function(n,t){return u[n]-u[t]}),a=0,c=0,l=[],s=[];for(t=0;r>t;++t)e=o[t],c>a?(a+=i[e],l.push(e)):(c+=i[e],s.push(e));return s.reverse().concat(l)},reverse:function(n){return ta.range(n.length).reverse()},"default":ai}),xl=ta.map({silhouette:function(n){var t,e,r,u=n.length,i=n[0].length,o=[],a=0,c=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;i>e;++e)c[e]=(a-o[e])/2;return c},wiggle:function(n){var t,e,r,u,i,o,a,c,l,s=n.length,f=n[0],h=f.length,g=[];for(g[0]=c=l=0,e=1;h>e;++e){for(t=0,u=0;s>t;++t)u+=n[t][e][1];for(t=0,i=0,a=f[e][0]-f[e-1][0];s>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;i+=o*n[t][e][1]}g[e]=c-=u?i/u*a:0,l>c&&(l=c)}for(e=0;h>e;++e)g[e]-=l;return g},expand:function(n){var t,e,r,u=n.length,i=n[0].length,o=1/u,a=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];if(r)for(t=0;u>t;t++)n[t][e][1]/=r;else for(t=0;u>t;t++)n[t][e][1]=o}for(e=0;i>e;++e)a[e]=0;return a},zero:ci});ta.layout.histogram=function(){function n(n,i){for(var o,a,c=[],l=n.map(e,this),s=r.call(this,l,i),f=u.call(this,s,l,i),i=-1,h=l.length,g=f.length-1,p=t?1:1/h;++i<g;)o=c[i]=[],o.dx=f[i+1]-(o.x=f[i]),o.y=0;if(g>0)for(i=-1;++i<h;)a=l[i],a>=s[0]&&a<=s[1]&&(o=c[ta.bisect(f,a,1,g)-1],o.y+=p,o.push(n[i]));return c}var t=!0,e=Number,r=pi,u=hi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=kt(t),n):r},n.bins=function(t){return arguments.length?(u="number"==typeof t?function(n){return gi(n,t)}:kt(t),n):u},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ta.layout.pack=function(){function n(n,i){var o=e.call(this,n,i),a=o[0],c=u[0],l=u[1],s=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,Qu(a,function(n){n.r=+s(n.value)}),Qu(a,Mi),r){var f=r*(t?1:Math.max(2*a.r/c,2*a.r/l))/2;Qu(a,function(n){n.r+=f}),Qu(a,Mi),Qu(a,function(n){n.r-=f})}return _i(a,c/2,l/2,t?1:1/Math.max(2*a.r/c,2*a.r/l)),o}var t,e=ta.layout.hierarchy().sort(vi),r=0,u=[1,1];return n.size=function(t){return arguments.length?(u=t,n):u},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},Gu(n,e)},ta.layout.tree=function(){function n(n,u){var s=o.call(this,n,u),f=s[0],h=t(f);if(Qu(h,e),h.parent.m=-h.z,Ku(h,r),l)Ku(f,i);else{var g=f,p=f,v=f;Ku(f,function(n){n.x<g.x&&(g=n),n.x>p.x&&(p=n),n.depth>v.depth&&(v=n)});var d=a(g,p)/2-g.x,m=c[0]/(p.x+a(p,g)/2+d),y=c[1]/(v.depth||1);Ku(f,function(n){n.x=(n.x+d)*m,n.y=n.depth*y})}return s}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var u,i=t.children,o=0,a=i.length;a>o;++o)r.push((i[o]=u={_:i[o],parent:t,children:(u=i[o].children)&&u.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=u);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Ni(n);var i=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-i):n.z=i}else r&&(n.z=r.z+a(n._,r._));n.parent.A=u(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function u(n,t,e){if(t){for(var r,u=n,i=n,o=t,c=u.parent.children[0],l=u.m,s=i.m,f=o.m,h=c.m;o=Ei(o),u=ki(u),o&&u;)c=ki(c),i=Ei(i),i.a=n,r=o.z+f-u.z-l+a(o._,u._),r>0&&(Ai(Ci(o,n,e),n,r),l+=r,s+=r),f+=o.m,l+=u.m,h+=c.m,s+=i.m;o&&!Ei(i)&&(i.t=o,i.m+=f-s),u&&!ki(c)&&(c.t=u,c.m+=l-h,e=n)}return e}function i(n){n.x*=c[0],n.y=n.depth*c[1]}var o=ta.layout.hierarchy().sort(null).value(null),a=Si,c=[1,1],l=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(l=null==(c=t)?i:null,n):l?null:c},n.nodeSize=function(t){return arguments.length?(l=null==(c=t)?null:i,n):l?c:null},Gu(n,o)},ta.layout.cluster=function(){function n(n,i){var o,a=t.call(this,n,i),c=a[0],l=0;Qu(c,function(n){var t=n.children;t&&t.length?(n.x=qi(t),n.y=zi(t)):(n.x=o?l+=e(n,o):0,n.y=0,o=n)});var s=Li(c),f=Ti(c),h=s.x-e(s,f)/2,g=f.x+e(f,s)/2;return Qu(c,u?function(n){n.x=(n.x-c.x)*r[0],n.y=(c.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(g-h)*r[0],n.y=(1-(c.y?n.y/c.y:1))*r[1]}),a}var t=ta.layout.hierarchy().sort(null).value(null),e=Si,r=[1,1],u=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(u=null==(r=t),n):u?null:r},n.nodeSize=function(t){return arguments.length?(u=null!=(r=t),n):u?r:null},Gu(n,t)},ta.layout.treemap=function(){function n(n,t){for(var e,r,u=-1,i=n.length;++u<i;)r=(e=n[u]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var i=e.children;if(i&&i.length){var o,a,c,l=f(e),s=[],h=i.slice(),p=1/0,v="slice"===g?l.dx:"dice"===g?l.dy:"slice-dice"===g?1&e.depth?l.dy:l.dx:Math.min(l.dx,l.dy);for(n(h,l.dx*l.dy/e.value),s.area=0;(c=h.length)>0;)s.push(o=h[c-1]),s.area+=o.area,"squarify"!==g||(a=r(s,v))<=p?(h.pop(),p=a):(s.area-=s.pop().area,u(s,v,l,!1),v=Math.min(l.dx,l.dy),s.length=s.area=0,p=1/0);s.length&&(u(s,v,l,!0),s.length=s.area=0),i.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var i,o=f(t),a=r.slice(),c=[];for(n(a,o.dx*o.dy/t.value),c.area=0;i=a.pop();)c.push(i),c.area+=i.area,null!=i.z&&(u(c,i.z?o.dx:o.dy,o,!a.length),c.length=c.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,u=0,i=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(i>e&&(i=e),e>u&&(u=e));return r*=r,t*=t,r?Math.max(t*u*p/r,r/(t*i*p)):1/0}function u(n,t,e,r){var u,i=-1,o=n.length,a=e.x,l=e.y,s=t?c(n.area/t):0;if(t==e.dx){for((r||s>e.dy)&&(s=e.dy);++i<o;)u=n[i],u.x=a,u.y=l,u.dy=s,a+=u.dx=Math.min(e.x+e.dx-a,s?c(u.area/s):0);u.z=!0,u.dx+=e.x+e.dx-a,e.y+=s,e.dy-=s}else{for((r||s>e.dx)&&(s=e.dx);++i<o;)u=n[i],u.x=a,u.y=l,u.dx=s,l+=u.dy=Math.min(e.y+e.dy-l,s?c(u.area/s):0);u.z=!1,u.dy+=e.y+e.dy-l,e.x+=s,e.dx-=s}}function i(r){var u=o||a(r),i=u[0];return i.x=0,i.y=0,i.dx=l[0],i.dy=l[1],o&&a.revalue(i),n([i],i.dx*i.dy/i.value),(o?e:t)(i),h&&(o=u),u}var o,a=ta.layout.hierarchy(),c=Math.round,l=[1,1],s=null,f=Ri,h=!1,g="squarify",p=.5*(1+Math.sqrt(5));return i.size=function(n){return arguments.length?(l=n,i):l},i.padding=function(n){function t(t){var e=n.call(i,t,t.depth);return null==e?Ri(t):Di(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Di(t,n)}if(!arguments.length)return s;var r;return f=null==(s=n)?Ri:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,i},i.round=function(n){return arguments.length?(c=n?Math.round:Number,i):c!=Number},i.sticky=function(n){return arguments.length?(h=n,o=null,i):h
  },i.ratio=function(n){return arguments.length?(p=n,i):p},i.mode=function(n){return arguments.length?(g=n+"",i):g},Gu(i,a)},ta.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,u;do e=2*Math.random()-1,r=2*Math.random()-1,u=e*e+r*r;while(!u||u>1);return n+t*e*Math.sqrt(-2*Math.log(u)/u)}},logNormal:function(){var n=ta.random.normal.apply(ta,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ta.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},ta.scale={};var bl={floor:Et,ceil:Et};ta.scale.linear=function(){return Yi([0,1],[0,1],mu,!1)};var _l={s:1,g:1,p:1,r:1,e:1};ta.scale.log=function(){return Ji(ta.scale.linear().domain([0,1]),10,!0,[1,10])};var wl=ta.format(".0e"),Sl={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ta.scale.pow=function(){return Gi(ta.scale.linear(),1,[0,1])},ta.scale.sqrt=function(){return ta.scale.pow().exponent(.5)},ta.scale.ordinal=function(){return Qi([],{t:"range",a:[[]]})},ta.scale.category10=function(){return ta.scale.ordinal().range(kl)},ta.scale.category20=function(){return ta.scale.ordinal().range(El)},ta.scale.category20b=function(){return ta.scale.ordinal().range(Al)},ta.scale.category20c=function(){return ta.scale.ordinal().range(Nl)};var kl=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(yt),El=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(yt),Al=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(yt),Nl=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(yt);ta.scale.quantile=function(){return no([],[])},ta.scale.quantize=function(){return to(0,1,[0,1])},ta.scale.threshold=function(){return eo([.5],[0,1])},ta.scale.identity=function(){return ro([0,1])},ta.svg={},ta.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),l=Math.max(0,+r.apply(this,arguments)),s=o.apply(this,arguments)-ja,f=a.apply(this,arguments)-ja,h=Math.abs(f-s),g=s>f?0:1;if(n>l&&(p=l,l=n,n=p),h>=Ua)return t(l,g)+(n?t(n,1-g):"")+"Z";var p,v,d,m,y,M,x,b,_,w,S,k,E=0,A=0,N=[];if((m=(+c.apply(this,arguments)||0)/2)&&(d=i===Cl?Math.sqrt(n*n+l*l):+i.apply(this,arguments),g||(A*=-1),l&&(A=nt(d/l*Math.sin(m))),n&&(E=nt(d/n*Math.sin(m)))),l){y=l*Math.cos(s+A),M=l*Math.sin(s+A),x=l*Math.cos(f-A),b=l*Math.sin(f-A);var C=Math.abs(f-s-2*A)<=Da?0:1;if(A&&so(y,M,x,b)===g^C){var z=(s+f)/2;y=l*Math.cos(z),M=l*Math.sin(z),x=b=null}}else y=M=0;if(n){_=n*Math.cos(f-E),w=n*Math.sin(f-E),S=n*Math.cos(s+E),k=n*Math.sin(s+E);var q=Math.abs(s-f+2*E)<=Da?0:1;if(E&&so(_,w,S,k)===1-g^q){var L=(s+f)/2;_=n*Math.cos(L),w=n*Math.sin(L),S=k=null}}else _=w=0;if((p=Math.min(Math.abs(l-n)/2,+u.apply(this,arguments)))>.001){v=l>n^g?0:1;var T=null==S?[_,w]:null==x?[y,M]:Lr([y,M],[S,k],[x,b],[_,w]),R=y-T[0],D=M-T[1],P=x-T[0],U=b-T[1],j=1/Math.sin(Math.acos((R*P+D*U)/(Math.sqrt(R*R+D*D)*Math.sqrt(P*P+U*U)))/2),F=Math.sqrt(T[0]*T[0]+T[1]*T[1]);if(null!=x){var H=Math.min(p,(l-F)/(j+1)),O=fo(null==S?[_,w]:[S,k],[y,M],l,H,g),Y=fo([x,b],[_,w],l,H,g);p===H?N.push("M",O[0],"A",H,",",H," 0 0,",v," ",O[1],"A",l,",",l," 0 ",1-g^so(O[1][0],O[1][1],Y[1][0],Y[1][1]),",",g," ",Y[1],"A",H,",",H," 0 0,",v," ",Y[0]):N.push("M",O[0],"A",H,",",H," 0 1,",v," ",Y[0])}else N.push("M",y,",",M);if(null!=S){var I=Math.min(p,(n-F)/(j-1)),Z=fo([y,M],[S,k],n,-I,g),V=fo([_,w],null==x?[y,M]:[x,b],n,-I,g);p===I?N.push("L",V[0],"A",I,",",I," 0 0,",v," ",V[1],"A",n,",",n," 0 ",g^so(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-g," ",Z[1],"A",I,",",I," 0 0,",v," ",Z[0]):N.push("L",V[0],"A",I,",",I," 0 0,",v," ",Z[0])}else N.push("L",_,",",w)}else N.push("M",y,",",M),null!=x&&N.push("A",l,",",l," 0 ",C,",",g," ",x,",",b),N.push("L",_,",",w),null!=S&&N.push("A",n,",",n," 0 ",q,",",1-g," ",S,",",k);return N.push("Z"),N.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=io,r=oo,u=uo,i=Cl,o=ao,a=co,c=lo;return n.innerRadius=function(t){return arguments.length?(e=kt(t),n):e},n.outerRadius=function(t){return arguments.length?(r=kt(t),n):r},n.cornerRadius=function(t){return arguments.length?(u=kt(t),n):u},n.padRadius=function(t){return arguments.length?(i=t==Cl?Cl:kt(t),n):i},n.startAngle=function(t){return arguments.length?(o=kt(t),n):o},n.endAngle=function(t){return arguments.length?(a=kt(t),n):a},n.padAngle=function(t){return arguments.length?(c=kt(t),n):c},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-ja;return[Math.cos(t)*n,Math.sin(t)*n]},n};var Cl="auto";ta.svg.line=function(){return ho(Et)};var zl=ta.map({linear:go,"linear-closed":po,step:vo,"step-before":mo,"step-after":yo,basis:So,"basis-open":ko,"basis-closed":Eo,bundle:Ao,cardinal:bo,"cardinal-open":Mo,"cardinal-closed":xo,monotone:To});zl.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var ql=[0,2/3,1/3,0],Ll=[0,1/3,2/3,0],Tl=[0,1/6,2/3,1/6];ta.svg.line.radial=function(){var n=ho(Ro);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},mo.reverse=yo,yo.reverse=mo,ta.svg.area=function(){return Do(Et)},ta.svg.area.radial=function(){var n=Do(Ro);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ta.svg.chord=function(){function n(n,a){var c=t(this,i,n,a),l=t(this,o,n,a);return"M"+c.p0+r(c.r,c.p1,c.a1-c.a0)+(e(c,l)?u(c.r,c.p1,c.r,c.p0):u(c.r,c.p1,l.r,l.p0)+r(l.r,l.p1,l.a1-l.a0)+u(l.r,l.p1,c.r,c.p0))+"Z"}function t(n,t,e,r){var u=t.call(n,e,r),i=a.call(n,u,r),o=c.call(n,u,r)-ja,s=l.call(n,u,r)-ja;return{r:i,a0:o,a1:s,p0:[i*Math.cos(o),i*Math.sin(o)],p1:[i*Math.cos(s),i*Math.sin(s)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Da)+",1 "+t}function u(n,t,e,r){return"Q 0,0 "+r}var i=mr,o=yr,a=Po,c=ao,l=co;return n.radius=function(t){return arguments.length?(a=kt(t),n):a},n.source=function(t){return arguments.length?(i=kt(t),n):i},n.target=function(t){return arguments.length?(o=kt(t),n):o},n.startAngle=function(t){return arguments.length?(c=kt(t),n):c},n.endAngle=function(t){return arguments.length?(l=kt(t),n):l},n},ta.svg.diagonal=function(){function n(n,u){var i=t.call(this,n,u),o=e.call(this,n,u),a=(i.y+o.y)/2,c=[i,{x:i.x,y:a},{x:o.x,y:a},o];return c=c.map(r),"M"+c[0]+"C"+c[1]+" "+c[2]+" "+c[3]}var t=mr,e=yr,r=Uo;return n.source=function(e){return arguments.length?(t=kt(e),n):t},n.target=function(t){return arguments.length?(e=kt(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ta.svg.diagonal.radial=function(){var n=ta.svg.diagonal(),t=Uo,e=n.projection;return n.projection=function(n){return arguments.length?e(jo(t=n)):t},n},ta.svg.symbol=function(){function n(n,r){return(Rl.get(t.call(this,n,r))||Oo)(e.call(this,n,r))}var t=Ho,e=Fo;return n.type=function(e){return arguments.length?(t=kt(e),n):t},n.size=function(t){return arguments.length?(e=kt(t),n):e},n};var Rl=ta.map({circle:Oo,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Pl)),e=t*Pl;return"M0,"+-t+"L"+e+",0"+" 0,"+t+" "+-e+",0"+"Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/Dl),e=t*Dl/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/Dl),e=t*Dl/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ta.svg.symbolTypes=Rl.keys();var Dl=Math.sqrt(3),Pl=Math.tan(30*Fa);ka.transition=function(n){for(var t,e,r=Ul||++Ol,u=Xo(n),i=[],o=jl||{time:Date.now(),ease:Su,delay:0,duration:250},a=-1,c=this.length;++a<c;){i.push(t=[]);for(var l=this[a],s=-1,f=l.length;++s<f;)(e=l[s])&&$o(e,s,u,r,o),t.push(e)}return Io(i,u,r)},ka.interrupt=function(n){return this.each(null==n?Fl:Yo(Xo(n)))};var Ul,jl,Fl=Yo(Xo()),Hl=[],Ol=0;Hl.call=ka.call,Hl.empty=ka.empty,Hl.node=ka.node,Hl.size=ka.size,ta.transition=function(n,t){return n&&n.transition?Ul?n.transition(t):n:Na.transition(n)},ta.transition.prototype=Hl,Hl.select=function(n){var t,e,r,u=this.id,i=this.namespace,o=[];n=k(n);for(var a=-1,c=this.length;++a<c;){o.push(t=[]);for(var l=this[a],s=-1,f=l.length;++s<f;)(r=l[s])&&(e=n.call(r,r.__data__,s,a))?("__data__"in r&&(e.__data__=r.__data__),$o(e,s,i,u,r[i][u]),t.push(e)):t.push(null)}return Io(o,i,u)},Hl.selectAll=function(n){var t,e,r,u,i,o=this.id,a=this.namespace,c=[];n=E(n);for(var l=-1,s=this.length;++l<s;)for(var f=this[l],h=-1,g=f.length;++h<g;)if(r=f[h]){i=r[a][o],e=n.call(r,r.__data__,h,l),c.push(t=[]);for(var p=-1,v=e.length;++p<v;)(u=e[p])&&$o(u,p,a,o,i),t.push(u)}return Io(c,a,o)},Hl.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=j(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]);for(var e=this[i],a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return Io(u,this.namespace,this.id)},Hl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):H(this,null==t?function(t){t[r][e].tween.remove(n)}:function(u){u[r][e].tween.set(n,t)})},Hl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function u(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function i(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?Hu:mu,a=ta.ns.qualify(n);return Zo(this,"attr."+n,t,a.local?i:u)},Hl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(u));return r&&function(n){this.setAttribute(u,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(u.space,u.local));return r&&function(n){this.setAttributeNS(u.space,u.local,r(n))}}var u=ta.ns.qualify(n);return this.tween("attr."+n,u.local?r:e)},Hl.style=function(n,t,e){function r(){this.style.removeProperty(n)}function u(t){return null==t?r:(t+="",function(){var r,u=oa.getComputedStyle(this,null).getPropertyValue(n);return u!==t&&(r=mu(u,t),function(t){this.style.setProperty(n,r(t),e)})})}var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(t="");for(e in n)this.style(e,n[e],t);return this}e=""}return Zo(this,"style."+n,t,u)},Hl.styleTween=function(n,t,e){function r(r,u){var i=t.call(this,r,u,oa.getComputedStyle(this,null).getPropertyValue(n));return i&&function(t){this.style.setProperty(n,i(t),e)}}return arguments.length<3&&(e=""),this.tween("style."+n,r)},Hl.text=function(n){return Zo(this,"text",n,Vo)},Hl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Hl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ta.ease.apply(ta,arguments)),H(this,function(r){r[e][t].ease=n}))},Hl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:H(this,"function"==typeof n?function(r,u,i){r[e][t].delay=+n.call(r,r.__data__,u,i)}:(n=+n,function(r){r[e][t].delay=n}))},Hl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:H(this,"function"==typeof n?function(r,u,i){r[e][t].duration=Math.max(1,n.call(r,r.__data__,u,i))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Hl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var u=jl,i=Ul;try{Ul=e,H(this,function(t,u,i){jl=t[r][e],n.call(t,t.__data__,u,i)})}finally{jl=u,Ul=i}}else H(this,function(u){var i=u[r][e];(i.event||(i.event=ta.dispatch("start","end","interrupt"))).on(n,t)});return this},Hl.transition=function(){for(var n,t,e,r,u=this.id,i=++Ol,o=this.namespace,a=[],c=0,l=this.length;l>c;c++){a.push(n=[]);for(var t=this[c],s=0,f=t.length;f>s;s++)(e=t[s])&&(r=e[o][u],$o(e,s,o,i,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Io(a,o,i)},ta.svg.axis=function(){function n(n){n.each(function(){var n,l=ta.select(this),s=this.__chart__||e,f=this.__chart__=e.copy(),h=null==c?f.ticks?f.ticks.apply(f,a):f.domain():c,g=null==t?f.tickFormat?f.tickFormat.apply(f,a):Et:t,p=l.selectAll(".tick").data(h,f),v=p.enter().insert("g",".domain").attr("class","tick").style("opacity",Ta),d=ta.transition(p.exit()).style("opacity",Ta).remove(),m=ta.transition(p.order()).style("opacity",1),y=Math.max(u,0)+o,M=Ui(f),x=l.selectAll(".domain").data([0]),b=(x.enter().append("path").attr("class","domain"),ta.transition(x));v.append("line"),v.append("text");var _,w,S,k,E=v.select("line"),A=m.select("line"),N=p.select("text").text(g),C=v.select("text"),z=m.select("text"),q="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=Bo,_="x",S="y",w="x2",k="y2",N.attr("dy",0>q?"0em":".71em").style("text-anchor","middle"),b.attr("d","M"+M[0]+","+q*i+"V0H"+M[1]+"V"+q*i)):(n=Wo,_="y",S="x",w="y2",k="x2",N.attr("dy",".32em").style("text-anchor",0>q?"end":"start"),b.attr("d","M"+q*i+","+M[0]+"H0V"+M[1]+"H"+q*i)),E.attr(k,q*u),C.attr(S,q*y),A.attr(w,0).attr(k,q*u),z.attr(_,0).attr(S,q*y),f.rangeBand){var L=f,T=L.rangeBand()/2;s=f=function(n){return L(n)+T}}else s.rangeBand?s=f:d.call(n,f,s);v.call(n,s,f),m.call(n,f,f)})}var t,e=ta.scale.linear(),r=Yl,u=6,i=6,o=3,a=[10],c=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Il?t+"":Yl,n):r},n.ticks=function(){return arguments.length?(a=arguments,n):a},n.tickValues=function(t){return arguments.length?(c=t,n):c},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(u=+t,i=+arguments[e-1],n):u},n.innerTickSize=function(t){return arguments.length?(u=+t,n):u},n.outerTickSize=function(t){return arguments.length?(i=+t,n):i},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Yl="bottom",Il={top:1,right:1,bottom:1,left:1};ta.svg.brush=function(){function n(i){i.each(function(){var i=ta.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=i.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),i.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=i.selectAll(".resize").data(p,Et);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return Zl[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var s,f=ta.transition(i),h=ta.transition(o);c&&(s=Ui(c),h.attr("x",s[0]).attr("width",s[1]-s[0]),e(f)),l&&(s=Ui(l),h.attr("y",s[0]).attr("height",s[1]-s[0]),r(f)),t(f)})}function t(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+s[+/e$/.test(n)]+","+f[+/^s/.test(n)]+")"})}function e(n){n.select(".extent").attr("x",s[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",s[1]-s[0])}function r(n){n.select(".extent").attr("y",f[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",f[1]-f[0])}function u(){function u(){32==ta.event.keyCode&&(N||(y=null,z[0]-=s[1],z[1]-=f[1],N=2),b())}function p(){32==ta.event.keyCode&&2==N&&(z[0]+=s[1],z[1]+=f[1],N=0,b())}function v(){var n=ta.mouse(x),u=!1;M&&(n[0]+=M[0],n[1]+=M[1]),N||(ta.event.altKey?(y||(y=[(s[0]+s[1])/2,(f[0]+f[1])/2]),z[0]=s[+(n[0]<y[0])],z[1]=f[+(n[1]<y[1])]):y=null),E&&d(n,c,0)&&(e(S),u=!0),A&&d(n,l,1)&&(r(S),u=!0),u&&(t(S),w({type:"brush",mode:N?"move":"resize"}))}function d(n,t,e){var r,u,a=Ui(t),c=a[0],l=a[1],p=z[e],v=e?f:s,d=v[1]-v[0];return N&&(c-=p,l-=d+p),r=(e?g:h)?Math.max(c,Math.min(l,n[e])):n[e],N?u=(r+=p)+d:(y&&(p=Math.max(c,Math.min(l,2*y[e]-r))),r>p?(u=r,r=p):u=p),v[0]!=r||v[1]!=u?(e?o=null:i=null,v[0]=r,v[1]=u,!0):void 0}function m(){v(),S.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ta.select("body").style("cursor",null),q.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),C(),w({type:"brushend"})}var y,M,x=this,_=ta.select(ta.event.target),w=a.of(x,arguments),S=ta.select(x),k=_.datum(),E=!/^(n|s)$/.test(k)&&c,A=!/^(e|w)$/.test(k)&&l,N=_.classed("extent"),C=X(),z=ta.mouse(x),q=ta.select(oa).on("keydown.brush",u).on("keyup.brush",p);if(ta.event.changedTouches?q.on("touchmove.brush",v).on("touchend.brush",m):q.on("mousemove.brush",v).on("mouseup.brush",m),S.interrupt().selectAll("*").interrupt(),N)z[0]=s[0]-z[0],z[1]=f[0]-z[1];else if(k){var L=+/w$/.test(k),T=+/^n/.test(k);M=[s[1-L]-z[0],f[1-T]-z[1]],z[0]=s[L],z[1]=f[T]}else ta.event.altKey&&(y=z.slice());S.style("pointer-events","none").selectAll(".resize").style("display",null),ta.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),v()}var i,o,a=w(n,"brushstart","brush","brushend"),c=null,l=null,s=[0,0],f=[0,0],h=!0,g=!0,p=Vl[0];return n.event=function(n){n.each(function(){var n=a.of(this,arguments),t={x:s,y:f,i:i,j:o},e=this.__chart__||t;this.__chart__=t,Ul?ta.select(this).transition().each("start.brush",function(){i=e.i,o=e.j,s=e.x,f=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=yu(s,t.x),r=yu(f,t.y);return i=o=null,function(u){s=t.x=e(u),f=t.y=r(u),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){i=t.i,o=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,p=Vl[!c<<1|!l],n):c},n.y=function(t){return arguments.length?(l=t,p=Vl[!c<<1|!l],n):l},n.clamp=function(t){return arguments.length?(c&&l?(h=!!t[0],g=!!t[1]):c?h=!!t:l&&(g=!!t),n):c&&l?[h,g]:c?h:l?g:null},n.extent=function(t){var e,r,u,a,h;return arguments.length?(c&&(e=t[0],r=t[1],l&&(e=e[0],r=r[0]),i=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(h=e,e=r,r=h),(e!=s[0]||r!=s[1])&&(s=[e,r])),l&&(u=t[0],a=t[1],c&&(u=u[1],a=a[1]),o=[u,a],l.invert&&(u=l(u),a=l(a)),u>a&&(h=u,u=a,a=h),(u!=f[0]||a!=f[1])&&(f=[u,a])),n):(c&&(i?(e=i[0],r=i[1]):(e=s[0],r=s[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(h=e,e=r,r=h))),l&&(o?(u=o[0],a=o[1]):(u=f[0],a=f[1],l.invert&&(u=l.invert(u),a=l.invert(a)),u>a&&(h=u,u=a,a=h))),c&&l?[[e,u],[r,a]]:c?[e,r]:l&&[u,a])},n.clear=function(){return n.empty()||(s=[0,0],f=[0,0],i=o=null),n},n.empty=function(){return!!c&&s[0]==s[1]||!!l&&f[0]==f[1]},ta.rebind(n,a,"on")};var Zl={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Vl=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Xl=fc.format=mc.timeFormat,$l=Xl.utc,Bl=$l("%Y-%m-%dT%H:%M:%S.%LZ");Xl.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?Jo:Bl,Jo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},Jo.toString=Bl.toString,fc.second=Ft(function(n){return new hc(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),fc.seconds=fc.second.range,fc.seconds.utc=fc.second.utc.range,fc.minute=Ft(function(n){return new hc(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),fc.minutes=fc.minute.range,fc.minutes.utc=fc.minute.utc.range,fc.hour=Ft(function(n){var t=n.getTimezoneOffset()/60;return new hc(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),fc.hours=fc.hour.range,fc.hours.utc=fc.hour.utc.range,fc.month=Ft(function(n){return n=fc.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),fc.months=fc.month.range,fc.months.utc=fc.month.utc.range;var Wl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Jl=[[fc.second,1],[fc.second,5],[fc.second,15],[fc.second,30],[fc.minute,1],[fc.minute,5],[fc.minute,15],[fc.minute,30],[fc.hour,1],[fc.hour,3],[fc.hour,6],[fc.hour,12],[fc.day,1],[fc.day,2],[fc.week,1],[fc.month,1],[fc.month,3],[fc.year,1]],Gl=Xl.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",Ne]]),Kl={range:function(n,t,e){return ta.range(Math.ceil(n/e)*e,+t,e).map(Ko)},floor:Et,ceil:Et};Jl.year=fc.year,fc.scale=function(){return Go(ta.scale.linear(),Jl,Gl)};var Ql=Jl.map(function(n){return[n[0].utc,n[1]]}),ns=$l.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",Ne]]);Ql.year=fc.year.utc,fc.scale.utc=function(){return Go(ta.scale.linear(),Ql,ns)},ta.text=At(function(n){return n.responseText}),ta.json=function(n,t){return Nt(n,"application/json",Qo,t)},ta.html=function(n,t){return Nt(n,"text/html",na,t)},ta.xml=At(function(n){return n.responseXML}),"function"==typeof define&&define.amd?define(ta):"object"==typeof module&&module.exports&&(module.exports=ta),this.d3=ta}();
  </script>
  <script>/* nvd3 version 1.8.6-dev (https://github.com/novus/nvd3) 2018-02-24 */
  (function(){
  
  // set up main nv object
  var nv = {};
  
  // the major global objects under the nv namespace
  nv.dev = false; //set false when in production
  nv.tooltip = nv.tooltip || {}; // For the tooltip system
  nv.utils = nv.utils || {}; // Utility subsystem
  nv.models = nv.models || {}; //stores all the possible models/components
  nv.charts = {}; //stores all the ready to use charts
  nv.logs = {}; //stores some statistics and potential error messages
  nv.dom = {}; //DOM manipulation functions
  
  // Node/CommonJS - require D3
  if (typeof(module) !== 'undefined' && typeof(exports) !== 'undefined' && typeof(d3) == 'undefined') {
      d3 = require('d3');
  }
  
  nv.dispatch = d3.dispatch('render_start', 'render_end');
  
  // Function bind polyfill
  // Needed ONLY for phantomJS as it's missing until version 2.0 which is unreleased as of this comment
  // https://github.com/ariya/phantomjs/issues/10522
  // http://kangax.github.io/compat-table/es5/#Function.prototype.bind
  // phantomJS is used for running the test suite
  if (!Function.prototype.bind) {
      Function.prototype.bind = function (oThis) {
          if (typeof this !== "function") {
              // closest thing possible to the ECMAScript 5 internal IsCallable function
              throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
          }
  
          var aArgs = Array.prototype.slice.call(arguments, 1),
              fToBind = this,
              fNOP = function () {},
              fBound = function () {
                  return fToBind.apply(this instanceof fNOP && oThis
                          ? this
                          : oThis,
                      aArgs.concat(Array.prototype.slice.call(arguments)));
              };
  
          fNOP.prototype = this.prototype;
          fBound.prototype = new fNOP();
          return fBound;
      };
  }
  
  //  Development render timers - disabled if dev = false
  if (nv.dev) {
      nv.dispatch.on('render_start', function(e) {
          nv.logs.startTime = +new Date();
      });
  
      nv.dispatch.on('render_end', function(e) {
          nv.logs.endTime = +new Date();
          nv.logs.totalTime = nv.logs.endTime - nv.logs.startTime;
          nv.log('total', nv.logs.totalTime); // used for development, to keep track of graph generation times
      });
  }
  
  // Logs all arguments, and returns the last so you can test things in place
  // Note: in IE8 console.log is an object not a function, and if modernizr is used
  // then calling Function.prototype.bind with with anything other than a function
  // causes a TypeError to be thrown.
  nv.log = function() {
      if (nv.dev && window.console && console.log && console.log.apply)
          console.log.apply(console, arguments);
      else if (nv.dev && window.console && typeof console.log == "function" && Function.prototype.bind) {
          var log = Function.prototype.bind.call(console.log, console);
          log.apply(console, arguments);
      }
      return arguments[arguments.length - 1];
  };
  
  // print console warning, should be used by deprecated functions
  nv.deprecated = function(name, info) {
      if (console && console.warn) {
          console.warn('nvd3 warning: `' + name + '` has been deprecated. ', info || '');
      }
  };
  
  // The nv.render function is used to queue up chart rendering
  // in non-blocking async functions.
  // When all queued charts are done rendering, nv.dispatch.render_end is invoked.
  nv.render = function render(step) {
      // number of graphs to generate in each timeout loop
      step = step || 1;
  
      nv.render.active = true;
      nv.dispatch.render_start();
  
      var renderLoop = function() {
          var chart, graph;
  
          for (var i = 0; i < step && (graph = nv.render.queue[i]); i++) {
              chart = graph.generate();
              if (typeof graph.callback == typeof(Function)) graph.callback(chart);
          }
  
          nv.render.queue.splice(0, i);
  
          if (nv.render.queue.length) {
              setTimeout(renderLoop);
          }
          else {
              nv.dispatch.render_end();
              nv.render.active = false;
          }
      };
  
      setTimeout(renderLoop);
  };
  
  nv.render.active = false;
  nv.render.queue = [];
  
  /*
  Adds a chart to the async rendering queue. This method can take arguments in two forms:
  nv.addGraph({
      generate: <Function>
      callback: <Function>
  })
  
  or
  
  nv.addGraph(<generate Function>, <callback Function>)
  
  The generate function should contain code that creates the NVD3 model, sets options
  on it, adds data to an SVG element, and invokes the chart model. The generate function
  should return the chart model.  See examples/lineChart.html for a usage example.
  
  The callback function is optional, and it is called when the generate function completes.
  */
  nv.addGraph = function(obj) {
      if (typeof arguments[0] === typeof(Function)) {
          obj = {generate: arguments[0], callback: arguments[1]};
      }
  
      nv.render.queue.push(obj);
  
      if (!nv.render.active) {
          nv.render();
      }
  };
  
  // Node/CommonJS exports
  if (typeof(module) !== 'undefined' && typeof(exports) !== 'undefined') {
    module.exports = nv;
  }
  
  if (typeof(window) !== 'undefined') {
    window.nv = nv;
  }
  /* Facade for queueing DOM write operations
   * with Fastdom (https://github.com/wilsonpage/fastdom)
   * if available.
   * This could easily be extended to support alternate
   * implementations in the future.
   */
  nv.dom.write = function(callback) {
    if (window.fastdom !== undefined) {
      return fastdom.mutate(callback);
    }
    return callback();
  };
  
  /* Facade for queueing DOM read operations
   * with Fastdom (https://github.com/wilsonpage/fastdom)
   * if available.
   * This could easily be extended to support alternate
   * implementations in the future.
   */
  nv.dom.read = function(callback) {
    if (window.fastdom !== undefined) {
      return fastdom.measure(callback);
    }
    return callback();
  };
  /* Utility class to handle creation of an interactive layer.
   This places a rectangle on top of the chart. When you mouse move over it, it sends a dispatch
   containing the X-coordinate. It can also render a vertical line where the mouse is located.
  
   dispatch.elementMousemove is the important event to latch onto.  It is fired whenever the mouse moves over
   the rectangle. The dispatch is given one object which contains the mouseX/Y location.
   It also has 'pointXValue', which is the conversion of mouseX to the x-axis scale.
   */
  nv.interactiveGuideline = function() {
      "use strict";
  
      var margin = { left: 0, top: 0 } //Pass the chart's top and left magins. Used to calculate the mouseX/Y.
          ,   width = null
          ,   height = null
          ,   xScale = d3.scale.linear()
          ,   dispatch = d3.dispatch('elementMousemove', 'elementMouseout', 'elementClick', 'elementDblclick', 'elementMouseDown', 'elementMouseUp')
          ,   showGuideLine = true
          ,   svgContainer = null // Must pass the chart's svg, we'll use its mousemove event.
          ,   tooltip = nv.models.tooltip()
          ,   isMSIE =  window.ActiveXObject// Checkt if IE by looking for activeX. (excludes IE11)
      ;
  
      tooltip
          .duration(0)
          .hideDelay(0)
          .hidden(false);
  
      function layer(selection) {
          selection.each(function(data) {
              var container = d3.select(this);
              var availableWidth = (width || 960), availableHeight = (height || 400);
              var wrap = container.selectAll("g.nv-wrap.nv-interactiveLineLayer")
                  .data([data]);
              var wrapEnter = wrap.enter()
                  .append("g").attr("class", " nv-wrap nv-interactiveLineLayer");
              wrapEnter.append("g").attr("class","nv-interactiveGuideLine");
  
              if (!svgContainer) {
                  return;
              }
  
              function mouseHandler() {
                  var mouseX = d3.event.clientX - this.getBoundingClientRect().left;
                  var mouseY = d3.event.clientY - this.getBoundingClientRect().top;
  
                  var subtractMargin = true;
                  var mouseOutAnyReason = false;
                  if (isMSIE) {
                      /*
                       D3.js (or maybe SVG.getScreenCTM) has a nasty bug in Internet Explorer 10.
                       d3.mouse() returns incorrect X,Y mouse coordinates when mouse moving
                       over a rect in IE 10.
                       However, d3.event.offsetX/Y also returns the mouse coordinates
                       relative to the triggering <rect>. So we use offsetX/Y on IE.
                       */
                      mouseX = d3.event.offsetX;
                      mouseY = d3.event.offsetY;
  
                      /*
                       On IE, if you attach a mouse event listener to the <svg> container,
                       it will actually trigger it for all the child elements (like <path>, <circle>, etc).
                       When this happens on IE, the offsetX/Y is set to where ever the child element
                       is located.
                       As a result, we do NOT need to subtract margins to figure out the mouse X/Y
                       position under this scenario. Removing the line below *will* cause
                       the interactive layer to not work right on IE.
                       */
                      if(d3.event.target.tagName !== "svg") {
                          subtractMargin = false;
                      }
  
                      if (d3.event.target.className.baseVal.match("nv-legend")) {
                          mouseOutAnyReason = true;
                      }
  
                  }
  
                  if(subtractMargin) {
                      mouseX -= margin.left;
                      mouseY -= margin.top;
                  }
  
                  /* If mouseX/Y is outside of the chart's bounds,
                   trigger a mouseOut event.
                   */
                  if (d3.event.type === 'mouseout'
                      || mouseX < 0 || mouseY < 0
                      || mouseX > availableWidth || mouseY > availableHeight
                      || (d3.event.relatedTarget && d3.event.relatedTarget.ownerSVGElement === undefined)
                      || mouseOutAnyReason
                      ) {
  
                      if (isMSIE) {
                          if (d3.event.relatedTarget
                              && d3.event.relatedTarget.ownerSVGElement === undefined
                              && (d3.event.relatedTarget.className === undefined
                                  || d3.event.relatedTarget.className.match(tooltip.nvPointerEventsClass))) {
  
                              return;
                          }
                      }
                      dispatch.elementMouseout({
                          mouseX: mouseX,
                          mouseY: mouseY
                      });
                      layer.renderGuideLine(null); //hide the guideline
                      tooltip.hidden(true);
                      return;
                  } else {
                      tooltip.hidden(false);
                  }
  
  
                  var scaleIsOrdinal = typeof xScale.rangeBands === 'function';
                  var pointXValue = undefined;
  
                  // Ordinal scale has no invert method
                  if (scaleIsOrdinal) {
                      var elementIndex = d3.bisect(xScale.range(), mouseX) - 1;
                      // Check if mouseX is in the range band
                      if (xScale.range()[elementIndex] + xScale.rangeBand() >= mouseX) {
                          pointXValue = xScale.domain()[d3.bisect(xScale.range(), mouseX) - 1];
                      }
                      else {
                          dispatch.elementMouseout({
                              mouseX: mouseX,
                              mouseY: mouseY
                          });
                          layer.renderGuideLine(null); //hide the guideline
                          tooltip.hidden(true);
                          return;
                      }
                  }
                  else {
                      pointXValue = xScale.invert(mouseX);
                  }
  
                  dispatch.elementMousemove({
                      mouseX: mouseX,
                      mouseY: mouseY,
                      pointXValue: pointXValue
                  });
  
                  //If user double clicks the layer, fire a elementDblclick
                  if (d3.event.type === "dblclick") {
                      dispatch.elementDblclick({
                          mouseX: mouseX,
                          mouseY: mouseY,
                          pointXValue: pointXValue
                      });
                  }
  
                  // if user single clicks the layer, fire elementClick
                  if (d3.event.type === 'click') {
                      dispatch.elementClick({
                          mouseX: mouseX,
                          mouseY: mouseY,
                          pointXValue: pointXValue
                      });
                  }
  
                  // if user presses mouse down the layer, fire elementMouseDown
                  if (d3.event.type === 'mousedown') {
                    dispatch.elementMouseDown({
                      mouseX: mouseX,
                      mouseY: mouseY,
                      pointXValue: pointXValue
                    });
                  }
  
                  // if user presses mouse down the layer, fire elementMouseUp
                  if (d3.event.type === 'mouseup') {
                    dispatch.elementMouseUp({
                      mouseX: mouseX,
                      mouseY: mouseY,
                      pointXValue: pointXValue
                    });
                  }
              }
  
              svgContainer
                  .on("touchmove",mouseHandler)
                  .on("mousemove",mouseHandler, true)
                  .on("mouseout" ,mouseHandler,true)
                  .on("mousedown" ,mouseHandler,true)
                  .on("mouseup" ,mouseHandler,true)
                  .on("dblclick" ,mouseHandler)
                  .on("click", mouseHandler)
              ;
  
              layer.guideLine = null;
              //Draws a vertical guideline at the given X postion.
              layer.renderGuideLine = function(x) {
                  if (!showGuideLine) return;
                  if (layer.guideLine && layer.guideLine.attr("x1") === x) return;
                  nv.dom.write(function() {
                      var line = wrap.select(".nv-interactiveGuideLine")
                          .selectAll("line")
                          .data((x != null) ? [nv.utils.NaNtoZero(x)] : [], String);
                      line.enter()
                          .append("line")
                          .attr("class", "nv-guideline")
                          .attr("x1", function(d) { return d;})
                          .attr("x2", function(d) { return d;})
                          .attr("y1", availableHeight)
                          .attr("y2",0);
                      line.exit().remove();
                  });
              }
          });
      }
  
      layer.dispatch = dispatch;
      layer.tooltip = tooltip;
  
      layer.margin = function(_) {
          if (!arguments.length) return margin;
          margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
          margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
          return layer;
      };
  
      layer.width = function(_) {
          if (!arguments.length) return width;
          width = _;
          return layer;
      };
  
      layer.height = function(_) {
          if (!arguments.length) return height;
          height = _;
          return layer;
      };
  
      layer.xScale = function(_) {
          if (!arguments.length) return xScale;
          xScale = _;
          return layer;
      };
  
      layer.showGuideLine = function(_) {
          if (!arguments.length) return showGuideLine;
          showGuideLine = _;
          return layer;
      };
  
      layer.svgContainer = function(_) {
          if (!arguments.length) return svgContainer;
          svgContainer = _;
          return layer;
      };
  
      return layer;
  };
  
  /* Utility class that uses d3.bisect to find the index in a given array, where a search value can be inserted.
   This is different from normal bisectLeft; this function finds the nearest index to insert the search value.
  
   For instance, lets say your array is [1,2,3,5,10,30], and you search for 28.
   Normal d3.bisectLeft will return 4, because 28 is inserted after the number 10.  But interactiveBisect will return 5
   because 28 is closer to 30 than 10.
  
   Unit tests can be found in: interactiveBisectTest.html
  
   Has the following known issues:
   * Will not work if the data points move backwards (ie, 10,9,8,7, etc) or if the data points are in random order.
   * Won't work if there are duplicate x coordinate values.
   */
  nv.interactiveBisect = function (values, searchVal, xAccessor) {
      "use strict";
      if (! (values instanceof Array)) {
          return null;
      }
      var _xAccessor;
      if (typeof xAccessor !== 'function') {
          _xAccessor = function(d) {
              return d.x;
          }
      } else {
          _xAccessor = xAccessor;
      }
      var _cmp = function(d, v) {
          // Accessors are no longer passed the index of the element along with
          // the element itself when invoked by d3.bisector.
          //
          // Starting at D3 v3.4.4, d3.bisector() started inspecting the
          // function passed to determine if it should consider it an accessor
          // or a comparator. This meant that accessors that take two arguments
          // (expecting an index as the second parameter) are treated as
          // comparators where the second argument is the search value against
          // which the first argument is compared.
          return _xAccessor(d) - v;
      };
  
      var bisect = d3.bisector(_cmp).left;
      var index = d3.max([0, bisect(values,searchVal) - 1]);
      var currentValue = _xAccessor(values[index]);
  
      if (typeof currentValue === 'undefined') {
          currentValue = index;
      }
  
      if (currentValue === searchVal) {
          return index; //found exact match
      }
  
      var nextIndex = d3.min([index+1, values.length - 1]);
      var nextValue = _xAccessor(values[nextIndex]);
  
      if (typeof nextValue === 'undefined') {
          nextValue = nextIndex;
      }
  
      if (Math.abs(nextValue - searchVal) >= Math.abs(currentValue - searchVal)) {
          return index;
      } else {
          return nextIndex
      }
  };
  
  /*
   Returns the index in the array "values" that is closest to searchVal.
   Only returns an index if searchVal is within some "threshold".
   Otherwise, returns null.
   */
  nv.nearestValueIndex = function (values, searchVal, threshold) {
      "use strict";
      var yDistMax = Infinity, indexToHighlight = null;
      values.forEach(function(d,i) {
          var delta = Math.abs(searchVal - d);
          if ( d != null && delta <= yDistMax && delta < threshold) {
              yDistMax = delta;
              indexToHighlight = i;
          }
      });
      return indexToHighlight;
  };
  
  /* Model which can be instantiated to handle tooltip rendering.
   Example usage:
   var tip = nv.models.tooltip().gravity('w').distance(23)
   .data(myDataObject);
  
   tip();    //just invoke the returned function to render tooltip.
   */
  nv.models.tooltip = function() {
      "use strict";
  
      /*
      Tooltip data. If data is given in the proper format, a consistent tooltip is generated.
      Example Format of data:
      {
          key: "Date",
          value: "August 2009",
          series: [
              {key: "Series 1", value: "Value 1", color: "#000"},
              {key: "Series 2", value: "Value 2", color: "#00f"}
          ]
      }
      */
      var id = "nvtooltip-" + Math.floor(Math.random() * 100000) // Generates a unique id when you create a new tooltip() object.
          ,   data = null
          ,   gravity = 'w'   // Can be 'n','s','e','w'. Determines how tooltip is positioned.
          ,   distance = 25 // Distance to offset tooltip from the mouse location.
          ,   snapDistance = 0   // Tolerance allowed before tooltip is moved from its current position (creates 'snapping' effect)
          ,   classes = null  // Attaches additional CSS classes to the tooltip DIV that is created.
          ,   hidden = true  // Start off hidden, toggle with hide/show functions below.
          ,   hideDelay = 200  // Delay (in ms) before the tooltip hides after calling hide().
          ,   tooltip = null // d3 select of the tooltip div.
          ,   lastPosition = { left: null, top: null } // Last position the tooltip was in.
          ,   enabled = true  // True -> tooltips are rendered. False -> don't render tooltips.
          ,   duration = 100 // Tooltip movement duration, in ms.
          ,   headerEnabled = true // If is to show the tooltip header.
          ,   nvPointerEventsClass = "nv-pointer-events-none" // CSS class to specify whether element should not have mouse events.
      ;
  
      // Format function for the tooltip values column.
      // d is value,
      // i is series index
      // p is point containing the value
      var valueFormatter = function(d, i, p) {
          return d;
      };
  
      // Format function for the tooltip header value.
      var headerFormatter = function(d) {
          return d;
      };
  
      var keyFormatter = function(d, i) {
          return d;
      };
  
      // By default, the tooltip model renders a beautiful table inside a DIV, returned as HTML
      // You can override this function if a custom tooltip is desired. For instance, you could directly manipulate
      // the DOM by accessing elem and returning false.
      var contentGenerator = function(d, elem) {
          if (d === null) {
              return '';
          }
  
          var table = d3.select(document.createElement("table"));
          if (headerEnabled) {
              var theadEnter = table.selectAll("thead")
                  .data([d])
                  .enter().append("thead");
  
              theadEnter.append("tr")
                  .append("td")
                  .attr("colspan", 3)
                  .append("strong")
                  .classed("x-value", true)
                  .html(headerFormatter(d.value));
          }
  
          var tbodyEnter = table.selectAll("tbody")
              .data([d])
              .enter().append("tbody");
  
          var trowEnter = tbodyEnter.selectAll("tr")
                  .data(function(p) { return p.series})
                  .enter()
                  .append("tr")
                  .classed("highlight", function(p) { return p.highlight});
  
          trowEnter.append("td")
              .classed("legend-color-guide",true)
              .append("div")
              .style("background-color", function(p) { return p.color});
  
          trowEnter.append("td")
              .classed("key",true)
              .classed("total",function(p) { return !!p.total})
              .html(function(p, i) { return keyFormatter(p.key, i)});
  
          trowEnter.append("td")
              .classed("value",true)
              .html(function(p, i) { return valueFormatter(p.value, i, p) });
  
          trowEnter.filter(function (p,i) { return p.percent !== undefined }).append("td")
              .classed("percent", true)
              .html(function(p, i) { return "(" + d3.format('%')(p.percent) + ")" });
  
          trowEnter.selectAll("td").each(function(p) {
              if (p.highlight) {
                  var opacityScale = d3.scale.linear().domain([0,1]).range(["#fff",p.color]);
                  var opacity = 0.6;
                  d3.select(this)
                      .style("border-bottom-color", opacityScale(opacity))
                      .style("border-top-color", opacityScale(opacity))
                  ;
              }
          });
  
          var html = table.node().outerHTML;
          if (d.footer !== undefined)
              html += "<div class='footer'>" + d.footer + "</div>";
          return html;
  
      };
  
      /*
       Function that returns the position (relative to the viewport/document.body)
       the tooltip should be placed in.
       Should return: {
          left: <leftPos>,
          top: <topPos>
       }
       */
      var position = function() {
          var pos = {
              left: d3.event !== null ? d3.event.clientX : 0,
              top: d3.event !== null ? d3.event.clientY : 0
          };
  
          if(getComputedStyle(document.body).transform != 'none') {
              // Take the offset into account, as now the tooltip is relative
              // to document.body.
              var client = document.body.getBoundingClientRect();
              pos.left -= client.left;
              pos.top -= client.top;
          }
  
          return pos;
      };
  
      var dataSeriesExists = function(d) {
          if (d && d.series) {
              if (nv.utils.isArray(d.series)) {
                  return true;
              }
              // if object, it's okay just convert to array of the object
              if (nv.utils.isObject(d.series)) {
                  d.series = [d.series];
                  return true;
              }
          }
          return false;
      };
  
      // Calculates the gravity offset of the tooltip. Parameter is position of tooltip
      // relative to the viewport.
      var calcGravityOffset = function(pos) {
          var height = tooltip.node().offsetHeight,
              width = tooltip.node().offsetWidth,
              clientWidth = document.documentElement.clientWidth, // Don't want scrollbars.
              clientHeight = document.documentElement.clientHeight, // Don't want scrollbars.
              left, top, tmp;
  
          // calculate position based on gravity
          switch (gravity) {
              case 'e':
                  left = - width - distance;
                  top = - (height / 2);
                  if(pos.left + left < 0) left = distance;
                  if((tmp = pos.top + top) < 0) top -= tmp;
                  if((tmp = pos.top + top + height) > clientHeight) top -= tmp - clientHeight;
                  break;
              case 'w':
                  left = distance;
                  top = - (height / 2);
                  if (pos.left + left + width > clientWidth) left = - width - distance;
                  if ((tmp = pos.top + top) < 0) top -= tmp;
                  if ((tmp = pos.top + top + height) > clientHeight) top -= tmp - clientHeight;
                  break;
              case 'n':
                  left = - (width / 2) - 5; // - 5 is an approximation of the mouse's height.
                  top = distance;
                  if (pos.top + top + height > clientHeight) top = - height - distance;
                  if ((tmp = pos.left + left) < 0) left -= tmp;
                  if ((tmp = pos.left + left + width) > clientWidth) left -= tmp - clientWidth;
                  break;
              case 's':
                  left = - (width / 2);
                  top = - height - distance;
                  if (pos.top + top < 0) top = distance;
                  if ((tmp = pos.left + left) < 0) left -= tmp;
                  if ((tmp = pos.left + left + width) > clientWidth) left -= tmp - clientWidth;
                  break;
              case 'center':
                  left = - (width / 2);
                  top = - (height / 2);
                  break;
              default:
                  left = 0;
                  top = 0;
                  break;
          }
  
          return { 'left': left, 'top': top };
      };
  
      /*
       Positions the tooltip in the correct place, as given by the position() function.
       */
      var positionTooltip = function() {
          nv.dom.read(function() {
              var pos = position(),
                  gravityOffset = calcGravityOffset(pos),
                  left = pos.left + gravityOffset.left,
                  top = pos.top + gravityOffset.top;
  
              // delay hiding a bit to avoid flickering
              if (hidden) {
                  tooltip
                      .interrupt()
                      .transition()
                      .delay(hideDelay)
                      .duration(0)
                      .style('opacity', 0);
              } else {
                  // using tooltip.style('transform') returns values un-usable for tween
                  var old_translate = 'translate(' + lastPosition.left + 'px, ' + lastPosition.top + 'px)';
                  var new_translate = 'translate(' + Math.round(left) + 'px, ' + Math.round(top) + 'px)';
                  var translateInterpolator = d3.interpolateString(old_translate, new_translate);
                  var is_hidden = tooltip.style('opacity') < 0.1;
  
                  tooltip
                      .interrupt() // cancel running transitions
                      .transition()
                      .duration(is_hidden ? 0 : duration)
                      // using tween since some versions of d3 can't auto-tween a translate on a div
                      .styleTween('transform', function (d) {
                          return translateInterpolator;
                      }, 'important')
                      // Safari has its own `-webkit-transform` and does not support `transform`
                      .styleTween('-webkit-transform', function (d) {
                          return translateInterpolator;
                      })
                      .style('-ms-transform', new_translate)
                      .style('opacity', 1);
              }
  
              lastPosition.left = left;
              lastPosition.top = top;
          });
      };
  
      // Creates new tooltip container, or uses existing one on DOM.
      function initTooltip() {
          if (!tooltip || !tooltip.node()) {
              // Create new tooltip div if it doesn't exist on DOM.
  
              var data = [1];
              tooltip = d3.select(document.body).selectAll('#'+id).data(data);
  
              tooltip.enter().append('div')
                     .attr("class", "nvtooltip " + (classes ? classes : "xy-tooltip"))
                     .attr("id", id)
                     .style("top", 0).style("left", 0)
                     .style('opacity', 0)
                     .style('position', 'absolute')
                     .selectAll("div, table, td, tr").classed(nvPointerEventsClass, true)
                     .classed(nvPointerEventsClass, true);
  
              tooltip.exit().remove()
          }
      }
  
      // Draw the tooltip onto the DOM.
      function nvtooltip() {
          if (!enabled) return;
          if (!dataSeriesExists(data)) return;
  
          nv.dom.write(function () {
              initTooltip();
              // Generate data and set it into tooltip.
              // Bonus - If you override contentGenerator and return false, you can use something like
              //         Angular, React or Knockout to bind the data for your tooltip directly to the DOM.
              var newContent = contentGenerator(data, tooltip.node());
              if (newContent) {
                  tooltip.node().innerHTML = newContent;
              }
  
              positionTooltip();
          });
  
          return nvtooltip;
      }
  
      nvtooltip.nvPointerEventsClass = nvPointerEventsClass;
      nvtooltip.options = nv.utils.optionsFunc.bind(nvtooltip);
  
      nvtooltip._options = Object.create({}, {
          // simple read/write options
          duration: {get: function(){return duration;}, set: function(_){duration=_;}},
          gravity: {get: function(){return gravity;}, set: function(_){gravity=_;}},
          distance: {get: function(){return distance;}, set: function(_){distance=_;}},
          snapDistance: {get: function(){return snapDistance;}, set: function(_){snapDistance=_;}},
          classes: {get: function(){return classes;}, set: function(_){classes=_;}},
          enabled: {get: function(){return enabled;}, set: function(_){enabled=_;}},
          hideDelay: {get: function(){return hideDelay;}, set: function(_){hideDelay=_;}},
          contentGenerator: {get: function(){return contentGenerator;}, set: function(_){contentGenerator=_;}},
          valueFormatter: {get: function(){return valueFormatter;}, set: function(_){valueFormatter=_;}},
          headerFormatter: {get: function(){return headerFormatter;}, set: function(_){headerFormatter=_;}},
          keyFormatter: {get: function(){return keyFormatter;}, set: function(_){keyFormatter=_;}},
          headerEnabled: {get: function(){return headerEnabled;}, set: function(_){headerEnabled=_;}},
          position: {get: function(){return position;}, set: function(_){position=_;}},
  
          // Deprecated options
          chartContainer: {get: function(){return document.body;}, set: function(_){
              // deprecated after 1.8.3
              nv.deprecated('chartContainer', 'feature removed after 1.8.3');
          }},
          fixedTop: {get: function(){return null;}, set: function(_){
              // deprecated after 1.8.1
              nv.deprecated('fixedTop', 'feature removed after 1.8.1');
          }},
          offset: {get: function(){return {left: 0, top: 0};}, set: function(_){
              // deprecated after 1.8.1
              nv.deprecated('offset', 'use chart.tooltip.distance() instead');
          }},
  
          // options with extra logic
          hidden: {get: function(){return hidden;}, set: function(_){
              if (hidden != _) {
                  hidden = !!_;
                  nvtooltip();
              }
          }},
          data: {get: function(){return data;}, set: function(_){
              // if showing a single data point, adjust data format with that
              if (_.point) {
                  _.value = _.point.x;
                  _.series = _.series || {};
                  _.series.value = _.point.y;
                  _.series.color = _.point.color || _.series.color;
              }
              data = _;
          }},
  
          // read only properties
          node: {get: function(){return tooltip.node();}, set: function(_){}},
          id: {get: function(){return id;}, set: function(_){}}
      });
  
      nv.utils.initOptions(nvtooltip);
      return nvtooltip;
  };
  
  
  /*
  Gets the browser window size
  
  Returns object with height and width properties
   */
  nv.utils.windowSize = function() {
      // Sane defaults
      var size = {width: 640, height: 480};
  
      // Most recent browsers use
      if (window.innerWidth && window.innerHeight) {
          size.width = window.innerWidth;
          size.height = window.innerHeight;
          return (size);
      }
  
      // IE can use depending on mode it is in
      if (document.compatMode=='CSS1Compat' &&
          document.documentElement &&
          document.documentElement.offsetWidth ) {
  
          size.width = document.documentElement.offsetWidth;
          size.height = document.documentElement.offsetHeight;
          return (size);
      }
  
      // Earlier IE uses Doc.body
      if (document.body && document.body.offsetWidth) {
          size.width = document.body.offsetWidth;
          size.height = document.body.offsetHeight;
          return (size);
      }
  
      return (size);
  };
  
  
  /* handle dumb browser quirks...  isinstance breaks if you use frames
  typeof returns 'object' for null, NaN is a number, etc.
   */
  nv.utils.isArray = Array.isArray;
  nv.utils.isObject = function(a) {
      return a !== null && typeof a === 'object';
  };
  nv.utils.isFunction = function(a) {
      return typeof a === 'function';
  };
  nv.utils.isDate = function(a) {
      return toString.call(a) === '[object Date]';
  };
  nv.utils.isNumber = function(a) {
      return !isNaN(a) && typeof a === 'number';
  };
  
  
  /*
  Binds callback function to run when window is resized
   */
  nv.utils.windowResize = function(handler) {
      if (window.addEventListener) {
          window.addEventListener('resize', handler);
      } else {
          nv.log("ERROR: Failed to bind to window.resize with: ", handler);
      }
      // return object with clear function to remove the single added callback.
      return {
          callback: handler,
          clear: function() {
              window.removeEventListener('resize', handler);
          }
      }
  };
  
  
  /*
  Backwards compatible way to implement more d3-like coloring of graphs.
  Can take in nothing, an array, or a function/scale
  To use a normal scale, get the range and pass that because we must be able
  to take two arguments and use the index to keep backward compatibility
  */
  nv.utils.getColor = function(color) {
      //if you pass in nothing, get default colors back
      if (color === undefined) {
          return nv.utils.defaultColor();
  
      //if passed an array, turn it into a color scale
      } else if(nv.utils.isArray(color)) {
          var color_scale = d3.scale.ordinal().range(color);
          return function(d, i) {
              var key = i === undefined ? d : i;
              return d.color || color_scale(key);
          };
  
      //if passed a function or scale, return it, or whatever it may be
      //external libs, such as angularjs-nvd3-directives use this
      } else {
          //can't really help it if someone passes rubbish as color
          return color;
      }
  };
  
  
  /*
  Default color chooser uses a color scale of 20 colors from D3
   https://github.com/mbostock/d3/wiki/Ordinal-Scales#categorical-colors
   */
  nv.utils.defaultColor = function() {
      // get range of the scale so we'll turn it into our own function.
      return nv.utils.getColor(d3.scale.category20().range());
  };
  
  
  /*
  Returns a color function that takes the result of 'getKey' for each series and
  looks for a corresponding color from the dictionary
  */
  nv.utils.customTheme = function(dictionary, getKey, defaultColors) {
      // use default series.key if getKey is undefined
      getKey = getKey || function(series) { return series.key };
      defaultColors = defaultColors || d3.scale.category20().range();
  
      // start at end of default color list and walk back to index 0
      var defIndex = defaultColors.length;
  
      return function(series, index) {
          var key = getKey(series);
          if (nv.utils.isFunction(dictionary[key])) {
              return dictionary[key]();
          } else if (dictionary[key] !== undefined) {
              return dictionary[key];
          } else {
              // no match in dictionary, use a default color
              if (!defIndex) {
                  // used all the default colors, start over
                  defIndex = defaultColors.length;
              }
              defIndex = defIndex - 1;
              return defaultColors[defIndex];
          }
      };
  };
  
  
  /*
  From the PJAX example on d3js.org, while this is not really directly needed
  it's a very cool method for doing pjax, I may expand upon it a little bit,
  open to suggestions on anything that may be useful
  */
  nv.utils.pjax = function(links, content) {
  
      var load = function(href) {
          d3.html(href, function(fragment) {
              var target = d3.select(content).node();
              target.parentNode.replaceChild(
                  d3.select(fragment).select(content).node(),
                  target);
              nv.utils.pjax(links, content);
          });
      };
  
      d3.selectAll(links).on("click", function() {
          history.pushState(this.href, this.textContent, this.href);
          load(this.href);
          d3.event.preventDefault();
      });
  
      d3.select(window).on("popstate", function() {
          if (d3.event.state) {
              load(d3.event.state);
          }
      });
  };
  
  
  /*
  For when we want to approximate the width in pixels for an SVG:text element.
  Most common instance is when the element is in a display:none; container.
  Forumla is : text.length * font-size * constant_factor
  */
  nv.utils.calcApproxTextWidth = function (svgTextElem) {
      if (nv.utils.isFunction(svgTextElem.style) && nv.utils.isFunction(svgTextElem.text)) {
          var fontSize = parseInt(svgTextElem.style("font-size").replace("px",""), 10);
          var textLength = svgTextElem.text().length;
          return nv.utils.NaNtoZero(textLength * fontSize * 0.5);
      }
      return 0;
  };
  
  
  /*
  Numbers that are undefined, null or NaN, convert them to zeros.
  */
  nv.utils.NaNtoZero = function(n) {
      if (!nv.utils.isNumber(n)
          || isNaN(n)
          || n === null
          || n === Infinity
          || n === -Infinity) {
  
          return 0;
      }
      return n;
  };
  
  /*
  Add a way to watch for d3 transition ends to d3
  */
  d3.selection.prototype.watchTransition = function(renderWatch){
      var args = [this].concat([].slice.call(arguments, 1));
      return renderWatch.transition.apply(renderWatch, args);
  };
  
  
  /*
  Helper object to watch when d3 has rendered something
  */
  nv.utils.renderWatch = function(dispatch, duration) {
      if (!(this instanceof nv.utils.renderWatch)) {
          return new nv.utils.renderWatch(dispatch, duration);
      }
  
      var _duration = duration !== undefined ? duration : 250;
      var renderStack = [];
      var self = this;
  
      this.models = function(models) {
          models = [].slice.call(arguments, 0);
          models.forEach(function(model){
              model.__rendered = false;
              (function(m){
                  m.dispatch.on('renderEnd', function(arg){
                      m.__rendered = true;
                      self.renderEnd('model');
                  });
              })(model);
  
              if (renderStack.indexOf(model) < 0) {
                  renderStack.push(model);
              }
          });
      return this;
      };
  
      this.reset = function(duration) {
          if (duration !== undefined) {
              _duration = duration;
          }
          renderStack = [];
      };
  
      this.transition = function(selection, args, duration) {
          args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
  
          if (args.length > 1) {
              duration = args.pop();
          } else {
              duration = _duration !== undefined ? _duration : 250;
          }
          selection.__rendered = false;
  
          if (renderStack.indexOf(selection) < 0) {
              renderStack.push(selection);
          }
  
          if (duration === 0) {
              selection.__rendered = true;
              selection.delay = function() { return this; };
              selection.duration = function() { return this; };
              return selection;
          } else {
              if (selection.length === 0) {
                  selection.__rendered = true;
              } else if (selection.every( function(d){ return !d.length; } )) {
                  selection.__rendered = true;
              } else {
                  selection.__rendered = false;
              }
  
              var n = 0;
              return selection
                  .transition()
                  .duration(duration)
                  .each(function(){ ++n; })
                  .each('end', function(d, i) {
                      if (--n === 0) {
                          selection.__rendered = true;
                          self.renderEnd.apply(this, args);
                      }
                  });
          }
      };
  
      this.renderEnd = function() {
          if (renderStack.every( function(d){ return d.__rendered; } )) {
              renderStack.forEach( function(d){ d.__rendered = false; });
              dispatch.renderEnd.apply(this, arguments);
          }
      }
  
  };
  
  
  /*
  Takes multiple objects and combines them into the first one (dst)
  example:  nv.utils.deepExtend({a: 1}, {a: 2, b: 3}, {c: 4});
  gives:  {a: 2, b: 3, c: 4}
  */
  nv.utils.deepExtend = function(dst){
      var sources = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
      sources.forEach(function(source) {
          for (var key in source) {
              var isArray = nv.utils.isArray(dst[key]);
              var isObject = nv.utils.isObject(dst[key]);
              var srcObj = nv.utils.isObject(source[key]);
  
              if (isObject && !isArray && srcObj) {
                  nv.utils.deepExtend(dst[key], source[key]);
              } else {
                  dst[key] = source[key];
              }
          }
      });
  };
  
  
  /*
  state utility object, used to track d3 states in the models
  */
  nv.utils.state = function(){
      if (!(this instanceof nv.utils.state)) {
          return new nv.utils.state();
      }
      var state = {};
      var _self = this;
      var _setState = function(){};
      var _getState = function(){ return {}; };
      var init = null;
      var changed = null;
  
      this.dispatch = d3.dispatch('change', 'set');
  
      this.dispatch.on('set', function(state){
          _setState(state, true);
      });
  
      this.getter = function(fn){
          _getState = fn;
          return this;
      };
  
      this.setter = function(fn, callback) {
          if (!callback) {
              callback = function(){};
          }
          _setState = function(state, update){
              fn(state);
              if (update) {
                  callback();
              }
          };
          return this;
      };
  
      this.init = function(state){
          init = init || {};
          nv.utils.deepExtend(init, state);
      };
  
      var _set = function(){
          var settings = _getState();
  
          if (JSON.stringify(settings) === JSON.stringify(state)) {
              return false;
          }
  
          for (var key in settings) {
              if (state[key] === undefined) {
                  state[key] = {};
              }
              state[key] = settings[key];
              changed = true;
          }
          return true;
      };
  
      this.update = function(){
          if (init) {
              _setState(init, false);
              init = null;
          }
          if (_set.call(this)) {
              this.dispatch.change(state);
          }
      };
  
  };
  
  
  /*
  Snippet of code you can insert into each nv.models.* to give you the ability to
  do things like:
  chart.options({
    showXAxis: true,
    tooltips: true
  });
  
  To enable in the chart:
  chart.options = nv.utils.optionsFunc.bind(chart);
  */
  nv.utils.optionsFunc = function(args) {
      if (args) {
          d3.map(args).forEach((function(key,value) {
              if (nv.utils.isFunction(this[key])) {
                  this[key](value);
              }
          }).bind(this));
      }
      return this;
  };
  
  
  /*
  numTicks:  requested number of ticks
  data:  the chart data
  
  returns the number of ticks to actually use on X axis, based on chart data
  to avoid duplicate ticks with the same value
  */
  nv.utils.calcTicksX = function(numTicks, data) {
      // find max number of values from all data streams
      var numValues = 1;
      var i = 0;
      for (i; i < data.length; i += 1) {
          var stream_len = data[i] && data[i].values ? data[i].values.length : 0;
          numValues = stream_len > numValues ? stream_len : numValues;
      }
      nv.log("Requested number of ticks: ", numTicks);
      nv.log("Calculated max values to be: ", numValues);
      // make sure we don't have more ticks than values to avoid duplicates
      numTicks = numTicks > numValues ? numTicks = numValues - 1 : numTicks;
      // make sure we have at least one tick
      numTicks = numTicks < 1 ? 1 : numTicks;
      // make sure it's an integer
      numTicks = Math.floor(numTicks);
      nv.log("Calculating tick count as: ", numTicks);
      return numTicks;
  };
  
  
  /*
  returns number of ticks to actually use on Y axis, based on chart data
  */
  nv.utils.calcTicksY = function(numTicks, data) {
      // currently uses the same logic but we can adjust here if needed later
      return nv.utils.calcTicksX(numTicks, data);
  };
  
  
  /*
  Add a particular option from an options object onto chart
  Options exposed on a chart are a getter/setter function that returns chart
  on set to mimic typical d3 option chaining, e.g. svg.option1('a').option2('b');
  
  option objects should be generated via Object.create() to provide
  the option of manipulating data via get/set functions.
  */
  nv.utils.initOption = function(chart, name) {
      // if it's a call option, just call it directly, otherwise do get/set
      if (chart._calls && chart._calls[name]) {
          chart[name] = chart._calls[name];
      } else {
          chart[name] = function (_) {
              if (!arguments.length) return chart._options[name];
              chart._overrides[name] = true;
              chart._options[name] = _;
              return chart;
          };
          // calling the option as _option will ignore if set by option already
          // so nvd3 can set options internally but the stop if set manually
          chart['_' + name] = function(_) {
              if (!arguments.length) return chart._options[name];
              if (!chart._overrides[name]) {
                  chart._options[name] = _;
              }
              return chart;
          }
      }
  };
  
  
  /*
  Add all options in an options object to the chart
  */
  nv.utils.initOptions = function(chart) {
      chart._overrides = chart._overrides || {};
      var ops = Object.getOwnPropertyNames(chart._options || {});
      var calls = Object.getOwnPropertyNames(chart._calls || {});
      ops = ops.concat(calls);
      for (var i in ops) {
          nv.utils.initOption(chart, ops[i]);
      }
  };
  
  
  /*
  Inherit options from a D3 object
  d3.rebind makes calling the function on target actually call it on source
  Also use _d3options so we can track what we inherit for documentation and chained inheritance
  */
  nv.utils.inheritOptionsD3 = function(target, d3_source, oplist) {
      target._d3options = oplist.concat(target._d3options || []);
      // Find unique d3 options (string) and update d3options
      target._d3options = (target._d3options || []).filter(function(item, i, ar){ return ar.indexOf(item) === i; });
      oplist.unshift(d3_source);
      oplist.unshift(target);
      d3.rebind.apply(this, oplist);
  };
  
  
  /*
  Remove duplicates from an array
  */
  nv.utils.arrayUnique = function(a) {
      return a.sort().filter(function(item, pos) {
          return !pos || item != a[pos - 1];
      });
  };
  
  
  /*
  Keeps a list of custom symbols to draw from in addition to d3.svg.symbol
  Necessary since d3 doesn't let you extend its list -_-
  Add new symbols by doing nv.utils.symbols.set('name', function(size){...});
  */
  nv.utils.symbolMap = d3.map();
  
  
  /*
  Replaces d3.svg.symbol so that we can look both there and our own map
   */
  nv.utils.symbol = function() {
      var type,
          size = 64;
      function symbol(d,i) {
          var t = type.call(this,d,i);
          var s = size.call(this,d,i);
          if (d3.svg.symbolTypes.indexOf(t) !== -1) {
              return d3.svg.symbol().type(t).size(s)();
          } else {
              return nv.utils.symbolMap.get(t)(s);
          }
      }
      symbol.type = function(_) {
          if (!arguments.length) return type;
          type = d3.functor(_);
          return symbol;
      };
      symbol.size = function(_) {
          if (!arguments.length) return size;
          size = d3.functor(_);
          return symbol;
      };
      return symbol;
  };
  
  
  /*
  Inherit option getter/setter functions from source to target
  d3.rebind makes calling the function on target actually call it on source
  Also track via _inherited and _d3options so we can track what we inherit
  for documentation generation purposes and chained inheritance
  */
  nv.utils.inheritOptions = function(target, source) {
      // inherit all the things
      var ops = Object.getOwnPropertyNames(source._options || {});
      var calls = Object.getOwnPropertyNames(source._calls || {});
      var inherited = source._inherited || [];
      var d3ops = source._d3options || [];
      var args = ops.concat(calls).concat(inherited).concat(d3ops);
      args.unshift(source);
      args.unshift(target);
      d3.rebind.apply(this, args);
      // pass along the lists to keep track of them, don't allow duplicates
      target._inherited = nv.utils.arrayUnique(ops.concat(calls).concat(inherited).concat(ops).concat(target._inherited || []));
      target._d3options = nv.utils.arrayUnique(d3ops.concat(target._d3options || []));
  };
  
  
  /*
  Runs common initialize code on the svg before the chart builds
  */
  nv.utils.initSVG = function(svg) {
      svg.classed({'nvd3-svg':true});
  };
  
  
  /*
  Sanitize and provide default for the container height.
  */
  nv.utils.sanitizeHeight = function(height, container) {
      return (height || parseInt(container.style('height'), 10) || 400);
  };
  
  
  /*
  Sanitize and provide default for the container width.
  */
  nv.utils.sanitizeWidth = function(width, container) {
      return (width || parseInt(container.style('width'), 10) || 960);
  };
  
  
  /*
  Calculate the available height for a chart.
  */
  nv.utils.availableHeight = function(height, container, margin) {
      return Math.max(0,nv.utils.sanitizeHeight(height, container) - margin.top - margin.bottom);
  };
  
  /*
  Calculate the available width for a chart.
  */
  nv.utils.availableWidth = function(width, container, margin) {
      return Math.max(0,nv.utils.sanitizeWidth(width, container) - margin.left - margin.right);
  };
  
  /*
  Clear any rendered chart components and display a chart's 'noData' message
  */
  nv.utils.noData = function(chart, container) {
      var opt = chart.options(),
          margin = opt.margin(),
          noData = opt.noData(),
          data = (noData == null) ? ["No Data Available."] : [noData],
          height = nv.utils.availableHeight(null, container, margin),
          width = nv.utils.availableWidth(null, container, margin),
          x = margin.left + width/2,
          y = margin.top + height/2;
  
      //Remove any previously created chart components
      container.selectAll('g').remove();
  
      var noDataText = container.selectAll('.nv-noData').data(data);
  
      noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');
  
      noDataText
          .attr('x', x)
          .attr('y', y)
          .text(function(t){ return t; });
  };
  
  /*
   Wrap long labels.
   */
  nv.utils.wrapTicks = function (text, width) {
      text.each(function() {
          var text = d3.select(this),
              words = text.text().split(/\s+/).reverse(),
              word,
              line = [],
              lineNumber = 0,
              lineHeight = 1.1,
              y = text.attr("y"),
              dy = parseFloat(text.attr("dy")),
              tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
          while (word = words.pop()) {
              line.push(word);
              tspan.text(line.join(" "));
              if (tspan.node().getComputedTextLength() > width) {
                  line.pop();
                  tspan.text(line.join(" "));
                  line = [word];
                  tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
              }
          }
      });
  };
  
  /*
  Check equality of 2 array
  */
  nv.utils.arrayEquals = function (array1, array2) {
      if (array1 === array2)
          return true;
  
      if (!array1 || !array2)
          return false;
  
      // compare lengths - can save a lot of time
      if (array1.length != array2.length)
          return false;
  
      for (var i = 0,
          l = array1.length; i < l; i++) {
          // Check if we have nested arrays
          if (array1[i] instanceof Array && array2[i] instanceof Array) {
              // recurse into the nested arrays
              if (!nv.arrayEquals(array1[i], array2[i]))
                  return false;
          } else if (array1[i] != array2[i]) {
              // Warning - two different object instances will never be equal: {x:20} != {x:20}
              return false;
          }
      }
      return true;
  };
  
  /*
   Check if a point within an arc
   */
  nv.utils.pointIsInArc = function(pt, ptData, d3Arc) {
      // Center of the arc is assumed to be 0,0
      // (pt.x, pt.y) are assumed to be relative to the center
      var r1 = d3Arc.innerRadius()(ptData), // Note: Using the innerRadius
        r2 = d3Arc.outerRadius()(ptData),
        theta1 = d3Arc.startAngle()(ptData),
        theta2 = d3Arc.endAngle()(ptData);
  
      var dist = pt.x * pt.x + pt.y * pt.y,
        angle = Math.atan2(pt.x, -pt.y); // Note: different coordinate system.
  
      angle = (angle < 0) ? (angle + Math.PI * 2) : angle;
  
      return (r1 * r1 <= dist) && (dist <= r2 * r2) &&
        (theta1 <= angle) && (angle <= theta2);
  };
  
  nv.models.axis = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var axis = d3.svg.axis();
      var scale = d3.scale.linear();
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 75 //only used for tickLabel currently
          , height = 60 //only used for tickLabel currently
          , axisLabelText = null
          , showMaxMin = true //TODO: showMaxMin should be disabled on all ordinal scaled axes
          , rotateLabels = 0
          , rotateYLabel = true
          , staggerLabels = false
          , isOrdinal = false
          , ticks = null
          , axisLabelDistance = 0
          , fontSize = undefined
          , duration = 250
          , dispatch = d3.dispatch('renderEnd')
          , tickFormatMaxMin
          ;
      axis
          .scale(scale)
          .orient('bottom')
          .tickFormat(function(d) { return d })
      ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var scale0;
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var container = d3.select(this);
              nv.utils.initSVG(container);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-axis').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-axis');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              if (ticks !== null)
                  axis.ticks(ticks);
              else if (axis.orient() == 'top' || axis.orient() == 'bottom')
                  axis.ticks(Math.abs(scale.range()[1] - scale.range()[0]) / 100);
  
              //TODO: consider calculating width/height based on whether or not label is added, for reference in charts using this component
              g.watchTransition(renderWatch, 'axis').call(axis);
  
              scale0 = scale0 || axis.scale();
  
              var fmt = axis.tickFormat();
              if (fmt == null) {
                  fmt = scale0.tickFormat();
              }
  
              var axisLabel = g.selectAll('text.nv-axislabel')
                  .data([axisLabelText || null]);
              axisLabel.exit().remove();
  
              //only skip when fontSize is undefined so it can be cleared with a null or blank string
              if (fontSize !== undefined) {
                  g.selectAll('g').select("text").style('font-size', fontSize);
              }
  
              var xLabelMargin;
              var axisMaxMin;
              var w;
              switch (axis.orient()) {
                  case 'top':
                      axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    w = 0;
                    if (scale.range().length === 1) {
                      w = isOrdinal ? scale.range()[0] * 2 + scale.rangeBand() : 0;
                    } else if (scale.range().length === 2) {
                      w = isOrdinal ? scale.range()[0] + scale.range()[1] + scale.rangeBand() : scale.range()[1];
                    } else if ( scale.range().length > 2){
                      w = scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]);
                    };
                      axisLabel
                          .attr('text-anchor', 'middle')
                          .attr('y', 0)
                          .attr('x', w/2);
                      if (showMaxMin) {
                          axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                              .data(scale.domain());
                          axisMaxMin.enter().append('g').attr('class',function(d,i){
                                  return ['nv-axisMaxMin','nv-axisMaxMin-x',(i == 0 ? 'nv-axisMin-x':'nv-axisMax-x')].join(' ')
                          }).append('text');
                          axisMaxMin.exit().remove();
                          axisMaxMin
                              .attr('transform', function(d,i) {
                                  return 'translate(' + nv.utils.NaNtoZero(scale(d)) + ',0)'
                              })
                              .select('text')
                              .attr('dy', '-0.5em')
                              .attr('y', -axis.tickPadding())
                              .attr('text-anchor', 'middle')
                              .text(function(d,i) {
                                  var formatter = tickFormatMaxMin || fmt;
                                  var v = formatter(d);
                                  return ('' + v).match('NaN') ? '' : v;
                              });
                          axisMaxMin.watchTransition(renderWatch, 'min-max top')
                              .attr('transform', function(d,i) {
                                  return 'translate(' + nv.utils.NaNtoZero(scale.range()[i]) + ',0)'
                              });
                      }
                      break;
                  case 'bottom':
                      xLabelMargin = axisLabelDistance + 36;
                      var maxTextWidth = 30;
                      var textHeight = 0;
                      var xTicks = g.selectAll('g').select("text");
                      var rotateLabelsRule = '';
                      if (rotateLabels%360) {
                          //Reset transform on ticks so textHeight can be calculated correctly
                          xTicks.attr('transform', '');
                          //Calculate the longest xTick width
                          xTicks.each(function(d,i){
                              var box = this.getBoundingClientRect();
                              var width = box.width;
                              textHeight = box.height;
                              if(width > maxTextWidth) maxTextWidth = width;
                          });
                          rotateLabelsRule = 'rotate(' + rotateLabels + ' 0,' + (textHeight/2 + axis.tickPadding()) + ')';
                          //Convert to radians before calculating sin. Add 30 to margin for healthy padding.
                          var sin = Math.abs(Math.sin(rotateLabels*Math.PI/180));
                          xLabelMargin = (sin ? sin*maxTextWidth : maxTextWidth)+30;
                          //Rotate all xTicks
                          xTicks
                              .attr('transform', rotateLabelsRule)
                              .style('text-anchor', rotateLabels%360 > 0 ? 'start' : 'end');
                      } else {
                          if (staggerLabels) {
                              xTicks
                                  .attr('transform', function(d,i) {
                                      return 'translate(0,' + (i % 2 == 0 ? '0' : '12') + ')'
                                  });
                          } else {
                              xTicks.attr('transform', "translate(0,0)");
                          }
                      }
                      axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                      w = 0;
                      if (scale.range().length === 1) {
                          w = isOrdinal ? scale.range()[0] * 2 + scale.rangeBand() : 0;
                      } else if (scale.range().length === 2) {
                          w = isOrdinal ? scale.range()[0] + scale.range()[1] + scale.rangeBand() : scale.range()[1];
                      } else if ( scale.range().length > 2){
                          w = scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]);
                      };
                      axisLabel
                          .attr('text-anchor', 'middle')
                          .attr('y', xLabelMargin)
                          .attr('x', w/2);
                      if (showMaxMin) {
                          //if (showMaxMin && !isOrdinal) {
                          axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                              //.data(scale.domain())
                              .data([scale.domain()[0], scale.domain()[scale.domain().length - 1]]);
                          axisMaxMin.enter().append('g').attr('class',function(d,i){
                                  return ['nv-axisMaxMin','nv-axisMaxMin-x',(i == 0 ? 'nv-axisMin-x':'nv-axisMax-x')].join(' ')
                          }).append('text');
                          axisMaxMin.exit().remove();
                          axisMaxMin
                              .attr('transform', function(d,i) {
                                  return 'translate(' + nv.utils.NaNtoZero((scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0))) + ',0)'
                              })
                              .select('text')
                              .attr('dy', '.71em')
                              .attr('y', axis.tickPadding())
                              .attr('transform', rotateLabelsRule)
                              .style('text-anchor', rotateLabels ? (rotateLabels%360 > 0 ? 'start' : 'end') : 'middle')
                              .text(function(d,i) {
                                  var formatter = tickFormatMaxMin || fmt;
                                  var v = formatter(d);
                                  return ('' + v).match('NaN') ? '' : v;
                              });
                          axisMaxMin.watchTransition(renderWatch, 'min-max bottom')
                              .attr('transform', function(d,i) {
                                  return 'translate(' + nv.utils.NaNtoZero((scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0))) + ',0)'
                              });
                      }
  
                      break;
                  case 'right':
                      axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                      axisLabel
                          .style('text-anchor', rotateYLabel ? 'middle' : 'begin')
                          .attr('transform', rotateYLabel ? 'rotate(90)' : '')
                          .attr('y', rotateYLabel ? (-Math.max(margin.right, width) + 12 - (axisLabelDistance || 0)) : -10) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart
                          .attr('x', rotateYLabel ? (d3.max(scale.range()) / 2) : axis.tickPadding());
                      if (showMaxMin) {
                          axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                              .data(scale.domain());
                           axisMaxMin.enter().append('g').attr('class',function(d,i){
                                  return ['nv-axisMaxMin','nv-axisMaxMin-y',(i == 0 ? 'nv-axisMin-y':'nv-axisMax-y')].join(' ')
                          }).append('text')
                              .style('opacity', 0);
                          axisMaxMin.exit().remove();
                          axisMaxMin
                              .attr('transform', function(d,i) {
                                  return 'translate(0,' + nv.utils.NaNtoZero(scale(d)) + ')'
                              })
                              .select('text')
                              .attr('dy', '.32em')
                              .attr('y', 0)
                              .attr('x', axis.tickPadding())
                              .style('text-anchor', 'start')
                              .text(function(d, i) {
                                  var formatter = tickFormatMaxMin || fmt;
                                  var v = formatter(d);
                                  return ('' + v).match('NaN') ? '' : v;
                              });
                          axisMaxMin.watchTransition(renderWatch, 'min-max right')
                              .attr('transform', function(d,i) {
                                  return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')'
                              })
                              .select('text')
                              .style('opacity', 1);
                      }
                      break;
                  case 'left':
                      /*
                       //For dynamically placing the label. Can be used with dynamically-sized chart axis margins
                       var yTicks = g.selectAll('g').select("text");
                       yTicks.each(function(d,i){
                       var labelPadding = this.getBoundingClientRect().width + axis.tickPadding() + 16;
                       if(labelPadding > width) width = labelPadding;
                       });
                       */
                      axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                      axisLabel
                          .style('text-anchor', rotateYLabel ? 'middle' : 'end')
                          .attr('transform', rotateYLabel ? 'rotate(-90)' : '')
                          .attr('y', rotateYLabel ? (-Math.max(margin.left, width) + 25 - (axisLabelDistance || 0)) : -10)
                          .attr('x', rotateYLabel ? (-d3.max(scale.range()) / 2) : -axis.tickPadding());
                      if (showMaxMin) {
                          axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                              .data(scale.domain());
                          axisMaxMin.enter().append('g').attr('class',function(d,i){
                                  return ['nv-axisMaxMin','nv-axisMaxMin-y',(i == 0 ? 'nv-axisMin-y':'nv-axisMax-y')].join(' ')
                          }).append('text')
                              .style('opacity', 0);
                          axisMaxMin.exit().remove();
                          axisMaxMin
                              .attr('transform', function(d,i) {
                                  return 'translate(0,' + nv.utils.NaNtoZero(scale0(d)) + ')'
                              })
                              .select('text')
                              .attr('dy', '.32em')
                              .attr('y', 0)
                              .attr('x', -axis.tickPadding())
                              .attr('text-anchor', 'end')
                              .text(function(d,i) {
                                  var formatter = tickFormatMaxMin || fmt;
                                  var v = formatter(d);
                                  return ('' + v).match('NaN') ? '' : v;
                              });
                          axisMaxMin.watchTransition(renderWatch, 'min-max right')
                              .attr('transform', function(d,i) {
                                  return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')'
                              })
                              .select('text')
                              .style('opacity', 1);
                      }
                      break;
              }
              axisLabel.text(function(d) { return d });
  
              if (showMaxMin && (axis.orient() === 'left' || axis.orient() === 'right')) {
                  //check if max and min overlap other values, if so, hide the values that overlap
                  g.selectAll('g') // the g's wrapping each tick
                      .each(function(d,i) {
                          d3.select(this).select('text').attr('opacity', 1);
                          if (scale(d) < scale.range()[1] + 10 || scale(d) > scale.range()[0] - 10) { // 10 is assuming text height is 16... if d is 0, leave it!
                              if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL
                                  d3.select(this).attr('opacity', 0);
  
                              d3.select(this).select('text').attr('opacity', 0); // Don't remove the ZERO line!!
                          }
                      });
  
                  //if Max and Min = 0 only show min, Issue #281
                  if (scale.domain()[0] == scale.domain()[1] && scale.domain()[0] == 0) {
                      wrap.selectAll('g.nv-axisMaxMin').style('opacity', function (d, i) {
                          return !i ? 1 : 0
                      });
                  }
              }
  
              if (showMaxMin && (axis.orient() === 'top' || axis.orient() === 'bottom')) {
                  var maxMinRange = [];
                  wrap.selectAll('g.nv-axisMaxMin')
                      .each(function(d,i) {
                          try {
                              if (i) // i== 1, max position
                                  maxMinRange.push(scale(d) - this.getBoundingClientRect().width - 4);  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)
                              else // i==0, min position
                                  maxMinRange.push(scale(d) + this.getBoundingClientRect().width + 4)
                          }catch (err) {
                              if (i) // i== 1, max position
                                  maxMinRange.push(scale(d) - 4);  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)
                              else // i==0, min position
                                  maxMinRange.push(scale(d) + 4);
                          }
                      });
                  // the g's wrapping each tick
                  g.selectAll('g').each(function(d, i) {
                      if (scale(d) < maxMinRange[0] || scale(d) > maxMinRange[1]) {
                          if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL
                              d3.select(this).remove();
                          else
                              d3.select(this).select('text').remove(); // Don't remove the ZERO line!!
                      }
                  });
              }
  
              //Highlight zero tick line
              g.selectAll('.tick')
                  .filter(function (d) {
                      /*
                      The filter needs to return only ticks at or near zero.
                      Numbers like 0.00001 need to count as zero as well,
                      and the arithmetic trick below solves that.
                      */
                      return !parseFloat(Math.round(d * 100000) / 1000000) && (d !== undefined)
                  })
                  .classed('zero', true);
  
              //store old scales for use in transitions on update
              scale0 = scale.copy();
  
          });
  
          renderWatch.renderEnd('axis immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.axis = axis;
      chart.dispatch = dispatch;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          axisLabelDistance: {get: function(){return axisLabelDistance;}, set: function(_){axisLabelDistance=_;}},
          staggerLabels:     {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
          rotateLabels:      {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},
          rotateYLabel:      {get: function(){return rotateYLabel;}, set: function(_){rotateYLabel=_;}},
          showMaxMin:        {get: function(){return showMaxMin;}, set: function(_){showMaxMin=_;}},
          axisLabel:         {get: function(){return axisLabelText;}, set: function(_){axisLabelText=_;}},
          height:            {get: function(){return height;}, set: function(_){height=_;}},
          ticks:             {get: function(){return ticks;}, set: function(_){ticks=_;}},
          width:             {get: function(){return width;}, set: function(_){width=_;}},
          fontSize:          {get: function(){return fontSize;}, set: function(_){fontSize=_;}},
          tickFormatMaxMin:  {get: function(){return tickFormatMaxMin;}, set: function(_){tickFormatMaxMin=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top !== undefined    ? _.top    : margin.top;
              margin.right  = _.right !== undefined  ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left !== undefined   ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration=_;
              renderWatch.reset(duration);
          }},
          scale: {get: function(){return scale;}, set: function(_){
              scale = _;
              axis.scale(scale);
              isOrdinal = typeof scale.rangeBands === 'function';
              nv.utils.inheritOptionsD3(chart, scale, ['domain', 'range', 'rangeBand', 'rangeBands']);
          }}
      });
  
      nv.utils.initOptions(chart);
      nv.utils.inheritOptionsD3(chart, axis, ['orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat']);
      nv.utils.inheritOptionsD3(chart, scale, ['domain', 'range', 'rangeBand', 'rangeBands']);
  
      return chart;
  };
  nv.models.boxPlot = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0},
          width = 960,
          height = 500,
          id = Math.floor(Math.random() * 10000), // Create semi-unique ID in case user doesn't select one
          xScale = d3.scale.ordinal(),
          yScale = d3.scale.linear(),
          getX  = function(d) { return d.label }, // Default data model selectors.
          getQ1 = function(d) { return d.values.Q1 },
          getQ2 = function(d) { return d.values.Q2 },
          getQ3 = function(d) { return d.values.Q3 },
          getWl = function(d) { return d.values.whisker_low },
          getWh = function(d) { return d.values.whisker_high },
          getColor = function(d) { return d.color },
          getOlItems  = function(d) { return d.values.outliers },
          getOlValue = function(d, i, j) { return d },
          getOlLabel = function(d, i, j) { return d },
          getOlColor = function(d, i, j) { return undefined },
          color = nv.utils.defaultColor(),
          container = null,
          xDomain, xRange,
          yDomain, yRange,
          dispatch = d3.dispatch('elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd'),
          duration = 250,
          maxBoxWidth = null;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var xScale0, yScale0;
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right,
                  availableHeight = height - margin.top - margin.bottom;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
  
              // Setup Scales
              xScale.domain(xDomain || data.map(function(d,i) { return getX(d,i); }))
                  .rangeBands(xRange || [0, availableWidth], 0.1);
  
              // if we know yDomain, no need to calculate
              var yData = []
              if (!yDomain) {
                  // (y-range is based on quartiles, whiskers and outliers)
                  var values = [], yMin, yMax;
                  data.forEach(function (d, i) {
                      var q1 = getQ1(d), q3 = getQ3(d), wl = getWl(d), wh = getWh(d);
                      var olItems = getOlItems(d);
                      if (olItems) {
                          olItems.forEach(function (e, i) {
                              values.push(getOlValue(e, i, undefined));
                          });
                      }
                      if (wl) { values.push(wl) }
                      if (q1) { values.push(q1) }
                      if (q3) { values.push(q3) }
                      if (wh) { values.push(wh) }
                  });
                  yMin = d3.min(values);
                  yMax = d3.max(values);
                  yData = [ yMin, yMax ] ;
              }
  
              yScale.domain(yDomain || yData);
              yScale.range(yRange || [availableHeight, 0]);
  
              //store old scales if they exist
              xScale0 = xScale0 || xScale;
              yScale0 = yScale0 || yScale.copy().range([yScale(0),yScale(0)]);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap');
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              var boxplots = wrap.selectAll('.nv-boxplot').data(function(d) { return d });
              var boxEnter = boxplots.enter().append('g').style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);
              boxplots
                  .attr('class', 'nv-boxplot')
                  .attr('transform', function(d,i,j) { return 'translate(' + (xScale(getX(d,i)) + xScale.rangeBand() * 0.05) + ', 0)'; })
                  .classed('hover', function(d) { return d.hover });
              boxplots
                  .watchTransition(renderWatch, 'nv-boxplot: boxplots')
                  .style('stroke-opacity', 1)
                  .style('fill-opacity', 0.75)
                  .delay(function(d,i) { return i * duration / data.length })
                  .attr('transform', function(d,i) {
                      return 'translate(' + (xScale(getX(d,i)) + xScale.rangeBand() * 0.05) + ', 0)';
                  });
              boxplots.exit().remove();
  
              // ----- add the SVG elements for each boxPlot -----
  
              // conditionally append whisker lines
              boxEnter.each(function(d,i) {
                  var box = d3.select(this);
                  [getWl, getWh].forEach(function (f) {
                      if (f(d) !== undefined && f(d) !== null) {
                          var key = (f === getWl) ? 'low' : 'high';
                          box.append('line')
                            .style('stroke', getColor(d) || color(d,i))
                            .attr('class', 'nv-boxplot-whisker nv-boxplot-' + key);
                          box.append('line')
                            .style('stroke', getColor(d) || color(d,i))
                            .attr('class', 'nv-boxplot-tick nv-boxplot-' + key);
                      }
                  });
              });
  
              var box_width = function() { return (maxBoxWidth === null ? xScale.rangeBand() * 0.9 : Math.min(75, xScale.rangeBand() * 0.9)); };
              var box_left  = function() { return xScale.rangeBand() * 0.45 - box_width()/2; };
              var box_right = function() { return xScale.rangeBand() * 0.45 + box_width()/2; };
  
              // update whisker lines and ticks
              [getWl, getWh].forEach(function (f) {
                  var key = (f === getWl) ? 'low' : 'high';
                  var endpoint = (f === getWl) ? getQ1 : getQ3;
                  boxplots.select('line.nv-boxplot-whisker.nv-boxplot-' + key)
                    .watchTransition(renderWatch, 'nv-boxplot: boxplots')
                      .attr('x1', xScale.rangeBand() * 0.45 )
                      .attr('y1', function(d,i) { return yScale(f(d)); })
                      .attr('x2', xScale.rangeBand() * 0.45 )
                      .attr('y2', function(d,i) { return yScale(endpoint(d)); });
                  boxplots.select('line.nv-boxplot-tick.nv-boxplot-' + key)
                    .watchTransition(renderWatch, 'nv-boxplot: boxplots')
                      .attr('x1', box_left )
                      .attr('y1', function(d,i) { return yScale(f(d)); })
                      .attr('x2', box_right )
                      .attr('y2', function(d,i) { return yScale(f(d)); });
              });
  
              [getWl, getWh].forEach(function (f) {
                  var key = (f === getWl) ? 'low' : 'high';
                  boxEnter.selectAll('.nv-boxplot-' + key)
                    .on('mouseover', function(d,i,j) {
                        d3.select(this).classed('hover', true);
                        dispatch.elementMouseover({
                            series: { key: f(d), color: getColor(d) || color(d,j) },
                            e: d3.event
                        });
                    })
                    .on('mouseout', function(d,i,j) {
                        d3.select(this).classed('hover', false);
                        dispatch.elementMouseout({
                            series: { key: f(d), color: getColor(d) || color(d,j) },
                            e: d3.event
                        });
                    })
                    .on('mousemove', function(d,i) {
                        dispatch.elementMousemove({e: d3.event});
                    });
              });
  
              // boxes
              boxEnter.append('rect')
                  .attr('class', 'nv-boxplot-box')
                  // tooltip events
                  .on('mouseover', function(d,i) {
                      d3.select(this).classed('hover', true);
                      dispatch.elementMouseover({
                          key: getX(d),
                          value: getX(d),
                          series: [
                              { key: 'Q3', value: getQ3(d), color: getColor(d) || color(d,i) },
                              { key: 'Q2', value: getQ2(d), color: getColor(d) || color(d,i) },
                              { key: 'Q1', value: getQ1(d), color: getColor(d) || color(d,i) }
                          ],
                          data: d,
                          index: i,
                          e: d3.event
                      });
                  })
                  .on('mouseout', function(d,i) {
                      d3.select(this).classed('hover', false);
                      dispatch.elementMouseout({
                          key: getX(d),
                          value: getX(d),
                          series: [
                              { key: 'Q3', value: getQ3(d), color: getColor(d) || color(d,i) },
                              { key: 'Q2', value: getQ2(d), color: getColor(d) || color(d,i) },
                              { key: 'Q1', value: getQ1(d), color: getColor(d) || color(d,i) }
                          ],
                          data: d,
                          index: i,
                          e: d3.event
                      });
                  })
                  .on('mousemove', function(d,i) {
                      dispatch.elementMousemove({e: d3.event});
                  });
  
              // box transitions
              boxplots.select('rect.nv-boxplot-box')
                .watchTransition(renderWatch, 'nv-boxplot: boxes')
                  .attr('y', function(d,i) { return yScale(getQ3(d)); })
                  .attr('width', box_width)
                  .attr('x', box_left )
                  .attr('height', function(d,i) { return Math.abs(yScale(getQ3(d)) - yScale(getQ1(d))) || 1 })
                  .style('fill', function(d,i) { return getColor(d) || color(d,i) })
                  .style('stroke', function(d,i) { return getColor(d) || color(d,i) });
  
              // median line
              boxEnter.append('line').attr('class', 'nv-boxplot-median');
  
              boxplots.select('line.nv-boxplot-median')
                .watchTransition(renderWatch, 'nv-boxplot: boxplots line')
                  .attr('x1', box_left)
                  .attr('y1', function(d,i) { return yScale(getQ2(d)); })
                  .attr('x2', box_right)
                  .attr('y2', function(d,i) { return yScale(getQ2(d)); });
  
              // outliers
              var outliers = boxplots.selectAll('.nv-boxplot-outlier').data(function(d) {
                  return getOlItems(d) || [];
              });
              outliers.enter().append('circle')
                  .style('fill', function(d,i,j) { return getOlColor(d,i,j) || color(d,j) })
                  .style('stroke', function(d,i,j) { return getOlColor(d,i,j) || color(d,j) })
                  .style('z-index', 9000)
                  .on('mouseover', function(d,i,j) {
                      d3.select(this).classed('hover', true);
                      dispatch.elementMouseover({
                          series: { key: getOlLabel(d,i,j), color: getOlColor(d,i,j) || color(d,j) },
                          e: d3.event
                      });
                  })
                  .on('mouseout', function(d,i,j) {
                      d3.select(this).classed('hover', false);
                      dispatch.elementMouseout({
                          series: { key: getOlLabel(d,i,j), color: getOlColor(d,i,j) || color(d,j) },
                          e: d3.event
                      });
                  })
                  .on('mousemove', function(d,i) {
                      dispatch.elementMousemove({e: d3.event});
                  });
              outliers.attr('class', 'nv-boxplot-outlier');
              outliers
                .watchTransition(renderWatch, 'nv-boxplot: nv-boxplot-outlier')
                  .attr('cx', xScale.rangeBand() * 0.45)
                  .attr('cy', function(d,i,j) { return yScale(getOlValue(d,i,j)); })
                  .attr('r', '3');
              outliers.exit().remove();
  
              //store old scales for use in transitions on update
              xScale0 = xScale.copy();
              yScale0 = yScale.copy();
          });
  
          renderWatch.renderEnd('nv-boxplot immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:       {get: function(){return width;}, set: function(_){width=_;}},
          height:      {get: function(){return height;}, set: function(_){height=_;}},
          maxBoxWidth: {get: function(){return maxBoxWidth;}, set: function(_){maxBoxWidth=_;}},
          x:           {get: function(){return getX;}, set: function(_){getX=_;}},
          q1: {get: function(){return getQ1;}, set: function(_){getQ1=_;}},
          q2: {get: function(){return getQ2;}, set: function(_){getQ2=_;}},
          q3: {get: function(){return getQ3;}, set: function(_){getQ3=_;}},
          wl: {get: function(){return getWl;}, set: function(_){getWl=_;}},
          wh: {get: function(){return getWh;}, set: function(_){getWh=_;}},
          itemColor:    {get: function(){return getColor;}, set: function(_){getColor=_;}},
          outliers:     {get: function(){return getOlItems;}, set: function(_){getOlItems=_;}},
          outlierValue: {get: function(){return getOlValue;}, set: function(_){getOlValue=_;}},
          outlierLabel: {get: function(){return getOlLabel;}, set: function(_){getOlLabel=_;}},
          outlierColor: {get: function(){return getOlColor;}, set: function(_){getOlColor=_;}},
          xScale:  {get: function(){return xScale;}, set: function(_){xScale=_;}},
          yScale:  {get: function(){return yScale;}, set: function(_){yScale=_;}},
          xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
          id:          {get: function(){return id;}, set: function(_){id=_;}},
          // rectClass: {get: function(){return rectClass;}, set: function(_){rectClass=_;}},
          y: {
              get: function() {
                  console.warn('BoxPlot \'y\' chart option is deprecated. Please use model overrides instead.');
                  return {};
              },
              set: function(_) {
                  console.warn('BoxPlot \'y\' chart option is deprecated. Please use model overrides instead.');
              }
          },
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  nv.models.boxPlotChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var boxplot = nv.models.boxPlot(),
          xAxis = nv.models.axis(),
          yAxis = nv.models.axis();
  
      var margin = {top: 15, right: 10, bottom: 50, left: 60},
          width = null,
          height = null,
          color = nv.utils.getColor(),
          showXAxis = true,
          showYAxis = true,
          rightAlignYAxis = false,
          staggerLabels = false,
          tooltip = nv.models.tooltip(),
          x, y,
          noData = 'No Data Available.',
          dispatch = d3.dispatch('beforeUpdate', 'renderEnd'),
          duration = 250;
  
      xAxis
          .orient('bottom')
          .showMaxMin(false)
          .tickFormat(function(d) { return d })
      ;
      yAxis
          .orient((rightAlignYAxis) ? 'right' : 'left')
          .tickFormat(d3.format(',.1f'))
      ;
  
      tooltip.duration(0);
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(boxplot);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this), that = this;
              nv.utils.initSVG(container);
              var availableWidth = (width  || parseInt(container.style('width')) || 960) - margin.left - margin.right;
              var availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;
  
              chart.update = function() {
                  dispatch.beforeUpdate();
                  container.transition().duration(duration).call(chart);
              };
              chart.container = this;
  
              // TODO still need to find a way to validate quartile data presence using boxPlot callbacks.
              // Display No Data message if there's nothing to show. (quartiles required at minimum).
              if (!data || !data.length) {
                  var noDataText = container.selectAll('.nv-noData').data([noData]);
  
                  noDataText.enter().append('text')
                      .attr('class', 'nvd3 nv-noData')
                      .attr('dy', '-.7em')
                      .style('text-anchor', 'middle');
  
                  noDataText
                      .attr('x', margin.left + availableWidth / 2)
                      .attr('y', margin.top + availableHeight / 2)
                      .text(function(d) { return d });
  
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = boxplot.xScale();
              y = boxplot.yScale().clamp(true);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-boxPlotWithAxes').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-boxPlotWithAxes').append('g');
              var defsEnter = gEnter.append('defs');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis')
                  .append('g').attr('class', 'nv-zeroLine')
                  .append('line');
  
              gEnter.append('g').attr('class', 'nv-barsWrap');
              g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              if (rightAlignYAxis) {
                  g.select('.nv-y.nv-axis')
                      .attr('transform', 'translate(' + availableWidth + ',0)');
              }
  
              // Main Chart Component(s)
              boxplot.width(availableWidth).height(availableHeight);
  
              var barsWrap = g.select('.nv-barsWrap')
                  .datum(data.filter(function(d) { return !d.disabled }))
  
              barsWrap.transition().call(boxplot);
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-x-label-clip-' + boxplot.id())
                  .append('rect');
  
              g.select('#nv-x-label-clip-' + boxplot.id() + ' rect')
                  .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))
                  .attr('height', 16)
                  .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));
  
              // Setup Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize(-availableHeight, 0);
  
                  g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');
                  g.select('.nv-x.nv-axis').call(xAxis);
  
                  var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                  if (staggerLabels) {
                      xTicks
                          .selectAll('text')
                          .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 === 0 ? '5' : '17') + ')' })
                  }
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      .ticks( Math.floor(availableHeight/36) ) // can't use nv.utils.calcTicksY with Object data
                      .tickSize( -availableWidth, 0);
  
                  g.select('.nv-y.nv-axis').call(yAxis);
              }
  
              // Zero line
              g.select('.nv-zeroLine line')
                  .attr('x1',0)
                  .attr('x2',availableWidth)
                  .attr('y1', y(0))
                  .attr('y2', y(0))
              ;
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
          });
  
          renderWatch.renderEnd('nv-boxplot chart immediate');
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      boxplot.dispatch.on('elementMouseover.tooltip', function(evt) {
          tooltip.data(evt).hidden(false);
      });
  
      boxplot.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.data(evt).hidden(true);
      });
  
      boxplot.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.boxplot = boxplot;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
          showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              boxplot.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              boxplot.color(color);
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( (_) ? 'right' : 'left');
          }}
      });
  
      nv.utils.inheritOptions(chart, boxplot);
      nv.utils.initOptions(chart);
  
      return chart;
  }
  
  // Chart design based on the recommendations of Stephen Few. Implementation
  // based on the work of Clint Ivy, Jamie Love, and Jason Davies.
  // http://projects.instantcognition.com/protovis/bulletchart/
  
  nv.models.bullet = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , orient = 'left' // TODO top & bottom
          , reverse = false
          , ranges = function(d) { return d.ranges }
          , markers = function(d) { return d.markers ? d.markers : [] }
          , markerLines = function(d) { return d.markerLines ? d.markerLines : [0] }
          , measures = function(d) { return d.measures }
          , rangeLabels = function(d) { return d.rangeLabels ? d.rangeLabels : [] }
          , markerLabels = function(d) { return d.markerLabels ? d.markerLabels : []  }
          , markerLineLabels = function(d) { return d.markerLineLabels ? d.markerLineLabels : []  }
          , measureLabels = function(d) { return d.measureLabels ? d.measureLabels : []  }
          , forceX = [0] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
          , width = 380
          , height = 30
          , container = null
          , tickFormat = null
          , color = nv.utils.getColor(['#1f77b4'])
          , dispatch = d3.dispatch('elementMouseover', 'elementMouseout', 'elementMousemove')
          , defaultRangeLabels = ["Maximum", "Mean", "Minimum"]
          , legacyRangeClassNames = ["Max", "Avg", "Min"]
          , duration = 1000
          ;
  
      function sortLabels(labels, values){
          var lz = labels.slice();
          labels.sort(function(a, b){
              var iA = lz.indexOf(a);
              var iB = lz.indexOf(b);
              return d3.descending(values[iA], values[iB]);
          });
      };
  
      function chart(selection) {
          selection.each(function(d, i) {
              var availableWidth = width - margin.left - margin.right,
                  availableHeight = height - margin.top - margin.bottom;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
  
              var rangez = ranges.call(this, d, i).slice(),
                  markerz = markers.call(this, d, i).slice(),
                  markerLinez = markerLines.call(this, d, i).slice(),
                  measurez = measures.call(this, d, i).slice(),
                  rangeLabelz = rangeLabels.call(this, d, i).slice(),
                  markerLabelz = markerLabels.call(this, d, i).slice(),
                  markerLineLabelz = markerLineLabels.call(this, d, i).slice(),
                  measureLabelz = measureLabels.call(this, d, i).slice();
  
              // Sort labels according to their sorted values
              sortLabels(rangeLabelz, rangez);
              sortLabels(markerLabelz, markerz);
              sortLabels(markerLineLabelz, markerLinez);
              sortLabels(measureLabelz, measurez);
  
              // sort values descending
              rangez.sort(d3.descending);
              markerz.sort(d3.descending);
              markerLinez.sort(d3.descending);
              measurez.sort(d3.descending);
  
              // Setup Scales
              // Compute the new x-scale.
              var x1 = d3.scale.linear()
                  .domain( d3.extent(d3.merge([forceX, rangez])) )
                  .range(reverse ? [availableWidth, 0] : [0, availableWidth]);
  
              // Retrieve the old x-scale, if this is an update.
              var x0 = this.__chart__ || d3.scale.linear()
                  .domain([0, Infinity])
                  .range(x1.range());
  
              // Stash the new scale.
              this.__chart__ = x1;
  
              var rangeMin = d3.min(rangez), //rangez[2]
                  rangeMax = d3.max(rangez), //rangez[0]
                  rangeAvg = rangez[1];
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-bullet').data([d]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bullet');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              for(var i=0,il=rangez.length; i<il; i++){
                  var rangeClassNames = 'nv-range nv-range'+i;
                  if(i <= 2){
                      rangeClassNames = rangeClassNames + ' nv-range'+legacyRangeClassNames[i];
                  }
                  gEnter.append('rect').attr('class', rangeClassNames);
              }
  
              gEnter.append('rect').attr('class', 'nv-measure');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)
                  w1 = function(d) { return Math.abs(x1(d) - x1(0)) };
              var xp0 = function(d) { return d < 0 ? x0(d) : x0(0) },
                  xp1 = function(d) { return d < 0 ? x1(d) : x1(0) };
  
              for(var i=0,il=rangez.length; i<il; i++){
                  var range = rangez[i];
                  g.select('rect.nv-range'+i)
                      .datum(range)
                      .attr('height', availableHeight)
                      .transition()
                      .duration(duration)
                      .attr('width', w1(range))
                      .attr('x', xp1(range))
              }
  
              g.select('rect.nv-measure')
                  .style('fill', color)
                  .attr('height', availableHeight / 3)
                  .attr('y', availableHeight / 3)
                  .on('mouseover', function() {
                      dispatch.elementMouseover({
                          value: measurez[0],
                          label: measureLabelz[0] || 'Current',
                          color: d3.select(this).style("fill")
                      })
                  })
                  .on('mousemove', function() {
                      dispatch.elementMousemove({
                          value: measurez[0],
                          label: measureLabelz[0] || 'Current',
                          color: d3.select(this).style("fill")
                      })
                  })
                  .on('mouseout', function() {
                      dispatch.elementMouseout({
                          value: measurez[0],
                          label: measureLabelz[0] || 'Current',
                          color: d3.select(this).style("fill")
                      })
                  })
                  .transition()
                  .duration(duration)
                  .attr('width', measurez < 0 ?
                      x1(0) - x1(measurez[0])
                      : x1(measurez[0]) - x1(0))
                  .attr('x', xp1(measurez));
  
              var h3 =  availableHeight / 6;
  
              var markerData = markerz.map( function(marker, index) {
                  return {value: marker, label: markerLabelz[index]}
              });
              gEnter
                .selectAll("path.nv-markerTriangle")
                .data(markerData)
                .enter()
                .append('path')
                .attr('class', 'nv-markerTriangle')
                .attr('d', 'M0,' + h3 + 'L' + h3 + ',' + (-h3) + ' ' + (-h3) + ',' + (-h3) + 'Z')
                .on('mouseover', function(d) {
                  dispatch.elementMouseover({
                    value: d.value,
                    label: d.label || 'Previous',
                    color: d3.select(this).style("fill"),
                    pos: [x1(d.value), availableHeight/2]
                  })
  
                })
                .on('mousemove', function(d) {
                    dispatch.elementMousemove({
                        value: d.value,
                        label: d.label || 'Previous',
                        color: d3.select(this).style("fill")
                    })
                })
                .on('mouseout', function(d, i) {
                    dispatch.elementMouseout({
                        value: d.value,
                        label: d.label || 'Previous',
                        color: d3.select(this).style("fill")
                    })
                });
  
              g.selectAll("path.nv-markerTriangle")
                .data(markerData)
                .transition()
                .duration(duration)
                .attr('transform', function(d) { return 'translate(' + x1(d.value) + ',' + (availableHeight / 2) + ')' });
  
              var markerLinesData = markerLinez.map( function(marker, index) {
                  return {value: marker, label: markerLineLabelz[index]}
              });
              gEnter
                .selectAll("line.nv-markerLine")
                .data(markerLinesData)
                .enter()
                .append('line')
                .attr('cursor', '')
                .attr('class', 'nv-markerLine')
                .attr('x1', function(d) { return x1(d.value) })
                .attr('y1', '2')
                .attr('x2', function(d) { return x1(d.value) })
                .attr('y2', availableHeight - 2)
                .on('mouseover', function(d) {
                  dispatch.elementMouseover({
                    value: d.value,
                    label: d.label || 'Previous',
                    color: d3.select(this).style("fill"),
                    pos: [x1(d.value), availableHeight/2]
                  })
  
                })
                .on('mousemove', function(d) {
                    dispatch.elementMousemove({
                        value: d.value,
                        label: d.label || 'Previous',
                        color: d3.select(this).style("fill")
                    })
                })
                .on('mouseout', function(d, i) {
                    dispatch.elementMouseout({
                        value: d.value,
                        label: d.label || 'Previous',
                        color: d3.select(this).style("fill")
                    })
                });
  
              g.selectAll("line.nv-markerLine")
                .data(markerLinesData)
                .transition()
                .duration(duration)
                .attr('x1', function(d) { return x1(d.value) })
                .attr('x2', function(d) { return x1(d.value) });
  
              wrap.selectAll('.nv-range')
                  .on('mouseover', function(d,i) {
                      var label = rangeLabelz[i] || defaultRangeLabels[i];
                      dispatch.elementMouseover({
                          value: d,
                          label: label,
                          color: d3.select(this).style("fill")
                      })
                  })
                  .on('mousemove', function() {
                      dispatch.elementMousemove({
                          value: measurez[0],
                          label: measureLabelz[0] || 'Previous',
                          color: d3.select(this).style("fill")
                      })
                  })
                  .on('mouseout', function(d,i) {
                      var label = rangeLabelz[i] || defaultRangeLabels[i];
                      dispatch.elementMouseout({
                          value: d,
                          label: label,
                          color: d3.select(this).style("fill")
                      })
                  });
          });
  
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          ranges:      {get: function(){return ranges;}, set: function(_){ranges=_;}}, // ranges (bad, satisfactory, good)
          markers:     {get: function(){return markers;}, set: function(_){markers=_;}}, // markers (previous, goal)
          measures: {get: function(){return measures;}, set: function(_){measures=_;}}, // measures (actual, forecast)
          forceX:      {get: function(){return forceX;}, set: function(_){forceX=_;}},
          width:    {get: function(){return width;}, set: function(_){width=_;}},
          height:    {get: function(){return height;}, set: function(_){height=_;}},
          tickFormat:    {get: function(){return tickFormat;}, set: function(_){tickFormat=_;}},
          duration:    {get: function(){return duration;}, set: function(_){duration=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          orient: {get: function(){return orient;}, set: function(_){ // left, right, top, bottom
              orient = _;
              reverse = orient == 'right' || orient == 'bottom';
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }}
      });
  
      nv.utils.initOptions(chart);
      return chart;
  };
  
  
  
  // Chart design based on the recommendations of Stephen Few. Implementation
  // based on the work of Clint Ivy, Jamie Love, and Jason Davies.
  // http://projects.instantcognition.com/protovis/bulletchart/
  nv.models.bulletChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var bullet = nv.models.bullet();
      var tooltip = nv.models.tooltip();
  
      var orient = 'left' // TODO top & bottom
          , reverse = false
          , margin = {top: 5, right: 40, bottom: 20, left: 120}
          , ranges = function(d) { return d.ranges }
          , markers = function(d) { return d.markers ? d.markers : [] }
          , measures = function(d) { return d.measures }
          , width = null
          , height = 55
          , tickFormat = null
          , ticks = null
          , noData = null
          , dispatch = d3.dispatch()
          ;
  
      tooltip
          .duration(0)
          .headerEnabled(false);
  
      function chart(selection) {
          selection.each(function(d, i) {
              var container = d3.select(this);
              nv.utils.initSVG(container);
  
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = height - margin.top - margin.bottom,
                  that = this;
  
              chart.update = function() { chart(selection) };
              chart.container = this;
  
              // Display No Data message if there's nothing to show.
              if (!d || !ranges.call(this, d, i)) {
                  nv.utils.noData(chart, container)
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              var rangez = ranges.call(this, d, i).slice().sort(d3.descending),
                  markerz = markers.call(this, d, i).slice().sort(d3.descending),
                  measurez = measures.call(this, d, i).slice().sort(d3.descending);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-bulletChart').data([d]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bulletChart');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-bulletWrap');
              gEnter.append('g').attr('class', 'nv-titles');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              // Compute the new x-scale.
              var x1 = d3.scale.linear()
                  .domain([0, Math.max(rangez[0], (markerz[0] || 0), measurez[0])])  // TODO: need to allow forceX and forceY, and xDomain, yDomain
                  .range(reverse ? [availableWidth, 0] : [0, availableWidth]);
  
              // Retrieve the old x-scale, if this is an update.
              var x0 = this.__chart__ || d3.scale.linear()
                  .domain([0, Infinity])
                  .range(x1.range());
  
              // Stash the new scale.
              this.__chart__ = x1;
  
              var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)
                  w1 = function(d) { return Math.abs(x1(d) - x1(0)) };
  
              var title = gEnter.select('.nv-titles').append('g')
                  .attr('text-anchor', 'end')
                  .attr('transform', 'translate(-6,' + (height - margin.top - margin.bottom) / 2 + ')');
              title.append('text')
                  .attr('class', 'nv-title')
                  .text(function(d) { return d.title; });
  
              title.append('text')
                  .attr('class', 'nv-subtitle')
                  .attr('dy', '1em')
                  .text(function(d) { return d.subtitle; });
  
              bullet
                  .width(availableWidth)
                  .height(availableHeight);
  
              var bulletWrap = g.select('.nv-bulletWrap');
              d3.transition(bulletWrap).call(bullet);
  
              // Compute the tick format.
              var format = tickFormat || x1.tickFormat( availableWidth / 100 );
  
              // Update the tick groups.
              var tick = g.selectAll('g.nv-tick')
                  .data(x1.ticks( ticks ? ticks : (availableWidth / 50) ), function(d) {
                      return this.textContent || format(d);
                  });
  
              // Initialize the ticks with the old scale, x0.
              var tickEnter = tick.enter().append('g')
                  .attr('class', 'nv-tick')
                  .attr('transform', function(d) { return 'translate(' + x0(d) + ',0)' })
                  .style('opacity', 1e-6);
  
              tickEnter.append('line')
                  .attr('y1', availableHeight)
                  .attr('y2', availableHeight * 7 / 6);
  
              tickEnter.append('text')
                  .attr('text-anchor', 'middle')
                  .attr('dy', '1em')
                  .attr('y', availableHeight * 7 / 6)
                  .text(format);
  
              // Transition the updating ticks to the new scale, x1.
              var tickUpdate = d3.transition(tick)
                  .transition()
                  .duration(bullet.duration())
                  .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })
                  .style('opacity', 1);
  
              tickUpdate.select('line')
                  .attr('y1', availableHeight)
                  .attr('y2', availableHeight * 7 / 6);
  
              tickUpdate.select('text')
                  .attr('y', availableHeight * 7 / 6);
  
              // Transition the exiting ticks to the new scale, x1.
              d3.transition(tick.exit())
                  .transition()
                  .duration(bullet.duration())
                  .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })
                  .style('opacity', 1e-6)
                  .remove();
          });
  
          d3.timer.flush();
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      bullet.dispatch.on('elementMouseover.tooltip', function(evt) {
          evt['series'] = {
              key: evt.label,
              value: evt.value,
              color: evt.color
          };
          tooltip.data(evt).hidden(false);
      });
  
      bullet.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      bullet.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.bullet = bullet;
      chart.dispatch = dispatch;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          ranges:      {get: function(){return ranges;}, set: function(_){ranges=_;}}, // ranges (bad, satisfactory, good)
          markers:     {get: function(){return markers;}, set: function(_){markers=_;}}, // markers (previous, goal)
          measures: {get: function(){return measures;}, set: function(_){measures=_;}}, // measures (actual, forecast)
          width:    {get: function(){return width;}, set: function(_){width=_;}},
          height:    {get: function(){return height;}, set: function(_){height=_;}},
          tickFormat:    {get: function(){return tickFormat;}, set: function(_){tickFormat=_;}},
          ticks:    {get: function(){return ticks;}, set: function(_){ticks=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          orient: {get: function(){return orient;}, set: function(_){ // left, right, top, bottom
              orient = _;
              reverse = orient == 'right' || orient == 'bottom';
          }}
      });
  
      nv.utils.inheritOptions(chart, bullet);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  
  
  nv.models.candlestickBar = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = null
          , height = null
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container
          , x = d3.scale.linear()
          , y = d3.scale.linear()
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , getOpen = function(d) { return d.open }
          , getClose = function(d) { return d.close }
          , getHigh = function(d) { return d.high }
          , getLow = function(d) { return d.low }
          , forceX = []
          , forceY = []
          , padData     = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
          , clipEdge = true
          , color = nv.utils.defaultColor()
          , interactive = false
          , xDomain
          , yDomain
          , xRange
          , yRange
          , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd', 'chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove')
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      function chart(selection) {
          selection.each(function(data) {
              container = d3.select(this);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              nv.utils.initSVG(container);
  
              // Width of the candlestick bars.
              var barWidth = (availableWidth / data[0].values.length) * .45;
  
              // Setup Scales
              x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));
  
              if (padData)
                  x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
              else
                  x.range(xRange || [5 + barWidth / 2, availableWidth - barWidth / 2 - 5]);
  
              y.domain(yDomain || [
                      d3.min(data[0].values.map(getLow).concat(forceY)),
                      d3.max(data[0].values.map(getHigh).concat(forceY))
                  ]
              ).range(yRange || [availableHeight, 0]);
  
              // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
              if (x.domain()[0] === x.domain()[1])
                  x.domain()[0] ?
                      x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                      : x.domain([-1,1]);
  
              if (y.domain()[0] === y.domain()[1])
                  y.domain()[0] ?
                      y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                      : y.domain([-1,1]);
  
              // Setup containers and skeleton of chart
              var wrap = d3.select(this).selectAll('g.nv-wrap.nv-candlestickBar').data([data[0].values]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-candlestickBar');
              var defsEnter = wrapEnter.append('defs');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-ticks');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              container
                  .on('click', function(d,i) {
                      dispatch.chartClick({
                          data: d,
                          index: i,
                          pos: d3.event,
                          id: id
                      });
                  });
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-chart-clip-path-' + id)
                  .append('rect');
  
              wrap.select('#nv-chart-clip-path-' + id + ' rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              g   .attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');
  
              var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick')
                  .data(function(d) { return d });
              ticks.exit().remove();
  
              var tickGroups = ticks.enter().append('g');
  
              // The colors are currently controlled by CSS.
              ticks
                  .attr('class', function(d, i, j) { return (getOpen(d, i) > getClose(d, i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i});
  
              var lines = tickGroups.append('line')
                  .attr('class', 'nv-candlestick-lines')
                  .attr('transform', function(d, i) { return 'translate(' + x(getX(d, i)) + ',0)'; })
                  .attr('x1', 0)
                  .attr('y1', function(d, i) { return y(getHigh(d, i)); })
                  .attr('x2', 0)
                  .attr('y2', function(d, i) { return y(getLow(d, i)); });
  
              var rects = tickGroups.append('rect')
                  .attr('class', 'nv-candlestick-rects nv-bars')
                  .attr('transform', function(d, i) {
                      return 'translate(' + (x(getX(d, i)) - barWidth/2) + ','
                      + (y(getY(d, i)) - (getOpen(d, i) > getClose(d, i) ? (y(getClose(d, i)) - y(getOpen(d, i))) : 0))
                      + ')';
                  })
                  .attr('x', 0)
                  .attr('y', 0)
                  .attr('width', barWidth)
                  .attr('height', function(d, i) {
                      var open = getOpen(d, i);
                      var close = getClose(d, i);
                      return open > close ? y(close) - y(open) : y(open) - y(close);
                  });
  
              ticks.select('.nv-candlestick-lines').transition()
                  .attr('transform', function(d, i) { return 'translate(' + x(getX(d, i)) + ',0)'; })
                  .attr('x1', 0)
                  .attr('y1', function(d, i) { return y(getHigh(d, i)); })
                  .attr('x2', 0)
                  .attr('y2', function(d, i) { return y(getLow(d, i)); });
  
              ticks.select('.nv-candlestick-rects').transition()
                  .attr('transform', function(d, i) {
                      return 'translate(' + (x(getX(d, i)) - barWidth/2) + ','
                      + (y(getY(d, i)) - (getOpen(d, i) > getClose(d, i) ? (y(getClose(d, i)) - y(getOpen(d, i))) : 0))
                      + ')';
                  })
                  .attr('x', 0)
                  .attr('y', 0)
                  .attr('width', barWidth)
                  .attr('height', function(d, i) {
                      var open = getOpen(d, i);
                      var close = getClose(d, i);
                      return open > close ? y(close) - y(open) : y(open) - y(close);
                  });
          });
  
          return chart;
      }
  
  
      //Create methods to allow outside functions to highlight a specific bar.
      chart.highlightPoint = function(pointIndex, isHoverOver) {
          chart.clearHighlights();
          container.select(".nv-candlestickBar .nv-tick-0-" + pointIndex)
              .classed("hover", isHoverOver)
          ;
      };
  
      chart.clearHighlights = function() {
          container.select(".nv-candlestickBar .nv-tick.hover")
              .classed("hover", false)
          ;
      };
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:    {get: function(){return width;}, set: function(_){width=_;}},
          height:   {get: function(){return height;}, set: function(_){height=_;}},
          xScale:   {get: function(){return x;}, set: function(_){x=_;}},
          yScale:   {get: function(){return y;}, set: function(_){y=_;}},
          xDomain:  {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain:  {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:   {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:   {get: function(){return yRange;}, set: function(_){yRange=_;}},
          forceX:   {get: function(){return forceX;}, set: function(_){forceX=_;}},
          forceY:   {get: function(){return forceY;}, set: function(_){forceY=_;}},
          padData:  {get: function(){return padData;}, set: function(_){padData=_;}},
          clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
          id:       {get: function(){return id;}, set: function(_){id=_;}},
          interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},
  
          x:     {get: function(){return getX;}, set: function(_){getX=_;}},
          y:     {get: function(){return getY;}, set: function(_){getY=_;}},
          open:  {get: function(){return getOpen();}, set: function(_){getOpen=_;}},
          close: {get: function(){return getClose();}, set: function(_){getClose=_;}},
          high:  {get: function(){return getHigh;}, set: function(_){getHigh=_;}},
          low:   {get: function(){return getLow;}, set: function(_){getLow=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    != undefined ? _.top    : margin.top;
              margin.right  = _.right  != undefined ? _.right  : margin.right;
              margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   != undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }}
      });
  
      nv.utils.initOptions(chart);
      return chart;
  };
  
  nv.models.cumulativeLineChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var lines = nv.models.line()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
          , legend = nv.models.legend()
          , controls = nv.models.legend()
          , interactiveLayer = nv.interactiveGuideline()
          , tooltip = nv.models.tooltip()
          ;
  
      var margin = {top: 30, right: 30, bottom: 50, left: 60}
          , marginTop = null
          , color = nv.utils.defaultColor()
          , width = null
          , height = null
          , showLegend = true
          , showXAxis = true
          , showYAxis = true
          , rightAlignYAxis = false
          , showControls = true
          , useInteractiveGuideline = false
          , rescaleY = true
          , x //can be accessed via chart.xScale()
          , y //can be accessed via chart.yScale()
          , id = lines.id()
          , state = nv.utils.state()
          , defaultState = null
          , noData = null
          , average = function(d) { return d.average }
          , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd')
          , transitionDuration = 250
          , duration = 250
          , noErrorCheck = false  //if set to TRUE, will bypass an error check in the indexify function.
          ;
  
      state.index = 0;
      state.rescaleY = rescaleY;
  
      xAxis.orient('bottom').tickPadding(7);
      yAxis.orient((rightAlignYAxis) ? 'right' : 'left');
  
      tooltip.valueFormatter(function(d, i) {
          return yAxis.tickFormat()(d, i);
      }).headerFormatter(function(d, i) {
          return xAxis.tickFormat()(d, i);
      });
  
      controls.updateState(false);
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var dx = d3.scale.linear()
          , index = {i: 0, x: 0}
          , renderWatch = nv.utils.renderWatch(dispatch, duration)
          , currentYDomain
          ;
  
      var stateGetter = function(data) {
          return function(){
              return {
                  active: data.map(function(d) { return !d.disabled }),
                  index: index.i,
                  rescaleY: rescaleY
              };
          }
      };
  
      var stateSetter = function(data) {
          return function(state) {
              if (state.index !== undefined)
                  index.i = state.index;
              if (state.rescaleY !== undefined)
                  rescaleY = state.rescaleY;
              if (state.active !== undefined)
                  data.forEach(function(series,i) {
                      series.disabled = !state.active[i];
                  });
          }
      };
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(lines);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
          selection.each(function(data) {
              var container = d3.select(this);
              nv.utils.initSVG(container);
              container.classed('nv-chart-' + id, true);
              var that = this;
  
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() {
                  if (duration === 0)
                      container.call(chart);
                  else
                      container.transition().duration(duration).call(chart)
              };
              chart.container = this;
  
              state
                  .setter(stateSetter(data), chart.update)
                  .getter(stateGetter(data))
                  .update();
  
              // DEPRECATED set state.disableddisabled
              state.disabled = data.map(function(d) { return !!d.disabled });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              var indexDrag = d3.behavior.drag()
                  .on('dragstart', dragStart)
                  .on('drag', dragMove)
                  .on('dragend', dragEnd);
  
  
              function dragStart(d,i) {
                  d3.select(chart.container)
                      .style('cursor', 'ew-resize');
              }
  
              function dragMove(d,i) {
                  index.x = d3.event.x;
                  index.i = Math.round(dx.invert(index.x));
                  updateZero();
              }
  
              function dragEnd(d,i) {
                  d3.select(chart.container)
                      .style('cursor', 'auto');
  
                  // update state and send stateChange with new index
                  state.index = index.i;
                  dispatch.stateChange(state);
              }
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container)
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = lines.xScale();
              y = lines.yScale();
  
  
              dx.domain([0, data[0].values.length - 1]) //Assumes all series have same length
                  .range([0, availableWidth])
                  .clamp(true);
  
              var data = indexify(index.i, data);
  
              // initialize the starting yDomain for the not-rescale case after indexify (to have calculated point.display)
              if (typeof(currentYDomain) === "undefined") {
                  currentYDomain = getCurrentYDomain(data);
              }
  
              if (!rescaleY) {
                  lines.yDomain(currentYDomain);
                  lines.clipEdge(true);
              } else {
                  lines.yDomain(null);
              }
  
              // Setup containers and skeleton of chart
              var interactivePointerEvents = (useInteractiveGuideline) ? "none" : "all";
              var wrap = container.selectAll('g.nv-wrap.nv-cumulativeLine').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-cumulativeLine').append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-interactive');
              gEnter.append('g').attr('class', 'nv-x nv-axis').style("pointer-events","none");
              gEnter.append('g').attr('class', 'nv-y nv-axis');
              gEnter.append('g').attr('class', 'nv-background');
              gEnter.append('g').attr('class', 'nv-linesWrap').style("pointer-events",interactivePointerEvents);
              gEnter.append('g').attr('class', 'nv-avgLinesWrap').style("pointer-events","none");
              gEnter.append('g').attr('class', 'nv-legendWrap');
              gEnter.append('g').attr('class', 'nv-controlsWrap');
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  legend.width(availableWidth);
  
                  g.select('.nv-legendWrap')
                      .datum(data)
                      .call(legend);
  
                  if (!marginTop && legend.height() !== margin.top) {
                      margin.top = legend.height();
                      availableHeight = nv.utils.availableHeight(height, container, margin);
                  }
  
                  g.select('.nv-legendWrap')
                      .attr('transform', 'translate(0,' + (-margin.top) +')')
              }
  
              // Controls
              if (!showControls) {
                   g.select('.nv-controlsWrap').selectAll('*').remove();
              } else {
                  var controlsData = [
                      { key: 'Re-scale y-axis', disabled: !rescaleY }
                  ];
  
                  controls
                      .width(140)
                      .color(['#444', '#444', '#444'])
                      .rightAlign(false)
                      .margin({top: 5, right: 0, bottom: 5, left: 20})
                  ;
  
                  g.select('.nv-controlsWrap')
                      .datum(controlsData)
                      .attr('transform', 'translate(0,' + (-margin.top) +')')
                      .call(controls);
              }
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              if (rightAlignYAxis) {
                  g.select(".nv-y.nv-axis")
                      .attr("transform", "translate(" + availableWidth + ",0)");
              }
  
              // Show error if index point value is 0 (division by zero avoided)
              var tempDisabled = data.filter(function(d) { return d.tempDisabled });
  
              wrap.select('.tempDisabled').remove(); //clean-up and prevent duplicates
              if (tempDisabled.length) {
                  wrap.append('text').attr('class', 'tempDisabled')
                      .attr('x', availableWidth / 2)
                      .attr('y', '-.71em')
                      .style('text-anchor', 'end')
                      .text(tempDisabled.map(function(d) { return d.key }).join(', ') + ' values cannot be calculated for this time period.');
              }
  
              //Set up interactive layer
              if (useInteractiveGuideline) {
                  interactiveLayer
                      .width(availableWidth)
                      .height(availableHeight)
                      .margin({left:margin.left,top:margin.top})
                      .svgContainer(container)
                      .xScale(x);
                  wrap.select(".nv-interactive").call(interactiveLayer);
              }
  
              gEnter.select('.nv-background')
                  .append('rect');
  
              g.select('.nv-background rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              lines
                  //.x(function(d) { return d.x })
                  .y(function(d) { return d.display.y })
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled && !data[i].tempDisabled; }));
  
              var linesWrap = g.select('.nv-linesWrap')
                  .datum(data.filter(function(d) { return  !d.disabled && !d.tempDisabled }));
  
              linesWrap.call(lines);
  
              //Store a series index number in the data array.
              data.forEach(function(d,i) {
                  d.seriesIndex = i;
              });
  
              var avgLineData = data.filter(function(d) {
                  return !d.disabled && !!average(d);
              });
  
              var avgLines = g.select(".nv-avgLinesWrap").selectAll("line")
                  .data(avgLineData, function(d) { return d.key; });
  
              var getAvgLineY = function(d) {
                  //If average lines go off the svg element, clamp them to the svg bounds.
                  var yVal = y(average(d));
                  if (yVal < 0) return 0;
                  if (yVal > availableHeight) return availableHeight;
                  return yVal;
              };
  
              avgLines.enter()
                  .append('line')
                  .style('stroke-width',2)
                  .style('stroke-dasharray','10,10')
                  .style('stroke',function (d,i) {
                      return lines.color()(d,d.seriesIndex);
                  })
                  .attr('x1',0)
                  .attr('x2',availableWidth)
                  .attr('y1', getAvgLineY)
                  .attr('y2', getAvgLineY);
  
              avgLines
                  .style('stroke-opacity',function(d){
                      //If average lines go offscreen, make them transparent
                      var yVal = y(average(d));
                      if (yVal < 0 || yVal > availableHeight) return 0;
                      return 1;
                  })
                  .attr('x1',0)
                  .attr('x2',availableWidth)
                  .attr('y1', getAvgLineY)
                  .attr('y2', getAvgLineY);
  
              avgLines.exit().remove();
  
              //Create index line
              var indexLine = linesWrap.selectAll('.nv-indexLine')
                  .data([index]);
              indexLine.enter().append('rect').attr('class', 'nv-indexLine')
                  .attr('width', 3)
                  .attr('x', -2)
                  .attr('fill', 'red')
                  .attr('fill-opacity', .5)
                  .style("pointer-events","all")
                  .call(indexDrag);
  
              indexLine
                  .attr('transform', function(d) { return 'translate(' + dx(d.i) + ',0)' })
                  .attr('height', availableHeight);
  
              // Setup Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      ._ticks( nv.utils.calcTicksX(availableWidth/70, data) )
                      .tickSize(-availableHeight, 0);
  
                  g.select('.nv-x.nv-axis')
                      .attr('transform', 'translate(0,' + y.range()[0] + ')');
                  g.select('.nv-x.nv-axis')
                      .call(xAxis);
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                      .tickSize( -availableWidth, 0);
  
                  g.select('.nv-y.nv-axis')
                      .call(yAxis);
              }
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              function updateZero() {
                  indexLine
                      .data([index]);
  
                  //When dragging the index line, turn off line transitions.
                  // Then turn them back on when done dragging.
                  var oldDuration = chart.duration();
                  chart.duration(0);
                  chart.update();
                  chart.duration(oldDuration);
              }
  
              g.select('.nv-background rect')
                  .on('click', function() {
                      index.x = d3.mouse(this)[0];
                      index.i = Math.round(dx.invert(index.x));
  
                      // update state and send stateChange with new index
                      state.index = index.i;
                      dispatch.stateChange(state);
  
                      updateZero();
                  });
  
              lines.dispatch.on('elementClick', function(e) {
                  index.i = e.pointIndex;
                  index.x = dx(index.i);
  
                  // update state and send stateChange with new index
                  state.index = index.i;
                  dispatch.stateChange(state);
  
                  updateZero();
              });
  
              controls.dispatch.on('legendClick', function(d,i) {
                  d.disabled = !d.disabled;
                  rescaleY = !d.disabled;
                  state.rescaleY = rescaleY;
                  if (!rescaleY) {
                      currentYDomain = getCurrentYDomain(data); // rescale is turned off, so set the currentYDomain
                  }
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              legend.dispatch.on('stateChange', function(newState) {
                  for (var key in newState)
                      state[key] = newState[key];
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              interactiveLayer.dispatch.on('elementMousemove', function(e) {
                  lines.clearHighlights();
                  var singlePoint, pointIndex, pointXLocation, allData = [];
  
                  data
                      .filter(function(series, i) {
                          series.seriesIndex = i;
                          return !(series.disabled || series.tempDisabled);
                      })
                      .forEach(function(series,i) {
                          pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                          lines.highlightPoint(i, pointIndex, true);
                          var point = series.values[pointIndex];
                          if (typeof point === 'undefined') return;
                          if (typeof singlePoint === 'undefined') singlePoint = point;
                          if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                          allData.push({
                              key: series.key,
                              value: chart.y()(point, pointIndex),
                              color: color(series,series.seriesIndex)
                          });
                      });
  
                  //Highlight the tooltip entry based on which point the mouse is closest to.
                  if (allData.length > 2) {
                      var yValue = chart.yScale().invert(e.mouseY);
                      var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                      var threshold = 0.03 * domainExtent;
                      var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
                      if (indexToHighlight !== null)
                          allData[indexToHighlight].highlight = true;
                  }
  
                  var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex), pointIndex);
                  interactiveLayer.tooltip
                      .valueFormatter(function(d,i) {
                          return yAxis.tickFormat()(d);
                      })
                      .data(
                      {
                          value: xValue,
                          series: allData
                      }
                  )();
  
                  interactiveLayer.renderGuideLine(pointXLocation);
              });
  
              interactiveLayer.dispatch.on("elementMouseout",function(e) {
                  lines.clearHighlights();
              });
  
              // Update chart from a state object passed to event handler
              dispatch.on('changeState', function(e) {
                  if (typeof e.disabled !== 'undefined') {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
  
                      state.disabled = e.disabled;
                  }
  
                  if (typeof e.index !== 'undefined') {
                      index.i = e.index;
                      index.x = dx(index.i);
  
                      state.index = e.index;
  
                      indexLine
                          .data([index]);
                  }
  
                  if (typeof e.rescaleY !== 'undefined') {
                      rescaleY = e.rescaleY;
                  }
  
                  chart.update();
              });
  
          });
  
          renderWatch.renderEnd('cumulativeLineChart immediate');
  
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      lines.dispatch.on('elementMouseover.tooltip', function(evt) {
          var point = {
              x: chart.x()(evt.point),
              y: chart.y()(evt.point),
              color: evt.point.color
          };
          evt.point = point;
          tooltip.data(evt).hidden(false);
      });
  
      lines.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true)
      });
  
      //============================================================
      // Functions
      //------------------------------------------------------------
  
      var indexifyYGetter = null;
      /* Normalize the data according to an index point. */
      function indexify(idx, data) {
          if (!indexifyYGetter) indexifyYGetter = lines.y();
          return data.map(function(line, i) {
              if (!line.values) {
                  return line;
              }
              var indexValue = line.values[idx];
              if (indexValue == null) {
                  return line;
              }
              var v = indexifyYGetter(indexValue, idx);
  
              // avoid divide by zero
              if (Math.abs(v) < 0.00001 && !noErrorCheck) {
                  line.tempDisabled = true;
                  return line;
              }
  
              line.tempDisabled = false;
  
              line.values = line.values.map(function(point, pointIndex) {
                  point.display = {'y': (indexifyYGetter(point, pointIndex) - v) / v };
                  return point;
              });
  
              return line;
          })
      }
  
      function getCurrentYDomain(data) {
          var seriesDomains = data
              .filter(function(series) { return !(series.disabled || series.tempDisabled)})
              .map(function(series,i) {
                  return d3.extent(series.values, function (d) { return d.display.y });
              });
  
          return [
              d3.min(seriesDomains, function(d) { return d[0] }),
              d3.max(seriesDomains, function(d) { return d[1] })
          ];
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.lines = lines;
      chart.legend = legend;
      chart.controls = controls;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.interactiveLayer = interactiveLayer;
      chart.state = state;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showControls:     {get: function(){return showControls;}, set: function(_){showControls=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          average: {get: function(){return average;}, set: function(_){average=_;}},
          defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
          showXAxis:    {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          noErrorCheck:    {get: function(){return noErrorCheck;}, set: function(_){noErrorCheck=_;}},
  
          // options that require extra logic in the setter
          rescaleY:     {get: function(){return rescaleY;}, set: function(_){
              rescaleY = _;
              chart.state.rescaleY = _; // also update state
          }},
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              legend.color(color);
          }},
          useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
              useInteractiveGuideline = _;
              if (_ === true) {
                  chart.interactive(false);
                  chart.useVoronoi(false);
              }
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( (_) ? 'right' : 'left');
          }},
          duration:    {get: function(){return duration;}, set: function(_){
              duration = _;
              lines.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
              renderWatch.reset(duration);
          }}
      });
  
      nv.utils.inheritOptions(chart, lines);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  //TODO: consider deprecating by adding necessary features to multiBar model
  nv.models.discreteBar = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 960
          , height = 500
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container
          , x = d3.scale.ordinal()
          , y = d3.scale.linear()
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
          , color = nv.utils.defaultColor()
          , showValues = false
          , valueFormat = d3.format(',.2f')
          , xDomain
          , yDomain
          , xRange
          , yRange
          , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')
          , rectClass = 'discreteBar'
          , duration = 250
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var x0, y0;
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right,
                  availableHeight = height - margin.top - margin.bottom;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
  
              //add series index to each data point for reference
              data.forEach(function(series, i) {
                  series.values.forEach(function(point) {
                      point.series = i;
                  });
              });
  
              // Setup Scales
              // remap and flatten the data for use in calculating the scales' domains
              var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                  data.map(function(d) {
                      return d.values.map(function(d,i) {
                          return { x: getX(d,i), y: getY(d,i), y0: d.y0 }
                      })
                  });
  
              x   .domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                  .rangeBands(xRange || [0, availableWidth], .1);
              y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return d.y }).concat(forceY)));
  
              // If showValues, pad the Y axis range to account for label height
              if (showValues) y.range(yRange || [availableHeight - (y.domain()[0] < 0 ? 12 : 0), y.domain()[1] > 0 ? 12 : 0]);
              else y.range(yRange || [availableHeight, 0]);
  
              //store old scales if they exist
              x0 = x0 || x;
              y0 = y0 || y.copy().range([y(0),y(0)]);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-discretebar').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discretebar');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-groups');
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              //TODO: by definition, the discrete bar should not have multiple groups, will modify/remove later
              var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                  .data(function(d) { return d }, function(d) { return d.key });
              groups.enter().append('g')
                  .style('stroke-opacity', 1e-6)
                  .style('fill-opacity', 1e-6);
              groups.exit()
                  .watchTransition(renderWatch, 'discreteBar: exit groups')
                  .style('stroke-opacity', 1e-6)
                  .style('fill-opacity', 1e-6)
                  .remove();
              groups
                  .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                  .classed('hover', function(d) { return d.hover });
              groups
                  .watchTransition(renderWatch, 'discreteBar: groups')
                  .style('stroke-opacity', 1)
                  .style('fill-opacity', .75);
  
              var bars = groups.selectAll('g.nv-bar')
                  .data(function(d) { return d.values });
              bars.exit().remove();
  
              var barsEnter = bars.enter().append('g')
                  .attr('transform', function(d,i,j) {
                      return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 ) + ', ' + y(0) + ')'
                  })
                  .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
                      d3.select(this).classed('hover', true);
                      dispatch.elementMouseover({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('mouseout', function(d,i) {
                      d3.select(this).classed('hover', false);
                      dispatch.elementMouseout({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('mousemove', function(d,i) {
                      dispatch.elementMousemove({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('click', function(d,i) {
                      var element = this;
                      dispatch.elementClick({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill"),
                          event: d3.event,
                          element: element
                      });
                      d3.event.stopPropagation();
                  })
                  .on('dblclick', function(d,i) {
                      dispatch.elementDblClick({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                      d3.event.stopPropagation();
                  });
  
              barsEnter.append('rect')
                  .attr('height', 0)
                  .attr('width', x.rangeBand() * .9 / data.length )
  
              if (showValues) {
                  barsEnter.append('text')
                      .attr('text-anchor', 'middle')
                  ;
  
                  bars.select('text')
                      .text(function(d,i) { return valueFormat(getY(d,i)) })
                      .watchTransition(renderWatch, 'discreteBar: bars text')
                      .attr('x', x.rangeBand() * .9 / 2)
                      .attr('y', function(d,i) { return getY(d,i) < 0 ? y(getY(d,i)) - y(0) + 12 : -4 })
  
                  ;
              } else {
                  bars.selectAll('text').remove();
              }
  
              bars
                  .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive' })
                  .style('fill', function(d,i) { return d.color || color(d,i) })
                  .style('stroke', function(d,i) { return d.color || color(d,i) })
                  .select('rect')
                  .attr('class', rectClass)
                  .watchTransition(renderWatch, 'discreteBar: bars rect')
                  .attr('width', x.rangeBand() * .9 / data.length);
              bars.watchTransition(renderWatch, 'discreteBar: bars')
                  //.delay(function(d,i) { return i * 1200 / data[0].values.length })
                  .attr('transform', function(d,i) {
                      var left = x(getX(d,i)) + x.rangeBand() * .05,
                          top = getY(d,i) < 0 ?
                              y(0) :
                                  y(0) - y(getY(d,i)) < 1 ?
                              y(0) - 1 : //make 1 px positive bars show up above y=0
                              y(getY(d,i));
  
                      return 'translate(' + left + ', ' + top + ')'
                  })
                  .select('rect')
                  .attr('height', function(d,i) {
                      return  Math.max(Math.abs(y(getY(d,i)) - y(0)), 1)
                  });
  
  
              //store old scales for use in transitions on update
              x0 = x.copy();
              y0 = y.copy();
  
          });
  
          renderWatch.renderEnd('discreteBar immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:   {get: function(){return width;}, set: function(_){width=_;}},
          height:  {get: function(){return height;}, set: function(_){height=_;}},
          forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
          showValues: {get: function(){return showValues;}, set: function(_){showValues=_;}},
          x:       {get: function(){return getX;}, set: function(_){getX=_;}},
          y:       {get: function(){return getY;}, set: function(_){getY=_;}},
          xScale:  {get: function(){return x;}, set: function(_){x=_;}},
          yScale:  {get: function(){return y;}, set: function(_){y=_;}},
          xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
          valueFormat:    {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
          id:          {get: function(){return id;}, set: function(_){id=_;}},
          rectClass: {get: function(){return rectClass;}, set: function(_){rectClass=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.discreteBarChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var discretebar = nv.models.discreteBar()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
    , legend = nv.models.legend()
          , tooltip = nv.models.tooltip()
          ;
  
      var margin = {top: 15, right: 10, bottom: 50, left: 60}
          , marginTop = null
          , width = null
          , height = null
          , color = nv.utils.getColor()
    , showLegend = false
          , showXAxis = true
          , showYAxis = true
          , rightAlignYAxis = false
          , staggerLabels = false
          , wrapLabels = false
          , rotateLabels = 0
          , x
          , y
          , noData = null
          , dispatch = d3.dispatch('beforeUpdate','renderEnd')
          , duration = 250
          ;
  
      xAxis
          .orient('bottom')
          .showMaxMin(false)
          .tickFormat(function(d) { return d })
      ;
      yAxis
          .orient((rightAlignYAxis) ? 'right' : 'left')
          .tickFormat(d3.format(',.1f'))
      ;
  
      tooltip
          .duration(0)
          .headerEnabled(false)
          .valueFormatter(function(d, i) {
              return yAxis.tickFormat()(d, i);
          })
          .keyFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          });
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(discretebar);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this),
                  that = this;
              nv.utils.initSVG(container);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() {
                  dispatch.beforeUpdate();
                  container.transition().duration(duration).call(chart);
              };
              chart.container = this;
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container);
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = discretebar.xScale();
              y = discretebar.yScale().clamp(true);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-discreteBarWithAxes').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discreteBarWithAxes').append('g');
              var defsEnter = gEnter.append('defs');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis')
                  .append('g').attr('class', 'nv-zeroLine')
                  .append('line');
  
              gEnter.append('g').attr('class', 'nv-barsWrap');
        gEnter.append('g').attr('class', 'nv-legendWrap');
  
              g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  legend.width(availableWidth);
  
                  g.select('.nv-legendWrap')
                      .datum(data)
                      .call(legend);
  
                  if (!marginTop && legend.height() !== margin.top) {
                      margin.top = legend.height();
                      availableHeight = nv.utils.availableHeight(height, container, margin);
                  }
  
                  wrap.select('.nv-legendWrap')
                      .attr('transform', 'translate(0,' + (-margin.top) +')')
              }
  
              if (rightAlignYAxis) {
                  g.select(".nv-y.nv-axis")
                      .attr("transform", "translate(" + availableWidth + ",0)");
              }
  
              // Main Chart Component(s)
              discretebar
                  .width(availableWidth)
                  .height(availableHeight);
  
              var barsWrap = g.select('.nv-barsWrap')
                  .datum(data.filter(function(d) { return !d.disabled }));
  
              barsWrap.transition().call(discretebar);
  
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-x-label-clip-' + discretebar.id())
                  .append('rect');
  
              g.select('#nv-x-label-clip-' + discretebar.id() + ' rect')
                  .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))
                  .attr('height', 16)
                  .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));
  
              // Setup Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize(-availableHeight, 0);
  
                  g.select('.nv-x.nv-axis')
                      .attr('transform', 'translate(0,' + (y.range()[0] + ((discretebar.showValues() && y.domain()[0] < 0) ? 16 : 0)) + ')');
                  g.select('.nv-x.nv-axis').call(xAxis);
  
                  var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                  if (staggerLabels) {
                      xTicks
                          .selectAll('text')
                          .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')' })
                  }
  
                  if (rotateLabels) {
                      xTicks
                          .selectAll('.tick text')
                          .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')
                          .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');
                  }
  
                  if (wrapLabels) {
                      g.selectAll('.tick text')
                          .call(nv.utils.wrapTicks, chart.xAxis.rangeBand())
                  }
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                      .tickSize( -availableWidth, 0);
  
                  g.select('.nv-y.nv-axis').call(yAxis);
              }
  
              // Zero line
              g.select(".nv-zeroLine line")
                  .attr("x1",0)
                  .attr("x2",(rightAlignYAxis) ? -availableWidth : availableWidth)
                  .attr("y1", y(0))
                  .attr("y2", y(0))
              ;
          });
  
          renderWatch.renderEnd('discreteBar chart immediate');
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      discretebar.dispatch.on('elementMouseover.tooltip', function(evt) {
          evt['series'] = {
              key: chart.x()(evt.data),
              value: chart.y()(evt.data),
              color: evt.color
          };
          tooltip.data(evt).hidden(false);
      });
  
      discretebar.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      discretebar.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.discretebar = discretebar;
      chart.legend = legend;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
    showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
          rotateLabels:  {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},
          wrapLabels:  {get: function(){return wrapLabels;}, set: function(_){wrapLabels=!!_;}},
          showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              discretebar.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              discretebar.color(color);
        legend.color(color);
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( (_) ? 'right' : 'left');
          }}
      });
  
      nv.utils.inheritOptions(chart, discretebar);
      nv.utils.initOptions(chart);
  
      return chart;
  }
  
  nv.models.distribution = function() {
      "use strict";
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 400 //technically width or height depending on x or y....
          , size = 8
          , axis = 'x' // 'x' or 'y'... horizontal or vertical
          , getData = function(d) { return d[axis] }  // defaults d.x or d.y
          , color = nv.utils.defaultColor()
          , scale = d3.scale.linear()
          , domain
          , duration = 250
          , dispatch = d3.dispatch('renderEnd')
          ;
  
      //============================================================
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var scale0;
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      //============================================================
  
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var availableLength = width - (axis === 'x' ? margin.left + margin.right : margin.top + margin.bottom),
                  naxis = axis == 'x' ? 'y' : 'x',
                  container = d3.select(this);
              nv.utils.initSVG(container);
  
              //------------------------------------------------------------
              // Setup Scales
  
              scale0 = scale0 || scale;
  
              //------------------------------------------------------------
  
  
              //------------------------------------------------------------
              // Setup containers and skeleton of chart
  
              var wrap = container.selectAll('g.nv-distribution').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-distribution');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
  
              //------------------------------------------------------------
  
  
              var distWrap = g.selectAll('g.nv-dist')
                  .data(function(d) { return d }, function(d) { return d.key });
  
              distWrap.enter().append('g');
              distWrap
                  .attr('class', function(d,i) { return 'nv-dist nv-series-' + i })
                  .style('stroke', function(d,i) { return color(d, i) });
  
              var dist = distWrap.selectAll('line.nv-dist' + axis)
                  .data(function(d) { return d.values })
              dist.enter().append('line')
                  .attr(axis + '1', function(d,i) { return scale0(getData(d,i)) })
                  .attr(axis + '2', function(d,i) { return scale0(getData(d,i)) })
              renderWatch.transition(distWrap.exit().selectAll('line.nv-dist' + axis), 'dist exit')
                  // .transition()
                  .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })
                  .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })
                  .style('stroke-opacity', 0)
                  .remove();
              dist
                  .attr('class', function(d,i) { return 'nv-dist' + axis + ' nv-dist' + axis + '-' + i })
                  .attr(naxis + '1', 0)
                  .attr(naxis + '2', size);
              renderWatch.transition(dist, 'dist')
                  // .transition()
                  .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })
                  .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })
  
  
              scale0 = scale.copy();
  
          });
          renderWatch.renderEnd('distribution immediate');
          return chart;
      }
  
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
      chart.options = nv.utils.optionsFunc.bind(chart);
      chart.dispatch = dispatch;
  
      chart.margin = function(_) {
          if (!arguments.length) return margin;
          margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
          margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
          margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
          margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
          return chart;
      };
  
      chart.width = function(_) {
          if (!arguments.length) return width;
          width = _;
          return chart;
      };
  
      chart.axis = function(_) {
          if (!arguments.length) return axis;
          axis = _;
          return chart;
      };
  
      chart.size = function(_) {
          if (!arguments.length) return size;
          size = _;
          return chart;
      };
  
      chart.getData = function(_) {
          if (!arguments.length) return getData;
          getData = d3.functor(_);
          return chart;
      };
  
      chart.scale = function(_) {
          if (!arguments.length) return scale;
          scale = _;
          return chart;
      };
  
      chart.color = function(_) {
          if (!arguments.length) return color;
          color = nv.utils.getColor(_);
          return chart;
      };
  
      chart.duration = function(_) {
          if (!arguments.length) return duration;
          duration = _;
          renderWatch.reset(duration);
          return chart;
      };
      //============================================================
  
  
      return chart;
  }
  nv.models.distroPlot = function() {
      "use strict";
  
      // IMPROVEMENTS:
      // - cleanup tooltip to look like candlestick example (don't need color square for everything)
      // - extend y scale range to min/max data better visually
      // - tips of violins need to be cut off if very long
      // - transition from box to violin not great since box only has a few points, and violin has many - need to generate box with as many points as violin
      // - when providing colorGroup, should color boxes by either parent or child group category (e.g. isolator)
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0},
          width = 960,
          height = 500,
          id = Math.floor(Math.random() * 10000), // Create semi-unique ID in case user doesn't select one
          xScale = d3.scale.ordinal(),
          yScale = d3.scale.linear(),
          getX  = function(d) { return d.label }, // Default data model selectors.
          getY  = function(d) { return d.value },
          getColor = function(d) { return d.color },
          getQ1 = function(d) { return d.values.q1 },
          getQ2 = function(d) { return d.values.q2 },
          getQ3 = function(d) { return d.values.q3 },
          getNl = function(d) { return (centralTendency == 'mean' ? getMean(d) : getQ2(d)) - d.values.notch },
          getNu = function(d) { return (centralTendency == 'mean' ? getMean(d) : getQ2(d)) + d.values.notch },
          getMean = function(d) { return d.values.mean },
          getWl = function(d) { return d.values.wl[whiskerDef] },
          getWh = function(d) { return d.values.wu[whiskerDef] },
          getMin = function(d) { return d.values.min },
          getMax = function(d) { return d.values.max },
          getDev = function(d) { return d.values.dev },
          getValsObj = function(d) { return d.values.observations; },
          getValsArr = function(d) { return d.values.observations.map(function(e) { return e.y }); },
          plotType, // type of background: 'box', 'violin', 'none'/false - default: 'box' - 'none' will activate random scatter automatically
          observationType = false, // type of observations to show: 'random', 'swarm', 'line', 'centered' - default: false (don't show any observations, even if an outlier)
          whiskerDef = 'iqr', // type of whisker to render: 'iqr', 'minmax', 'stddev' - default: iqr
          hideWhiskers = false,
          notchBox = false, // bool whether to notch box
          colorGroup = false, // if specified, each x-category will be split into groups, each colored
          centralTendency = false,
          showOnlyOutliers = true, // show only outliers in box plot
          jitter = 0.7, // faction of that jitter should take up in 'random' observationType, must be in range [0,1]; see jitterX(), default 0.7
          squash = true, // whether to remove the x-axis positions for empty data groups, default is true
          bandwidth = 'scott', // bandwidth for kde calculation, can be float or str, if str, must be one of scott or silverman
          clampViolin = true, // whether to clamp the "tails" of the violin; prevents long 0-density area
          resolution = 50,
          pointSize = 3,
          color = nv.utils.defaultColor(),
          container = null,
          xDomain, xRange,
          yDomain, yRange,
          dispatch = d3.dispatch('elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd'),
          duration = 250,
          maxBoxWidth = null;
  
      //============================================================
      // Helper Functions
      //------------------------------------------------------------
  
  
      /* Returns the smaller of std(X, ddof=1) or normalized IQR(X) over axis 0.
       *
       * @param (list) x - input x formatted as a single list of values
       *
       * @return float
       *
       * Source: https://github.com/statsmodels/statsmodels/blob/master/statsmodels/nonparametric/bandwidths.py#L9
       */
      function select_sigma(x) {
          var sorted = x.sort(d3.ascending); // sort our dat
          var normalize = 1.349;
          var IQR = (d3.quantile(sorted, 0.75) - d3.quantile(sorted, 0.25))/normalize; // normalized IQR
          return d3.min([d3.deviation(sorted), IQR]);
      }
  
      /*
      Scott's Rule of Thumb
  
      Parameters
      ----------
      x : array-like
          Array for which to get the bandwidth
      type : string
             The type of estimate to use, must be one of scott or silverman
  
      Returns
      -------
      bw : float
          The estimate of the bandwidth
  
      Notes
      -----
      Returns 1.059 * A * n ** (-1/5.) where ::
         A = min(std(x, ddof=1), IQR/1.349)
         IQR = np.subtract.reduce(np.percentile(x, [75,25]))
  
      References
      ----------
      Scott, D.W. (1992) Multivariate Density Estimation: Theory, Practice, and
          Visualization.
       */
      function calcBandwidth(x, type) {
  
          if (typeof type === 'undefined') type = 'scott';
  
          // TODO: consider using https://github.com/jasondavies/science.js
          var A = select_sigma(x);
          var n = x.length;
          return type==='scott' ? Math.pow(1.059 * A * n, -0.2) : Math.pow(.9 * A * n, -0.2);
      }
  
  
  
      /*
       * Prep data for use with distroPlot by grouping data
       * by .x() option set by user and then calculating
       * count, sum, mean, q1, q2 (median), q3, lower whisker (wl)
       * upper whisker (wu), iqr, min, max, and standard dev.
       *
       * NOTE: preparing this data can be resource intensive, and
       *       is therefore only run once on plot load. It can
       *       manually be run by calling recalcData(). This should
       *       be re-run any time the axis accessors are changed or
       *       when bandwidth/resolution are updated.
       *
       * NOTE: this will also setup the individual vertical scales
       *       for the violins.
       *
       * @param (list) dat - input data formatted as list of objects,
       *   with an object key that must exist when accessed by getX()
       *
       * @return prepared data in the form for box plotType:
       * [{
       *    key : YY,
       *    values: {
       *      count: XX,
       *      sum: XX,
       *      mean: XX,
       *      q1: XX,
       *      q2: XX,
       *      q3: XX,
       *      wl: XX,
       *      wu: XX,
       *      iqr: XX,
       *      min: XX,
       *      max: XX,
       *      dev: XX,
       *      observations: [{y:XX,..},..],
       *      key: XX,
       *      kdeDat: XX,
       *      notch: XX,
       *    }
       *  },
       *  ...
       *  ]
       * for violin plotType:
       * [{
       *    key : YY,
       *    values: {
       *      original: [{y:XX,..},..]
       *    }
       *  },
       *  ...
       *  ]
       * where YY are those keys in dat that define the
       * x-axis and which are defined by .x()
       */
      function prepData(dat) {
  
          // helper function to calcuate the various boxplot stats
          function calcStats(g, xGroup) {
  
              // sort data by Y so we can calc quartiles
              var v = g.map(function(d) {
                  if (colorGroup) allColorGroups.add(colorGroup(d)); // list of all colorGroups; used to set x-axis
                  return getY(d);
              }).sort(d3.ascending);
  
              var q1 = d3.quantile(v, 0.25);
              var q3 = d3.quantile(v, 0.75);
              var iqr = q3 - q1;
              var upper = q3 + 1.5 * iqr;
              var lower = q1 - 1.5 * iqr;
  
              /* whisker definitions:
               *  - iqr: also known as Tukey boxplot, the lowest datum still within 1.5 IQR of the lower quartile, and the highest datum still within 1.5 IQR of the upper quartile
               *  - minmax: the minimum and maximum of all of the data
               *  - sttdev: one standard deviation above and below the mean of the data
               * Note that the central tendency type (median or mean) does not impact the whisker location
               */
              var wl = {iqr: d3.max([d3.min(v),  d3.min(v.filter(function(d) {return d > lower}))]), minmax: d3.min(v), stddev: d3.mean(v) - d3.deviation(v)};
              var wu = {iqr: d3.min([d3.max(v), d3.max(v.filter(function(d) {return d < upper}))]), minmax: d3.max(v), stddev: d3.mean(v) + d3.deviation(v)};
              var median = d3.median(v);
              var mean = d3.mean(v);
              var observations = [];
  
  
              // d3-beeswarm library must be externally loaded if being used
              // https://github.com/Kcnarf/d3-beeswarm
              if (typeof d3.beeswarm !== 'undefined') {
                  observations = d3.beeswarm()
                      .data(g.map(function(e) { return getY(e); }))
                      .radius(pointSize+1)
                      .orientation('vertical')
                      .side('symmetric')
                      .distributeOn(function(e) { return yScale(e); })
                      .arrange()
  
                  // add group info for tooltip
                  observations.map(function(e,i) {
                      e.key = xGroup;
                      e.object_constancy = g[i].object_constancy;
                      e.isOutlier = (e.datum < wl.iqr || e.datum > wu.iqr) // add isOulier meta for proper class assignment
                      e.isOutlierStdDev = (e.datum < wl.stddev || e.datum > wu.stddev) // add isOulier meta for proper class assignment
                      e.randX = Math.random() * jitter * (Math.floor(Math.random()*2) == 1 ? 1 : -1) // calculate random x-position only once for each point
                  })
              } else {
                  v.forEach(function(e,i) {
                      observations.push({
                          object_constancy: e.object_constancy,
                          datum: e,
                          key: xGroup,
                          isOutlier: (e < wl.iqr || e > wu.iqr), // add isOulier meta for proper class assignment
                          isOutlierStdDev: (e < wl.stddev || e > wu.stddev), // add isOulier meta for proper class assignment
                          randX: Math.random() * jitter * (Math.floor(Math.random()*2) == 1 ? 1 : -1)
                      })
                  })
              }
  
  
              // calculate bandwidth if no number is provided
              if(isNaN(parseFloat(bandwidth))) { // if not is float
                  var bandwidthCalc;
                  if (['scott','silverman'].indexOf(bandwidth) != -1) {
                      bandwidthCalc = calcBandwidth(v, bandwidth);
                  } else {
                      bandwidthCalc = calcBandwidth(v); // calculate with default 'scott'
                  }
              }
              var kde = kernelDensityEstimator(eKernel(bandwidthCalc), yScale.ticks(resolution));
              var kdeDat = clampViolin ? clampViolinKDE(kde(v), d3.extent(v)) : kde(v);
  
  
              // make a new vertical scale for each group
              var tmpScale = d3.scale.linear()
                  .domain([0, d3.max(kdeDat, function (e) { return e.y;})])
                  .clamp(true);
              yVScale.push(tmpScale);
  
              var reformat = {
                  count: v.length,
                  num_outlier: observations.filter(function (e) { return e.isOutlier; }).length,
                  sum: d3.sum(v),
                  mean: mean,
                  q1: q1,
                  q2: median,
                  q3: q3,
                  wl: wl,
                  wu: wu,
                  iqr: iqr,
                  min: d3.min(v),
                  max: d3.max(v),
                  dev: d3.deviation(v),
                  observations: observations,
                  key: xGroup,
                  kde: kdeDat,
                  notch: 1.57 * iqr / Math.sqrt(v.length), // notch distance from mean/median
              };
  
              if (colorGroup) {reformatDatFlat.push({key: xGroup, values: reformat});}
  
              return reformat;
          }
  
          // assign a unique identifier for each point for object constancy
          // this makes updating data possible
          dat.forEach(function(d,i) { d.object_constancy = i + '_' + getY(d) + '_' + getX(d); })
  
  
          // TODO not DRY
          // couldn't find a conditional way of doing the key() grouping
          var formatted;
          if (!colorGroup) {
              formatted = d3.nest()
                  .key(function(d) { return getX(d); })
                  .rollup(function(v,i) {
                      return calcStats(v);
                  })
                  .entries(dat);
          } else {
              allColorGroups = d3.set() // reset
              var tmp = d3.nest()
                  .key(function(d) { return getX(d); })
                  .key(function(d) { return colorGroup(d); })
                  .rollup(function(v) {
                      return calcStats(v, getX(v[0]));
                  })
                  .entries(dat);
  
              // generate a final list of all x & colorGroup combinations
              // this is used to properly set the x-axis domain
              allColorGroups = allColorGroups.values(); // convert from d3.set to list
              var xGroups = tmp.map(function(d) { return d.key; });
              var allGroups = [];
              for (var i = 0; i < xGroups.length; i++) {
                  for (var j = 0; j < allColorGroups.length; j++) {
                      allGroups.push(xGroups[i] + '_' + allColorGroups[j]);
                  }
              }
              allColorGroups = allGroups;
  
              // flatten the inner most level so that
              // the plot retains the same DOM structure
              // to allow for smooth updating between
              // all groups.
              formatted = [];
              tmp.forEach(function(d) {
                  d.values.forEach(function(e) { e.key = d.key +'_'+e.key }) // generate a combo key so that each boxplot has a distinct x-position
                  formatted.push.apply(formatted, d.values)
              });
  
          }
          return formatted;
      }
  
      // https://bl.ocks.org/mbostock/4341954
      function kernelDensityEstimator(kernel, X) {
          return function (sample) {
              return X.map(function(x) {
                  var y = d3.mean(sample, function (v) {return kernel(x - v);});
                  return {x:x, y:y};
              });
          };
      }
  
      /*
       * Limit whether the density extends past the extreme datapoints
       * of the violin.
       *
       * @param (list) kde - x & y kde cooridinates
       * @param (list) extent - min/max y-values used for clamping violing
       */
      function clampViolinKDE(kde, extent) {
  
          // this handles the case when all the x-values are equal
          // which means no kde could be properly calculated
          // just return the kde data so we can continue plotting successfully
          if (extent[0] === extent[1]) return kde;
  
          var clamped = kde.reduce(function(res, d) {
              if (d.x >= extent[0] && d.x <= extent[1]) res.push(d);
              return res;
          },[]);
  
          // add the extreme data points back in
          if (extent[0] < clamped[0].x) clamped.unshift({x:extent[0], y:clamped[0].y})
          if (extent[1] > clamped[clamped.length-1].x) clamped.push({x:extent[1], y:clamped[clamped.length-1].y})
  
          return clamped;
  
      }
  
      // https://bl.ocks.org/mbostock/4341954
      function eKernel(scale) {
          return function (u) {
              return Math.abs(u /= scale) <= 1 ? .75 * (1 - u * u) / scale : 0;
          };
      }
  
      /**
       * Makes the svg polygon string for a boxplot in either a notched
       * or square version
       *
       * NOTE: this actually only draws the left half of the box, since
       * the shape is symmetric (and since this is how violins are drawn)
       * we can simply generate half the box and mirror it.
       *
       * @param boxLeft {float} - left position of box
       * @param notchLeft {float} - left position of notch
       * @param dat {obj} - box plot data that was run through prepDat, must contain
       *      data for Q1, median, Q2, notch upper and notch lower
       * @returns {string} A string in the proper format for a svg polygon
       */
      function makeNotchBox(boxLeft, notchLeft, boxCenter, dat) {
  
          var boxPoints;
          var y = centralTendency == 'mean' ? getMean(dat) : getQ2(dat); // if centralTendency is not specified, we still want to notch boxes on 'median'
          if (notchBox) {
              boxPoints = [
                      {x:boxCenter, y:yScale(getQ1(dat))},
                      {x:boxLeft, y:yScale(getQ1(dat))},
                      {x:boxLeft, y:yScale(getNl(dat))},
                      {x:notchLeft, y:yScale(y)},
                      {x:boxLeft, y:yScale(getNu(dat))},
                      {x:boxLeft, y:yScale(getQ3(dat))},
                      {x:boxCenter, y:yScale(getQ3(dat))},
                  ];
          } else {
              boxPoints = [
                      {x:boxCenter, y:yScale(getQ1(dat))},
                      {x:boxLeft, y:yScale(getQ1(dat))},
                      {x:boxLeft, y:yScale(y)}, // repeated point so that transition between notched/regular more smooth
                      {x:boxLeft, y:yScale(y)},
                      {x:boxLeft, y:yScale(y)}, // repeated point so that transition between notched/regular more smooth
                      {x:boxLeft, y:yScale(getQ3(dat))},
                      {x:boxCenter, y:yScale(getQ3(dat))},
                  ];
          }
  
          return boxPoints;
      }
  
      /**
       * Given an x-axis group, return the available color groups within it
       * provided that colorGroups is set, if not, x-axis group is returned
       */
      function getAvailableColorGroups(x) {
          if (!colorGroup) return x;
          var tmp = reformatDat.find(function(d) { return d.key == x });
          return tmp.values.map(function(d) { return d.key }).sort(d3.ascending);
      }
  
      // return true if point is an outlier
      function isOutlier(d) {
          return (whiskerDef == 'iqr' && d.isOutlier) || (whiskerDef == 'stddev' && d.isOutlierStdDev)
      }
  
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var allColorGroups = d3.set()
      var yVScale = [], reformatDat, reformatDatFlat = [];
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
      var availableWidth, availableHeight;
  
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              availableWidth = width - margin.left - margin.right,
              availableHeight = height - margin.top - margin.bottom;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
  
              // Setup y-scale so that beeswarm layout can use it in prepData()
              yScale.domain(yDomain || d3.extent(data.map(function(d) { return getY(d)}))).nice()
                  .range(yRange || [availableHeight, 0]);
  
  
              if (typeof reformatDat === 'undefined') reformatDat = prepData(data); // this prevents us from recalculating data all the time
  
              // Setup x-scale
              xScale.rangeBands(xRange || [0, availableWidth], 0.1)
                    .domain(xDomain || (colorGroup && !squash) ? allColorGroups : reformatDat.map(function(d) { return d.key }))
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap').data([reformatDat]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap');
              wrap.watchTransition(renderWatch, 'nv-wrap: wrap')
                  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              var areaEnter,
                  distroplots = wrap.selectAll('.nv-distroplot-x-group')
                      .data(function(d) { return d; });
  
              // rebind new data
              // we don't rebuild individual x-axis groups so that we can update transition them
              // however the data associated with each x-axis group needs to be updated
              // so we manually update it here
              distroplots.each(function(d,i) {
                  d3.select(this).selectAll('line.nv-distroplot-middle').datum(d);
              })
  
              areaEnter = distroplots.enter()
                  .append('g')
                  .attr('class', 'nv-distroplot-x-group')
                  .style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6)
                  .style('fill', function(d,i) { return getColor(d) || color(d,i) })
                  .style('stroke', function(d,i) { return getColor(d) || color(d,i) })
  
              distroplots.exit().remove();
  
              var rangeBand = function() { return xScale.rangeBand() };
              var areaWidth = function() { return d3.min([maxBoxWidth,rangeBand() * 0.9]); };
              var areaCenter = function() { return areaWidth()/2; };
              var areaLeft  = function() { return areaCenter() - areaWidth()/2; };
              var areaRight = function() { return areaCenter() + areaWidth()/2; };
              var tickLeft  = function() { return areaCenter() - areaWidth()/5; };
              var tickRight = function() { return areaCenter() + areaWidth()/5; };
  
              areaEnter.attr('transform', function(d) {
                      return 'translate(' + (xScale(d.key) + (rangeBand() - areaWidth()) * 0.5) + ', 0)';
                  });
  
              distroplots
                  .watchTransition(renderWatch, 'nv-distroplot-x-group: distroplots')
                  .style('stroke-opacity', 1)
                  .style('fill-opacity', 0.5)
                  .attr('transform', function(d) {
                      return 'translate(' + (xScale(d.key) + (rangeBand() - areaWidth()) * 0.5) + ', 0)';
                  });
  
              // set range for violin scale
              yVScale.map(function(d) { d.range([areaWidth()/2, 0]) });
  
              // ----- add the SVG elements for each plot type -----
  
              // scatter plot type
              if (!plotType) {
                  showOnlyOutliers = false; // force all observations to be seen
                  if (!observationType) observationType = 'random'
              }
  
              // conditionally append whisker lines
              areaEnter.each(function(d,i) {
                  var box = d3.select(this);
                  [getWl, getWh].forEach(function (f) {
                      var key = (f === getWl) ? 'low' : 'high';
                      box.append('line')
                        .style('opacity', function() { return !hideWhiskers ? '0' : '1' })
                        .attr('class', 'nv-distroplot-whisker nv-distroplot-' + key)
                      box.append('line')
                        .style('opacity', function() { return hideWhiskers ? '0' : '1' })
                        .attr('class', 'nv-distroplot-tick nv-distroplot-' + key)
                  });
              });
  
  
              // update whisker lines and ticks
              [getWl, getWh].forEach(function (f) {
                  var key = (f === getWl) ? 'low' : 'high';
                  var endpoint = (f === getWl) ? getQ1 : getQ3;
                  distroplots.select('line.nv-distroplot-whisker.nv-distroplot-' + key)
                    .watchTransition(renderWatch, 'nv-distroplot-x-group: distroplots')
                      .attr('x1', areaCenter())
                      .attr('y1', function(d) { return plotType!='violin' ? yScale(f(d)) : yScale(getQ2(d)); })
                      .attr('x2', areaCenter())
                      .attr('y2', function(d) { return plotType=='box' ? yScale(endpoint(d)) : yScale(getQ2(d)); })
                      .style('opacity', function() { return hideWhiskers ? '0' : '1' })
                  distroplots.select('line.nv-distroplot-tick.nv-distroplot-' + key)
                    .watchTransition(renderWatch, 'nv-distroplot-x-group: distroplots')
                      .attr('x1', function(d) { return plotType!='violin' ? tickLeft() : areaCenter()} )
                      .attr('y1', function(d,i) { return plotType!='violin' ? yScale(f(d)) : yScale(getQ2(d)); })
                      .attr('x2', function(d) { return plotType!='violin' ? tickRight() : areaCenter()} )
                      .attr('y2', function(d,i) { return plotType!='violin' ? yScale(f(d)) : yScale(getQ2(d)); })
                      .style('opacity', function() { return hideWhiskers ? '0' : '1' })
              });
  
              [getWl, getWh].forEach(function (f) {
                  var key = (f === getWl) ? 'low' : 'high';
                  areaEnter.selectAll('.nv-distroplot-' + key)
                    .on('mouseover', function(d,i,j) {
                        d3.select(this.parentNode).selectAll('line.nv-distroplot-'+key).classed('hover',true);
                        dispatch.elementMouseover({
                            value: key == 'low' ? 'Lower whisker' : 'Upper whisker',
                            series: { key: f(d).toFixed(2), color: getColor(d) || color(d,j) },
                            e: d3.event
                        });
                    })
                    .on('mouseout', function(d,i,j) {
                        d3.select(this.parentNode).selectAll('line.nv-distroplot-'+key).classed('hover',false);
                        dispatch.elementMouseout({
                            value: key == 'low' ? 'Lower whisker' : 'Upper whisker',
                            series: { key: f(d).toFixed(2), color: getColor(d) || color(d,j) },
                            e: d3.event
                        });
                    })
                    .on('mousemove', function(d,i) {
                        dispatch.elementMousemove({e: d3.event});
                    });
              });
  
              // setup boxes as 4 parts: left-area, left-line, right-area, right-line,
              // this way we can transition to a violin
              areaEnter.each(function(d,i) {
                  var violin = d3.select(this);
  
                  ['left','right'].forEach(function(side) {
                      ['line','area'].forEach(function(d) {
                          violin.append('path')
                              .attr('class', 'nv-distribution-' + d + ' nv-distribution-' + side)
                              .attr("transform", "rotate(90,0,0)   translate(0," + (side == 'left' ? -areaWidth() : 0) + ")" + (side == 'left' ? '' : ' scale(1,-1)')); // rotate violin
                      })
  
                  })
  
                  areaEnter.selectAll('.nv-distribution-line')
                      .style('fill','none')
                  areaEnter.selectAll('.nv-distribution-area')
                      .style('stroke','none')
                      .style('opacity',0.7)
  
              });
  
              // transitions
              distroplots.each(function(d,i) {
                  var violin = d3.select(this);
                  var objData = plotType == 'box' ? makeNotchBox(areaLeft(), tickLeft(), areaCenter(), d) : d.values.kde;
  
                  violin.selectAll('path')
                      .datum(objData)
  
                  var tmpScale = yVScale[i];
  
                  var interp = plotType=='box' ? 'linear' : 'basis';
  
                  if (plotType == 'box' || plotType == 'violin') {
                      ['left','right'].forEach(function(side) {
  
                          // line
                          distroplots.selectAll('.nv-distribution-line.nv-distribution-' + side)
                            //.watchTransition(renderWatch, 'nv-distribution-line: distroplots') // disable transition for now because it's jaring
                              .attr("d", d3.svg.line()
                                      .x(function(e) { return plotType=='box' ? e.y : yScale(e.x); })
                                      .y(function(e) { return plotType=='box' ? e.x : tmpScale(e.y) })
                                      .interpolate(interp)
                              )
                              .attr("transform", "rotate(90,0,0)   translate(0," + (side == 'left' ? -areaWidth() : 0) + ")" + (side == 'left' ? '' : ' scale(1,-1)')) // rotate violin
                              .style('opacity', !plotType ? '0' : '1');
  
                          // area
                          distroplots.selectAll('.nv-distribution-area.nv-distribution-' + side)
                            //.watchTransition(renderWatch, 'nv-distribution-line: distroplots') // disable transition for now because it's jaring
                              .attr("d", d3.svg.area()
                                      .x(function(e) { return plotType=='box' ? e.y : yScale(e.x); })
                                      .y(function(e) { return plotType=='box' ? e.x : tmpScale(e.y) })
                                      .y0(areaWidth()/2)
                                      .interpolate(interp)
                              )
                              .attr("transform", "rotate(90,0,0)   translate(0," + (side == 'left' ? -areaWidth() : 0) + ")" + (side == 'left' ? '' : ' scale(1,-1)')) // rotate violin
                              .style('opacity', !plotType ? '0' : '1');
  
                      })
                  } else { // scatter type, hide areas
                      distroplots.selectAll('.nv-distribution-area')
                          .watchTransition(renderWatch, 'nv-distribution-area: distroplots')
                          .style('opacity', !plotType ? '0' : '1');
  
                      distroplots.selectAll('.nv-distribution-line')
                          .watchTransition(renderWatch, 'nv-distribution-line: distroplots')
                          .style('opacity', !plotType ? '0' : '1');
                  }
  
              })
  
              // tooltip events
              distroplots.selectAll('path')
                  .on('mouseover', function(d,i,j) {
                      d = d3.select(this.parentNode).datum(); // grab data from parent g
                      d3.select(this).classed('hover', true);
                      dispatch.elementMouseover({
                          key: d.key,
                          value: 'Group ' + d.key + ' stats',
                          series: [
                              { key: 'max', value: getMax(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'Q3', value: getQ3(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'Q2', value: getQ2(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'Q1', value: getQ1(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'min', value: getMin(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'mean', value: getMean(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'std. dev.', value: getDev(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'count', value: d.values.count, color: getColor(d) || color(d,j) },
                              { key: 'num. outliers', value: d.values.num_outlier, color: getColor(d) || color(d,j) },
                          ],
                          data: d,
                          index: i,
                          e: d3.event
                      });
                  })
                  .on('mouseout', function(d,i,j) {
                      d3.select(this).classed('hover', false);
                      d = d3.select(this.parentNode).datum(); // grab data from parent g
                      dispatch.elementMouseout({
                          key: d.key,
                          value: 'Group ' + d.key + ' stats',
                          series: [
                              { key: 'max', value: getMax(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'Q3', value: getQ3(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'Q2', value: getQ2(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'Q1', value: getQ1(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'min', value: getMin(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'mean', value: getMean(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'std. dev.', value: getDev(d).toFixed(2), color: getColor(d) || color(d,j) },
                              { key: 'count', value: d.values.count, color: getColor(d) || color(d,j) },
                              { key: 'num. outliers', value: d.values.num_outlier, color: getColor(d) || color(d,j) },
                          ],
                          data: d,
                          index: i,
                          e: d3.event
                      });
                  })
                  .on('mousemove', function(d,i) {
                      dispatch.elementMousemove({e: d3.event});
                  });
  
  
              // median/mean line
              areaEnter.append('line')
                  .attr('class', function(d) { return 'nv-distroplot-middle'})
  
  
              distroplots.selectAll('line.nv-distroplot-middle')
                  .watchTransition(renderWatch, 'nv-distroplot-x-group: distroplots line')
                  .attr('x1', notchBox ? tickLeft : plotType != 'violin' ? areaLeft : tickLeft())
                  .attr('y1', function(d,i,j) { return centralTendency == 'mean' ? yScale(getMean(d)) : yScale(getQ2(d)); })
                  .attr('x2', notchBox ? tickRight : plotType != 'violin' ? areaRight : tickRight())
                  .attr('y2', function(d,i) { return centralTendency == 'mean' ? yScale(getMean(d)) : yScale(getQ2(d)); })
                  .style('opacity', centralTendency ? '1' : '0');
  
  
              // tooltip
              distroplots.selectAll('.nv-distroplot-middle')
                  .on('mouseover', function(d,i,j) {
                      if (d3.select(this).style('opacity') == 0) return; // don't show tooltip for hidden lines
                      var fillColor = d3.select(this.parentNode).style('fill'); // color set by parent g fill
                      d3.select(this).classed('hover', true);
                      dispatch.elementMouseover({
                          value: centralTendency == 'mean' ? 'Mean' : 'Median',
                          series: { key: centralTendency == 'mean' ? getMean(d).toFixed(2) : getQ2(d).toFixed(2), color: fillColor },
                          e: d3.event
                      });
                  })
                  .on('mouseout', function(d,i,j) {
                      if (d3.select(this).style('opacity') == 0) return; // don't show tooltip for hidden lines
                      d3.select(this).classed('hover', false);
                      var fillColor = d3.select(this.parentNode).style('fill'); // color set by parent g fill
                      dispatch.elementMouseout({
                          value: centralTendency == 'mean' ? 'Mean' : 'Median',
                          series: { key: centralTendency == 'mean' ? getMean(d).toFixed(2) : getQ2(d).toFixed(2), color: fillColor },
                          e: d3.event
                      });
                  })
                  .on('mousemove', function(d,i) {
                      dispatch.elementMousemove({e: d3.event});
                  });
  
  
              // setup observations
              // create DOMs even if not requested (and hide them), so that
              // we can do transitions on them
              var obsWrap = distroplots.selectAll('g.nv-distroplot-observation')
                  .data(function(d) { return getValsObj(d) }, function(d) {  return d.object_constancy; });
  
              var obsGroup = obsWrap.enter()
                  .append('g')
                  .attr('class', 'nv-distroplot-observation')
  
              obsGroup.append('circle')
                  .style({'opacity': 0})
  
              obsGroup.append('line')
                  .style('stroke-width', 1)
                  .style({'stroke': d3.rgb(85, 85, 85), 'opacity': 0})
  
              obsWrap.exit().remove();
              obsWrap.attr('class', function(d) { return 'nv-distroplot-observation ' + (isOutlier(d) && plotType == 'box' ? 'nv-distroplot-outlier' : 'nv-distroplot-non-outlier')})
  
              // transition observations
              if (observationType == 'line') {
                  distroplots.selectAll('g.nv-distroplot-observation line')
                    .watchTransition(renderWatch, 'nv-distrolot-x-group: nv-distoplot-observation')
                      .attr("x1", tickLeft() + areaWidth()/4)
                      .attr("x2", tickRight() - areaWidth()/4)
                      .attr('y1', function(d) { return yScale(d.datum)})
                      .attr('y2', function(d) { return yScale(d.datum)});
              } else {
                  distroplots.selectAll('g.nv-distroplot-observation circle')
                    .watchTransition(renderWatch, 'nv-distroplot: nv-distroplot-observation')
                      .attr('cy', function(d) { return yScale(d.datum); })
                      .attr('r', pointSize);
  
                  // NOTE: this update can be slow when re-sizing window when many point visible 
                  // TODO: filter selection down to only visible points, no need to update x-position
                  //       of the hidden points
                  distroplots.selectAll('g.nv-distroplot-observation circle')
                    .watchTransition(renderWatch, 'nv-distroplot: nv-distroplot-observation')
                      .attr('cx', function(d) { return observationType == 'swarm' ? d.x + areaWidth()/2 : observationType == 'random' ? areaWidth()/2 + d.randX * areaWidth()/2 : areaWidth()/2; })
  
              }
  
              // set opacity on outliers/non-outliers
              // any circle/line entering has opacity 0
              if (observationType !== false) { // observationType is False when hidding all circle/lines
                  if (!showOnlyOutliers) { // show all line/circle
                      distroplots.selectAll(observationType== 'line' ? 'line':'circle')
                        .watchTransition(renderWatch, 'nv-distroplot: nv-distroplot-observation')
                          .style('opacity',1)
                  } else { // show only outliers
                      distroplots.selectAll('.nv-distroplot-outlier '+ (observationType== 'line' ? 'line':'circle'))
                        .watchTransition(renderWatch, 'nv-distroplot: nv-distroplot-observation')
                          .style('opacity',1)
                      distroplots.selectAll('.nv-distroplot-non-outlier '+ (observationType== 'line' ? 'line':'circle'))
                        .watchTransition(renderWatch, 'nv-distroplot: nv-distroplot-observation')
                          .style('opacity',0)
                  }
              }
  
              // hide all other observations
              distroplots.selectAll('.nv-distroplot-observation' + (observationType=='line'?' circle':' line'))
                .watchTransition(renderWatch, 'nv-distroplot: nv-distoplot-observation')
                  .style('opacity',0)
  
              // tooltip events for observations
              distroplots.selectAll('.nv-distroplot-observation')
                      .on('mouseover', function(d,i,j) {
                          var pt = d3.select(this);
                          if (showOnlyOutliers && plotType == 'box' && !isOutlier(d)) return; // don't show tooltip for hidden observation
                          var fillColor = d3.select(this.parentNode).style('fill'); // color set by parent g fill
                          pt.classed('hover', true);
                          dispatch.elementMouseover({
                              value: (plotType == 'box' && isOutlier(d)) ? 'Outlier' : 'Observation',
                              series: { key: d.datum.toFixed(2), color: fillColor },
                              e: d3.event
                          });
                      })
                      .on('mouseout', function(d,i,j) {
                          var pt = d3.select(this);
                          var fillColor = d3.select(this.parentNode).style('fill'); // color set by parent g fill
                          pt.classed('hover', false);
                          dispatch.elementMouseout({
                              value: (plotType == 'box' && isOutlier(d)) ? 'Outlier' : 'Observation',
                              series: { key: d.datum.toFixed(2), color: fillColor },
                              e: d3.event
                          });
                      })
                      .on('mousemove', function(d,i) {
                          dispatch.elementMousemove({e: d3.event});
                      });
  
          });
  
          renderWatch.renderEnd('nv-distroplot-x-group immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:            {get: function(){return width;}, set: function(_){width=_;}},
          height:           {get: function(){return height;}, set: function(_){height=_;}},
          maxBoxWidth:      {get: function(){return maxBoxWidth;}, set: function(_){maxBoxWidth=_;}},
          x:                {get: function(){return getX;}, set: function(_){getX=_;}},
          y:                {get: function(){return getY;}, set: function(_){getY=_;}},
          plotType:         {get: function(){return plotType;}, set: function(_){plotType=_;}}, // plotType of background: 'box', 'violin' - default: 'box'
          observationType:  {get: function(){return observationType;}, set: function(_){observationType=_;}}, // type of observations to show: 'random', 'swarm', 'line', 'point' - default: false (don't show observations)
          whiskerDef:       {get: function(){return whiskerDef;}, set: function(_){whiskerDef=_;}}, // type of whisker to render: 'iqr', 'minmax', 'stddev' - default: iqr
          notchBox:         {get: function(){return notchBox;}, set: function(_){notchBox=_;}}, // bool whether to notch box
          hideWhiskers:     {get: function(){return hideWhiskers;}, set: function(_){hideWhiskers=_;}},
          colorGroup:       {get: function(){return colorGroup;}, set: function(_){colorGroup=_;}}, // data key to use to set color group of each x-category - default: don't group
          centralTendency:       {get: function(){return centralTendency;}, set: function(_){centralTendency=_;}}, // add a mean or median line to the data - default: don't show, must be one of 'mean' or 'median'
          bandwidth:        {get: function(){return bandwidth;}, set: function(_){bandwidth=_;}}, // bandwidth for kde calculation, can be float or str, if str, must be one of scott or silverman
          clampViolin:           {get: function(){return clampViolin;}, set: function(_){clampViolin=_;}},
          resolution:       {get: function(){return resolution;}, set: function(_){resolution=_;}}, // resolution for kde calculation, default 50
          xScale:           {get: function(){return xScale;}, set: function(_){xScale=_;}},
          yScale:           {get: function(){return yScale;}, set: function(_){yScale=_;}},
          showOnlyOutliers: {get: function(){return showOnlyOutliers;}, set: function(_){showOnlyOutliers=_;}}, // show only outliers in box plot, default true
          jitter:           {get: function(){return jitter;}, set: function(_){jitter=_;}}, // faction of that jitter should take up in 'random' observationType, must be in range [0,1]; see jitterX(), default 0.7
          squash:           {get: function(){return squash;}, set: function(_){squash=_;}}, // whether to squash sparse distribution of color groups towards middle of x-axis position
          pointSize:     {get: function(){return pointSize;}, set: function(_){pointSize=_;}},
          xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
          recalcData:   {get: function() { reformatDat = prepData(container.datum()); } },
          itemColor:    {get: function(){return getColor;}, set: function(_){getColor=_;}},
          id:           {get: function(){return id;}, set: function(_){id=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  nv.models.distroPlotChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var distroplot = nv.models.distroPlot(),
          xAxis = nv.models.axis(),
          yAxis = nv.models.axis()
  
      var margin = {top: 25, right: 10, bottom: 40, left: 60},
          width = null,
          height = null,
          color = nv.utils.getColor(),
          showXAxis = true,
          showYAxis = true,
          rightAlignYAxis = false,
          staggerLabels = false,
          xLabel = false,
          yLabel = false,
          tooltip = nv.models.tooltip(),
          x, y,
          noData = 'No Data Available.',
          dispatch = d3.dispatch('stateChange', 'beforeUpdate', 'renderEnd'),
          duration = 500;
  
      xAxis
          .orient('bottom')
          .showMaxMin(false)
          .tickFormat(function(d) { return d })
      ;
      yAxis
          .orient((rightAlignYAxis) ? 'right' : 'left')
          .tickFormat(d3.format(',.1f'))
      ;
  
      tooltip.duration(0);
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
      var colorGroup0, marginTop0 = margin.top, x0, y0, resolution0, bandwidth0, clampViolin0;
      var dataCache;
  
  
      // return true if data has changed somehow after
      // an .update() was called
      // works by comparing current data set to the
      // one previously cached
      // TODO - since we keep another version of the dataset
      // around for comparison, it doubles the memory usage :(
      function dataHasChanged(d) {
          if (arraysEqual(d, dataCache)) {
              return false;
          } else {
              dataCache = JSON.parse(JSON.stringify(d)) // deep copy
              return true;
          }
      }
  
      // return true if array of objects equivalent
      function arraysEqual(arr1, arr2) {
          if(arr1.length !== arr2.length) return false;
  
          for(var i = arr1.length; i--;) {
              if ('object_constancy' in arr1[i]) delete arr1[i].object_constancy
              if ('object_constancy' in arr2[i]) delete arr2[i].object_constancy
  
              if(!objectEquals(arr1[i], arr2[i])) {
                  return false;
              }
          }
  
          return true;
      }
  
      // return true if objects are equivalent
      function objectEquals(a, b) {
          // Create arrays of property names
          var aProps = Object.getOwnPropertyNames(a);
          var bProps = Object.getOwnPropertyNames(b);
  
          // If number of properties is different,
          // objects are not equivalent
          if (aProps.length != bProps.length) {
              return false;
          }
  
          for (var i = 0; i < aProps.length; i++) {
              var propName = aProps[i];
  
              // If values of same property are not equal,
              // objects are not equivalent
              if (a[propName] !== b[propName]) {
                  return false;
              }
          }
  
          return true;
      }
  
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(distroplot);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this), that = this;
              nv.utils.initSVG(container);
              var availableWidth = (width  || parseInt(container.style('width')) || 960) - margin.left - margin.right;
              var availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;
  
              if (typeof dataCache === 'undefined') {
                  dataCache = JSON.parse(JSON.stringify(data)) // deep copy
              }
  
              chart.update = function() {
                  dispatch.beforeUpdate();
                  var opts = distroplot.options()
                  if (colorGroup0 !== opts.colorGroup() || // recalc data when any of the axis accessors are changed
                      x0 !== opts.x() ||
                      y0 !== opts.y() ||
                      bandwidth0 !== opts.bandwidth() ||
                      resolution0 !== opts.resolution() ||
                      clampViolin0 !== opts.clampViolin() ||
                      dataHasChanged(data)
                  ) {
                      distroplot.recalcData();
                  }
                  container.transition().duration(duration).call(chart);
              };
              chart.container = this;
  
  
              if (typeof d3.beeswarm !== 'function' && chart.options().observationType() == 'swarm') {
                  var xPos = margin.left + availableWidth/2;
                  noData = 'Please include the library https://github.com/Kcnarf/d3-beeswarm to use "swarm".'
                  nv.utils.noData(chart, container);
                  return chart;
              } else if (!data || !data.length) {
                  nv.utils.noData(chart, container);
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = distroplot.xScale();
              y = distroplot.yScale().clamp(true);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-distroPlot').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-distroPlot').append('g');
              var defsEnter = gEnter.append('defs');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis')
                  .append('g').attr('class', 'nv-zeroLine')
                  .append('line');
  
              gEnter.append('g').attr('class', 'nv-distroWrap');
              gEnter.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
              g.watchTransition(renderWatch, 'nv-wrap: wrap')
                  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              if (rightAlignYAxis) {
                  g.select('.nv-y.nv-axis')
                      .attr('transform', 'translate(' + availableWidth + ',0)');
              }
  
  
              // Main Chart Component(s)
              distroplot.width(availableWidth).height(availableHeight);
  
              var distroWrap = g.select('.nv-distroWrap')
                  .datum(data)
  
              distroWrap.transition().call(distroplot);
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-x-label-clip-' + distroplot.id())
                  .append('rect');
  
              g.select('#nv-x-label-clip-' + distroplot.id() + ' rect')
                  .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))
                  .attr('height', 16)
                  .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));
  
              // Setup Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize(-availableHeight, 0);
  
                  g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')')
                  g.select('.nv-x.nv-axis').call(xAxis);
  
                  //g.select('.nv-x.nv-axis').select('.nv-axislabel')
                  //    .style('font-size', d3.min([availableWidth * 0.05,20]) + 'px')
  
                  var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                  if (staggerLabels) {
                      xTicks
                          .selectAll('text')
                          .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 === 0 ? '5' : '17') + ')' })
                  }
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      .ticks( Math.floor(availableHeight/36) ) // can't use nv.utils.calcTicksY with Object data
                      .tickSize( -availableWidth, 0);
  
                  g.select('.nv-y.nv-axis').call(yAxis);
  
                  //g.select('.nv-y.nv-axis').select('.nv-axislabel')
                  //    .style('font-size', d3.min([availableHeight * 0.05,20]) + 'px')
              }
  
  
  
  
              // Zero line on chart bottom
              g.select('.nv-zeroLine line')
                  .attr('x1',0)
                  .attr('x2',availableWidth)
                  .attr('y1', y(0))
                  .attr('y2', y(0))
              ;
  
              // store original values so that we can
              // call 'recalcData()' if needed
              colorGroup0 = distroplot.options().colorGroup();
              x0 = distroplot.options().x();
              y0 = distroplot.options().y();
              bandwidth0 = distroplot.options().bandwidth();
              resolution0 = distroplot.options().resolution();
              clampViolin0 = distroplot.options().clampViolin();
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
          });
  
          renderWatch.renderEnd('nv-distroplot chart immediate');
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      distroplot.dispatch.on('elementMouseover.tooltip', function(evt) {
          tooltip.data(evt).hidden(false);
      });
  
      distroplot.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.data(evt).hidden(true);
      });
  
      distroplot.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.distroplot = distroplot;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
          showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
          defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              distroplot.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              distroplot.color(color);
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( (_) ? 'right' : 'left');
          }},
          xLabel:  {get: function(){return xLabel;}, set: function(_){
              xLabel=_;
              xAxis.axisLabel(xLabel);
          }},
          yLabel:  {get: function(){return yLabel;}, set: function(_){
              yLabel=_;
              yAxis.axisLabel(yLabel);
          }},
      });
  
  
      nv.utils.inheritOptions(chart, distroplot);
      nv.utils.initOptions(chart);
  
      return chart;
  }
  nv.models.focus = function(content) {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var content = content || nv.models.line()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
          , brush = d3.svg.brush()
          ;
  
      var margin = {top: 10, right: 0, bottom: 30, left: 0}
          , color = nv.utils.defaultColor()
          , width = null
          , height = 70
          , showXAxis = true
          , showYAxis = false
          , rightAlignYAxis = false
          , ticks = null
          , x
          , y
          , brushExtent = null
          , duration = 250
          , dispatch = d3.dispatch('brush', 'onBrush', 'renderEnd')
          , syncBrushing = true
          ;
  
      content.interactive(false);
      content.pointActive(function(d) { return false; });
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(content);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this);
              nv.utils.initSVG(container);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = height - margin.top - margin.bottom;
  
              chart.update = function() { 
                  if( duration === 0 ) {
                      container.call( chart );
                  } else {
                      container.transition().duration(duration).call(chart);
                  }
              };
              chart.container = this;
  
              // Setup Scales
              x = content.xScale();
              y = content.yScale();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-focus').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-focus').append('g');
              var g = wrap.select('g');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              gEnter.append('g').attr('class', 'nv-background').append('rect');
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis');
              gEnter.append('g').attr('class', 'nv-contentWrap');
              gEnter.append('g').attr('class', 'nv-brushBackground');
              gEnter.append('g').attr('class', 'nv-x nv-brush');
  
              if (rightAlignYAxis) {
                  g.select(".nv-y.nv-axis")
                      .attr("transform", "translate(" + availableWidth + ",0)");
              }
  
              g.select('.nv-background rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
                  
              content
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled; }));
  
              var contentWrap = g.select('.nv-contentWrap')
                  .datum(data.filter(function(d) { return !d.disabled; }));
  
              d3.transition(contentWrap).call(content);
              
              // Setup Brush
              brush
                  .x(x)
                  .on('brush', function() {
                      onBrush(syncBrushing);
                  });
  
              brush.on('brushend', function () {
                  if (!syncBrushing) {
                      dispatch.onBrush(brush.empty() ? x.domain() : brush.extent());
                  }
              });
  
              if (brushExtent) brush.extent(brushExtent);
  
              var brushBG = g.select('.nv-brushBackground').selectAll('g')
                  .data([brushExtent || brush.extent()]);
      
              var brushBGenter = brushBG.enter()
                  .append('g');
  
              brushBGenter.append('rect')
                  .attr('class', 'left')
                  .attr('x', 0)
                  .attr('y', 0)
                  .attr('height', availableHeight);
  
              brushBGenter.append('rect')
                  .attr('class', 'right')
                  .attr('x', 0)
                  .attr('y', 0)
                  .attr('height', availableHeight);
  
              var gBrush = g.select('.nv-x.nv-brush')
                  .call(brush);
              gBrush.selectAll('rect')
                  .attr('height', availableHeight);
              gBrush.selectAll('.resize').append('path').attr('d', resizePath);
  
              onBrush(true);
  
              g.select('.nv-background rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              if (showXAxis) {
                  xAxis.scale(x)
                      ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize(-availableHeight, 0);
    
                  g.select('.nv-x.nv-axis')
                      .attr('transform', 'translate(0,' + y.range()[0] + ')');
                  d3.transition(g.select('.nv-x.nv-axis'))
                      .call(xAxis);
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                      .tickSize( -availableWidth, 0);
  
                  d3.transition(g.select('.nv-y.nv-axis'))
                      .call(yAxis);
              }
              
              g.select('.nv-x.nv-axis')
                  .attr('transform', 'translate(0,' + y.range()[0] + ')');
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              //============================================================
              // Functions
              //------------------------------------------------------------
      
              // Taken from crossfilter (http://square.github.com/crossfilter/)
              function resizePath(d) {
                  var e = +(d == 'e'),
                      x = e ? 1 : -1,
                      y = availableHeight / 3;
                  return 'M' + (0.5 * x) + ',' + y
                      + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                      + 'V' + (2 * y - 6)
                      + 'A6,6 0 0 ' + e + ' ' + (0.5 * x) + ',' + (2 * y)
                      + 'Z'
                      + 'M' + (2.5 * x) + ',' + (y + 8)
                      + 'V' + (2 * y - 8)
                      + 'M' + (4.5 * x) + ',' + (y + 8)
                      + 'V' + (2 * y - 8);
              }
      
      
              function updateBrushBG() {
                  if (!brush.empty()) brush.extent(brushExtent);
                  brushBG
                      .data([brush.empty() ? x.domain() : brushExtent])
                      .each(function(d,i) {
                          var leftWidth = x(d[0]) - x.range()[0],
                              rightWidth = availableWidth - x(d[1]);
                          d3.select(this).select('.left')
                              .attr('width',  leftWidth < 0 ? 0 : leftWidth);
      
                          d3.select(this).select('.right')
                              .attr('x', x(d[1]))
                              .attr('width', rightWidth < 0 ? 0 : rightWidth);
                      });
              }
  
  
              function onBrush(shouldDispatch) {
                  brushExtent = brush.empty() ? null : brush.extent();
                  var extent = brush.empty() ? x.domain() : brush.extent();
                  dispatch.brush({extent: extent, brush: brush});
                  updateBrushBG();
                  if (shouldDispatch) {
                      dispatch.onBrush(extent);
                  }
              }
          });
  
          renderWatch.renderEnd('focus immediate');
          return chart;
      }
  
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.content = content;
      chart.brush = brush;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          brushExtent: {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},
          syncBrushing: {get: function(){return syncBrushing;}, set: function(_){syncBrushing=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              content.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              content.color(color);
          }},
          interpolate: {get: function(){return content.interpolate();}, set: function(_){
              content.interpolate(_);
          }},
          xTickFormat: {get: function(){return xAxis.tickFormat();}, set: function(_){
              xAxis.tickFormat(_);
          }},
          yTickFormat: {get: function(){return yAxis.tickFormat();}, set: function(_){
              yAxis.tickFormat(_);
          }},
          x: {get: function(){return content.x();}, set: function(_){
              content.x(_);
          }},
          y: {get: function(){return content.y();}, set: function(_){
              content.y(_);
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( rightAlignYAxis ? 'right' : 'left');
          }}
      });
  
      nv.utils.inheritOptions(chart, content);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  nv.models.forceDirectedGraph = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
      var margin = {top: 2, right: 0, bottom: 2, left: 0}
          , width = 400
          , height = 32
          , container = null
          , dispatch = d3.dispatch('renderEnd')
          , color = nv.utils.getColor(['#000'])
          , tooltip      = nv.models.tooltip()
          , noData = null
          // Force directed graph specific parameters [default values]
          , linkStrength = 0.1
          , friction = 0.9
          , linkDist = 30
          , charge = -120
          , gravity = 0.1
          , theta = 0.8
          , alpha = 0.1
          , radius = 5
          // These functions allow to add extra attributes to ndes and links
          ,nodeExtras = function(nodes) { /* Do nothing */ }
          ,linkExtras = function(links) { /* Do nothing */ }
          , getX=d3.functor(0.0)
          , getY=d3.functor(0.0)
          ;
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
  
      function chart(selection) {
          renderWatch.reset();
  
          selection.each(function(data) {
            container = d3.select(this);
            nv.utils.initSVG(container);
  
            var availableWidth = nv.utils.availableWidth(width, container, margin),
                availableHeight = nv.utils.availableHeight(height, container, margin);
  
            container
                    .attr("width", availableWidth)
                    .attr("height", availableHeight);
  
            // Display No Data message if there's nothing to show.
            if (!data || !data.links || !data.nodes) {
                nv.utils.noData(chart, container)
                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }
            container.selectAll('*').remove();
  
            // Collect names of all fields in the nodes
            var nodeFieldSet = new Set();
            data.nodes.forEach(function(node) {
              var keys = Object.keys(node);
              keys.forEach(function(key) {
                nodeFieldSet.add(key);
              });
            });
  
            var force = d3.layout.force()
                  .nodes(data.nodes)
                  .links(data.links)
                  .size([availableWidth, availableHeight])
                  .linkStrength(linkStrength)
                  .friction(friction)
                  .linkDistance(linkDist)
                  .charge(charge)
                  .gravity(gravity)
                  .theta(theta)
                  .alpha(alpha)
                  .start();
  
            var link = container.selectAll(".link")
                  .data(data.links)
                  .enter().append("line")
                  .attr("class", "nv-force-link")
                  .style("stroke-width", function(d) { return Math.sqrt(d.value); });
  
            var node = container.selectAll(".node")
                  .data(data.nodes)
                  .enter()
                  .append("g")
                  .attr("class", "nv-force-node")
                  .call(force.drag);
  
            node
              .append("circle")
              .attr("r", radius)
              .style("fill", function(d) { return color(d) } )
              .on("mouseover", function(evt) {
                container.select('.nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex)
                    .attr('y1', evt.py);
                container.select('.nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex)
                    .attr('x2', evt.px);
  
                // Add 'series' object to
                var nodeColor = color(evt);
                evt.series = [];
                nodeFieldSet.forEach(function(field) {
                  evt.series.push({
                    color: nodeColor,
                    key:   field,
                    value: evt[field]
                  });
                });
                tooltip.data(evt).hidden(false);
              })
              .on("mouseout",  function(d) {
                tooltip.hidden(true);
              });
  
            tooltip.headerFormatter(function(d) {return "Node";});
  
            // Apply extra attributes to nodes and links (if any)
            linkExtras(link);
            nodeExtras(node);
  
            force.on("tick", function() {
                link.attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });
  
                node.attr("transform", function(d) {
                  return "translate(" + d.x + ", " + d.y + ")";
                });
              });
          });
  
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:     {get: function(){return width;}, set: function(_){width=_;}},
          height:    {get: function(){return height;}, set: function(_){height=_;}},
  
          // Force directed graph specific parameters
          linkStrength:{get: function(){return linkStrength;}, set: function(_){linkStrength=_;}},
          friction:    {get: function(){return friction;}, set: function(_){friction=_;}},
          linkDist:    {get: function(){return linkDist;}, set: function(_){linkDist=_;}},
          charge:      {get: function(){return charge;}, set: function(_){charge=_;}},
          gravity:     {get: function(){return gravity;}, set: function(_){gravity=_;}},
          theta:       {get: function(){return theta;}, set: function(_){theta=_;}},
          alpha:       {get: function(){return alpha;}, set: function(_){alpha=_;}},
          radius:      {get: function(){return radius;}, set: function(_){radius=_;}},
  
          //functor options
          x: {get: function(){return getX;}, set: function(_){getX=d3.functor(_);}},
          y: {get: function(){return getY;}, set: function(_){getY=d3.functor(_);}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
          nodeExtras: {get: function(){return nodeExtras;}, set: function(_){
              nodeExtras = _;
          }},
          linkExtras: {get: function(){return linkExtras;}, set: function(_){
              linkExtras = _;
          }}
      });
  
      chart.dispatch = dispatch;
      chart.tooltip = tooltip;
      nv.utils.initOptions(chart);
      return chart;
  };
  nv.models.furiousLegend = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 5, right: 0, bottom: 5, left: 0}
          , width = 400
          , height = 20
          , getKey = function(d) { return d.key }
          , keyFormatter = function (d) { return d }
          , color = nv.utils.getColor()
          , maxKeyLength = 20 //default value for key lengths
          , align = true
          , padding = 28 //define how much space between legend items. - recommend 32 for furious version
          , rightAlign = true
          , updateState = true   //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.
          , radioButtonMode = false   //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)
          , expanded = false
          , dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange')
          , vers = 'classic' //Options are "classic" and "furious"
          ;
  
      function chart(selection) {
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right,
                  container = d3.select(this);
              nv.utils.initSVG(container);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-legend').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');
              var g = wrap.select('g');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              var series = g.selectAll('.nv-series')
                  .data(function(d) {
                      if(vers != 'furious') return d;
  
                      return d.filter(function(n) {
                          return expanded ? true : !n.disengaged;
                      });
                  });
              var seriesEnter = series.enter().append('g').attr('class', 'nv-series')
  
              var seriesShape;
  
              if(vers == 'classic') {
                  seriesEnter.append('circle')
                      .style('stroke-width', 2)
                      .attr('class','nv-legend-symbol')
                      .attr('r', 5);
  
                  seriesShape = series.select('circle');
              } else if (vers == 'furious') {
                  seriesEnter.append('rect')
                      .style('stroke-width', 2)
                      .attr('class','nv-legend-symbol')
                      .attr('rx', 3)
                      .attr('ry', 3);
  
                  seriesShape = series.select('rect');
  
                  seriesEnter.append('g')
                      .attr('class', 'nv-check-box')
                      .property('innerHTML','<path d="M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z" class="nv-box"></path><path d="M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511" class="nv-check"></path>')
                      .attr('transform', 'translate(-10,-8)scale(0.5)');
  
                  var seriesCheckbox = series.select('.nv-check-box');
  
                  seriesCheckbox.each(function(d,i) {
                      d3.select(this).selectAll('path')
                          .attr('stroke', setTextColor(d,i));
                  });
              }
  
              seriesEnter.append('text')
                  .attr('text-anchor', 'start')
                  .attr('class','nv-legend-text')
                  .attr('dy', '.32em')
                  .attr('dx', '8');
  
              var seriesText = series.select('text.nv-legend-text');
  
              series
                  .on('mouseover', function(d,i) {
                      dispatch.legendMouseover(d,i);  //TODO: Make consistent with other event objects
                  })
                  .on('mouseout', function(d,i) {
                      dispatch.legendMouseout(d,i);
                  })
                  .on('click', function(d,i) {
                      dispatch.legendClick(d,i);
                      // make sure we re-get data in case it was modified
                      var data = series.data();
                      if (updateState) {
                          if(vers =='classic') {
                              if (radioButtonMode) {
                                  //Radio button mode: set every series to disabled,
                                  //  and enable the clicked series.
                                  data.forEach(function(series) { series.disabled = true});
                                  d.disabled = false;
                              }
                              else {
                                  d.disabled = !d.disabled;
                                  if (data.every(function(series) { return series.disabled})) {
                                      //the default behavior of NVD3 legends is, if every single series
                                      // is disabled, turn all series' back on.
                                      data.forEach(function(series) { series.disabled = false});
                                  }
                              }
                          } else if(vers == 'furious') {
                              if(expanded) {
                                  d.disengaged = !d.disengaged;
                                  d.userDisabled = d.userDisabled == undefined ? !!d.disabled : d.userDisabled;
                                  d.disabled = d.disengaged || d.userDisabled;
                              } else if (!expanded) {
                                  d.disabled = !d.disabled;
                                  d.userDisabled = d.disabled;
                                  var engaged = data.filter(function(d) { return !d.disengaged; });
                                  if (engaged.every(function(series) { return series.userDisabled })) {
                                      //the default behavior of NVD3 legends is, if every single series
                                      // is disabled, turn all series' back on.
                                      data.forEach(function(series) {
                                          series.disabled = series.userDisabled = false;
                                      });
                                  }
                              }
                          }
                          dispatch.stateChange({
                              disabled: data.map(function(d) { return !!d.disabled }),
                              disengaged: data.map(function(d) { return !!d.disengaged })
                          });
  
                      }
                  })
                  .on('dblclick', function(d,i) {
                      if(vers == 'furious' && expanded) return;
                      dispatch.legendDblclick(d,i);
                      if (updateState) {
                          // make sure we re-get data in case it was modified
                          var data = series.data();
                          //the default behavior of NVD3 legends, when double clicking one,
                          // is to set all other series' to false, and make the double clicked series enabled.
                          data.forEach(function(series) {
                              series.disabled = true;
                              if(vers == 'furious') series.userDisabled = series.disabled;
                          });
                          d.disabled = false;
                          if(vers == 'furious') d.userDisabled = d.disabled;
                          dispatch.stateChange({
                              disabled: data.map(function(d) { return !!d.disabled })
                          });
                      }
                  });
  
              series.classed('nv-disabled', function(d) { return d.userDisabled });
              series.exit().remove();
  
              seriesText
                  .attr('fill', setTextColor)
                  .text(function (d) { return keyFormatter(getKey(d)) });
  
              //TODO: implement fixed-width and max-width options (max-width is especially useful with the align option)
              // NEW ALIGNING CODE, TODO: clean up
  
              var versPadding;
              switch(vers) {
                  case 'furious' :
                      versPadding = 23;
                      break;
                  case 'classic' :
                      versPadding = 20;
              }
  
              if (align) {
  
                  var seriesWidths = [];
                  series.each(function(d,i) {
                      var legendText;
                      if (keyFormatter(getKey(d)) && keyFormatter(getKey(d)).length > maxKeyLength) {
                          var trimmedKey = keyFormatter(getKey(d)).substring(0, maxKeyLength);
                          legendText = d3.select(this).select('text').text(trimmedKey + "...");
                          d3.select(this).append("svg:title").text(keyFormatter(getKey(d)));
                      } else {
                          legendText = d3.select(this).select('text');
                      }
                      var nodeTextLength;
                      try {
                          nodeTextLength = legendText.node().getComputedTextLength();
                          // If the legendText is display:none'd (nodeTextLength == 0), simulate an error so we approximate, instead
                          if(nodeTextLength <= 0) throw Error();
                      }
                      catch(e) {
                          nodeTextLength = nv.utils.calcApproxTextWidth(legendText);
                      }
  
                      seriesWidths.push(nodeTextLength + padding);
                  });
  
                  var seriesPerRow = 0;
                  var legendWidth = 0;
                  var columnWidths = [];
  
                  while ( legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {
                      columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];
                      legendWidth += seriesWidths[seriesPerRow++];
                  }
                  if (seriesPerRow === 0) seriesPerRow = 1; //minimum of one series per row
  
                  while ( legendWidth > availableWidth && seriesPerRow > 1 ) {
                      columnWidths = [];
                      seriesPerRow--;
  
                      for (var k = 0; k < seriesWidths.length; k++) {
                          if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0) )
                              columnWidths[k % seriesPerRow] = seriesWidths[k];
                      }
  
                      legendWidth = columnWidths.reduce(function(prev, cur, index, array) {
                          return prev + cur;
                      });
                  }
  
                  var xPositions = [];
                  for (var i = 0, curX = 0; i < seriesPerRow; i++) {
                      xPositions[i] = curX;
                      curX += columnWidths[i];
                  }
  
                  series
                      .attr('transform', function(d, i) {
                          return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * versPadding) + ')';
                      });
  
                  //position legend as far right as possible within the total width
                  if (rightAlign) {
                      g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');
                  }
                  else {
                      g.attr('transform', 'translate(0' + ',' + margin.top + ')');
                  }
  
                  height = margin.top + margin.bottom + (Math.ceil(seriesWidths.length / seriesPerRow) * versPadding);
  
              } else {
  
                  var ypos = 5,
                      newxpos = 5,
                      maxwidth = 0,
                      xpos;
                  series
                      .attr('transform', function(d, i) {
                          var length = d3.select(this).select('text').node().getComputedTextLength() + padding;
                          xpos = newxpos;
  
                          if (width < margin.left + margin.right + xpos + length) {
                              newxpos = xpos = 5;
                              ypos += versPadding;
                          }
  
                          newxpos += length;
                          if (newxpos > maxwidth) maxwidth = newxpos;
  
                          return 'translate(' + xpos + ',' + ypos + ')';
                      });
  
                  //position legend as far right as possible within the total width
                  g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');
  
                  height = margin.top + margin.bottom + ypos + 15;
              }
  
              if(vers == 'furious') {
                  // Size rectangles after text is placed
                  seriesShape
                      .attr('width', function(d,i) {
                          return seriesText[0][i].getComputedTextLength() + 27;
                      })
                      .attr('height', 18)
                      .attr('y', -9)
                      .attr('x', -15)
              }
  
              seriesShape
                  .style('fill', setBGColor)
                  .style('stroke', function(d,i) { return d.color || color(d, i) });
          });
  
          function setTextColor(d,i) {
              if(vers != 'furious') return '#000';
              if(expanded) {
                  return d.disengaged ? color(d,i) : '#fff';
              } else if (!expanded) {
                  return !!d.disabled ? color(d,i) : '#fff';
              }
          }
  
          function setBGColor(d,i) {
              if(expanded && vers == 'furious') {
                  return d.disengaged ? '#fff' : color(d,i);
              } else {
                  return !!d.disabled ? '#fff' : color(d,i);
              }
          }
  
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:          {get: function(){return width;}, set: function(_){width=_;}},
          height:         {get: function(){return height;}, set: function(_){height=_;}},
          key:            {get: function(){return getKey;}, set: function(_){getKey=_;}},
          keyFormatter:   {get: function(){return keyFormatter;}, set: function(_){keyFormatter=_;}},
          align:          {get: function(){return align;}, set: function(_){align=_;}},
          rightAlign:     {get: function(){return rightAlign;}, set: function(_){rightAlign=_;}},
          maxKeyLength:   {get: function(){return maxKeyLength;}, set: function(_){maxKeyLength=_;}},
          padding:        {get: function(){return padding;}, set: function(_){padding=_;}},
          updateState:    {get: function(){return updateState;}, set: function(_){updateState=_;}},
          radioButtonMode:{get: function(){return radioButtonMode;}, set: function(_){radioButtonMode=_;}},
          expanded:       {get: function(){return expanded;}, set: function(_){expanded=_;}},
          vers:           {get: function(){return vers;}, set: function(_){vers=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  /* 
  Improvements:
  - consistenly apply no-hover classes to rect isntead of to containing g, see example CSS style for .no-hover rect, rect.no-hover
  - row/column order (user specified) or 'ascending' / 'descending'
  - I haven't tested for transitions between changing datasets
  */
  
  nv.models.heatMap = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 960
          , height = 500
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container
          , xScale = d3.scale.ordinal()
          , yScale = d3.scale.ordinal()
          , colorScale = false
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , getCellValue = function(d) { return d.value }
          , showCellValues = true
          , cellValueFormat = function(d) { return typeof d === 'number' ? d.toFixed(0) : d }
          , cellAspectRatio = false // width / height of cell
          , cellRadius = 2
          , cellBorderWidth = 4 // pixels between cells
          , normalize = false
          , highContrastText = true
          , xDomain
          , yDomain
          , xMetaColorScale = nv.utils.defaultColor()
          , yMetaColorScale = nv.utils.defaultColor()
          , missingDataColor = '#bcbcbc'
          , missingDataLabel = ''
          , metaOffset = 5 // spacing between meta rects and cells
          , xRange
          , yRange
          , xMeta
          , yMeta
          , colorRange
          , colorDomain
          , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')
          , duration = 250
          , xMetaHeight = function(d) { return cellHeight / 3 }
          , yMetaWidth = function(d) { return cellWidth / 3 }
          , showGrid = false
          ;
  
  
  
      //============================================================
      // Aux helper function for heatmap
      //------------------------------------------------------------
      // choose high contrast text color based on background
      // shameful steal: https://github.com/alexandersimoes/d3plus/blob/master/src/color/text.coffee
      function cellTextColor(bgColor) {
  
          if (highContrastText) {
              var rgbColor = d3.rgb(bgColor);
              var r = rgbColor.r;
              var g = rgbColor.g;
              var b = rgbColor.b;
              var yiq = (r * 299 + g * 587 + b * 114) / 1000;
              return yiq >= 128 ? "#404040" : "#EDEDED"; // dark text else light text
          } else {
              return 'black';
          }
      }
  
      /* go through heatmap data and generate array of values
       * for each row/column or for entire dataset; for use in
       * calculating means/medians of data for normalizing
       * @param {str} axis - 'row', 'col' or null
       *
       * @returns {row/column index: [array of values for row/col]}
       * note that if axis is not specified, the return will be
       * {0: [all values in heatmap]}
       */
      function getHeatmapValues(data, axis) {
          var vals = {};
  
          data.forEach(function(cell, i) {
              if (axis == 'row') {
                  if (!(getIY(cell) in vals)) vals[getIY(cell)] = [];
                  vals[getIY(cell)].push(getCellValue(cell));
              } else if (axis == 'col') {
                  if (!(getIX(cell) in vals)) vals[getIX(cell)] = [];
                  vals[getIX(cell)].push(getCellValue(cell));
              } else if (axis == null) { // if calculating stat over entire dataset
                  if (!(0 in vals)) vals[0] = [];
                  vals[0].push(getCellValue(cell)); 
              }
          })
  
          return vals;
      }
  
      // calculate the median absolute deviation of the given array of data
      // https://en.wikipedia.org/wiki/Median_absolute_deviation
      // MAD = median(abs(Xi - median(X)))
      function mad(dat) {
          var med = d3.median(dat);
          var vals = dat.map(function(d) { return Math.abs(d - med); })
          return d3.median(vals);
      }
  
  
      // set cell color based on cell value
      // depending on whether it should be normalized or not
      function cellColor(d) {
          var colorVal = normalize ? getNorm(d) : getCellValue(d);
          return (cellsAreNumeric() && !isNaN(colorVal) || typeof colorVal !== 'undefined') ? colorScale(colorVal) : missingDataColor;
      }
  
      // return the domain of the color data
      // if ordinal data is given for the cells, this will
      // return all possible cells values; otherwise it
      // returns the extent of the cell values
      // will take into account normalization if specified
      function getColorDomain() {
      
          if (cellsAreNumeric()) { // if cell values are numeric
              return normalize ? d3.extent(prepedData, function(d) { return getNorm(d); }) : d3.extent(uniqueColor);
          } else if (!cellsAreNumeric()) { // if cell values are ordinal
              return uniqueColor;
          }
      }
  
      // return true if cells are numeric
      // as opposed to categorical
      function cellsAreNumeric() {
          return typeof uniqueColor[0] === 'number';
      }
  
      /*
       * Normalize input data
       *
       * normalize must be one of centerX, robustCenterX, centerScaleX, robustCenterScaleX, centerAll, 
       * robustCenterAll, centerScaleAll, robustCenterScaleAll where X is either 'Row' or 'Column'
       *
       * - centerX: subtract row/column mean from cell
       * - centerAll: subtract mean of whole data set from cell
       * - centerScaleX: scale so that row/column has mean 0 and variance 1 (Z-score)
       * - centerScaleAll: scale by overall normalization factor so that the whole data set has mean 0 and variance 1 (Z-score)
       * - robustCenterX: subtract row/column median from cell
       * - robustCenterScaleX: subtract row/column median from cell and then scale row/column by median absolute deviation
       * - robustCenterAll: subtract median of whole data set from cell
       * - robustCenterScaleAll: subtract overall median from cell and scale by overall median absolute deviation
       */
      function normalizeData(dat) {
          
          var normTypes = ['centerRow',
              'robustCenterRow',
              'centerScaleRow',
              'robustCenterScaleRow',
              'centerColumn',
              'robustCenterColumn',
              'centerScaleColumn',
              'robustCenterScaleColumn',
              'centerAll',
              'robustCenterAll',
              'centerScaleAll',
              'robustCenterScaleAll'];
  
  
          if(normTypes.indexOf(normalize) != -1) {
  
              var xVals = Object.keys(uniqueX), yVals = Object.keys(uniqueY);
  
              // setup normalization options
              var scale = normalize.includes('Scale') ? true: false,
                  agg = normalize.includes('robust') ? 'median': 'mean',
                  axis = normalize.includes('Row') ? 'row' : normalize.includes('Column') ? 'col' : null,
                  vals = getHeatmapValues(dat, axis);
  
              // calculate mean or median
              // calculate standard dev or median absolute deviation
              var stat = {};
              var dev = {};
              for (var key in vals) {
                  stat[key] = agg == 'mean' ? d3.mean(vals[key]) : d3.median(vals[key]);
                  if (scale) dev[key] = agg == 'mean' ? d3.deviation(vals[key]) : mad(vals[key]);
              }
  
  
              // do the normalizing
              dat.forEach(function(cell, i) {
                  if (cellsAreNumeric()) {
                      if (axis == 'row') {
                          var key = getIY(cell);
                      } else if (axis == 'col') {
                          var key = getIX(cell);
                      } else if (axis == null) {  // if calculating stat over entire dataset
                          var key = 0;
                      }
  
                      var normVal = getCellValue(cell) - stat[key];
                      if (scale) {
                          cell._cellPos.norm = normVal / dev[key];
                      } else {
                          cell._cellPos.norm = normVal;
                      }
                  } else {
                      cell._cellPos.norm = getCellValue(cell); // if trying to normalize ordinal cells, just set norm to cell value
                  }
              })
  
          } else {
              normalize = false; // proper normalize option was not provided, disable it so heatmap still shows colors
          }
  
          return dat;
      }
  
      /*
       * Process incoming data for use with heatmap including:
       * - adding a unique key indexer to each data point (idx)
       * - getting a unique list of all x & y values
       * - generating a position index (x & y) for each data point
       * - sorting that data for correct traversal when generating rect
       * - generating placeholders for missing data
       *
       * In order to allow for the flexibility of the user providing either
       * categorical or quantitative data, we're going to position the cells
       * through indices that we increment based on previously seen data
       * this way we can use ordinal() axes even if the data is quantitative.
       *
       * When we generate the SVG elements, we assumes traversal occures from
       * top to bottom and from left to right.
       *
       * @param data {list} - input data organize as a list of objects
       *
       * @return - copy of input data with additional '_cellPos' key
       *           formatted as {idx: XXX, ix, XXX, iy: XXX}
       *           where idx is a global identifier; ix is an identifier
       *           within each column, and iy is an identifier within
       *           each row. 
       */
      function prepData(data) {
  
          // reinitialize
          uniqueX = {}, // {cell x value: ix index}
          uniqueY = {}, // {cell y value: iy index}
          uniqueColor = [], // [cell color value]
          uniqueXMeta = [], // [cell x metadata value]
          uniqueYMeta = [], // [cell y metadata value]
          uniqueCells = []; // [cell x,y values stored as array]
          var warnings = [];
          var sortedCells = {}; // {cell x values: {cell y value: cell data, ... }, ... }
  
          var ix = 0, iy = 0; // use these indices to position cell in x & y direction
          var combo, idx=0;
          data.forEach(function(cell) {
              var valX = getX(cell),
                  valY = getY(cell),
                  valColor = getCellValue(cell);            
  
              // assemble list of unique values for each dimension
              if (!(valX in uniqueX)) { 
                  uniqueX[valX] = ix; 
                  ix++;
  
                  sortedCells[valX] = {}
  
                  if (typeof xMeta === 'function') uniqueXMeta.push(xMeta(cell));
              }
  
              if (!(valY in uniqueY)) {
                  uniqueY[valY] = iy; 
                  iy++;
  
                  sortedCells[valX][valY] = {}
  
                  if (typeof yMeta === 'function') uniqueYMeta.push(yMeta(cell));
              }
              if (uniqueColor.indexOf(valColor) == -1) uniqueColor.push(valColor)
  
  
              // for each data point, we generate an object of data
              // needed to properly position each cell
              cell._cellPos = {
                  idx: idx,
                  ix: uniqueX[valX],
                  iy: uniqueY[valY],
              }
              idx++;
  
  
              // keep track of row & column combinations we've already seen
              // this prevents the same cells from being generated when
              // the user hasn't provided proper data (one value for each
              // row & column).
              // if properly formatted data is not provided, only the first
              // row & column value is used (the rest are ignored)
              combo = [valX, valY];
              if (!isArrayInArray(uniqueCells, combo)) {
                  uniqueCells.push(combo)
                  sortedCells[valX][valY] = cell;
              } else if (warnings.indexOf(valX + valY) == -1) {
                  warnings.push(valX + valY);
                  console.warn("The row/column position " + valX + "/" + valY + " has multiple values; ensure each cell has only a single value.");
              }
  
          });
  
          uniqueColor = uniqueColor.sort()
  
          // check in sortedCells that each x has all the y's
          // if not, generate an empty placeholder
          // this will also sort all cells from left to right
          // and top to bottom
          var reformatData = [];
          Object.keys(uniqueY).forEach(function(j) {
              Object.keys(uniqueX).forEach(function(i) {
                  var cellVal = sortedCells[i][j];
      
                  if (cellVal) {
                      reformatData.push(cellVal);
                  } else {
                      var cellPos = {
                          idx: idx,
                          ix: uniqueX[i],
                          iy: uniqueY[j],
                      }
                      idx++;
                      reformatData.push({_cellPos: cellPos}); // empty cell placeholder
                  }
              })
          })
  
  
          // normalize data is needed
          return normalize ? normalizeData(reformatData) : reformatData;
  
      }
  
      // https://stackoverflow.com/a/41661388/1153897
      function isArrayInArray(arr, item){
        var item_as_string = JSON.stringify(item);
  
        var contains = arr.some(function(ele){
          return JSON.stringify(ele) === item_as_string;
        });
        return contains;
      }
  
      function removeAllHoverClasses() {
          // remove all hover classes
          d3.selectAll('.cell-hover').classed('cell-hover', false);
          d3.selectAll('.no-hover').classed('no-hover', false);
          d3.selectAll('.row-hover').classed('row-hover', false);
          d3.selectAll('.column-hover').classed('column-hover', false);
      }
  
      // return the formatted cell value if it is
      // a number, otherwise return missingDataLabel
      var cellValueLabel = function(d) {
          var val = !normalize ? cellValueFormat(getCellValue(d)) : cellValueFormat(getNorm(d));
          return (cellsAreNumeric() && !isNaN(val) || typeof val !== 'undefined') ? val : missingDataLabel;
      }
  
      // https://stackoverflow.com/a/16794116/1153897
      // note this returns the obj keys
      function sortObjByVals(obj) {
          return Object.keys(obj).sort(function(a,b){return obj[a]-obj[b]})
      }
  
      // https://stackoverflow.com/a/28191966/1153897
      function getKeyByValue(object, value) {
          //return Object.keys(object).find(key => object[key] === value);
          return Object.keys(object).filter(function(key) {return object[key] === value})[0];
      }
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var prepedData, cellHeight, cellWidth;
      var uniqueX = {}, uniqueY = {}, uniqueColor = [];
      var uniqueXMeta = [], uniqueYMeta = [], uniqueCells = []
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
      var RdYlBu = ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"];
  
      var getCellPos = function(d) { return d._cellPos; };
      var getIX = function(d) { return getCellPos(d).ix; } // get the given cell's x index position
      var getIY = function(d) { return getCellPos(d).iy; } // get the given cell's y index position
      var getNorm = function(d) { return getCellPos(d).norm; }
      var getIdx = function(d) { return getCellPos(d).idx; }
  
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
  
              prepedData = prepData(data);
  
              var availableWidth = width - margin.left - margin.right,
                  availableHeight = height - margin.top - margin.bottom;
  
              // available width/height set the cell dimenions unless
              // the aspect ratio is defined - in that case the cell
              // height is adjusted and availableHeight updated
              cellWidth = availableWidth / Object.keys(uniqueX).length;
              cellHeight = cellAspectRatio ? cellWidth / cellAspectRatio : availableHeight / Object.keys(uniqueY).length;
              if (cellAspectRatio) availableHeight = cellHeight * Object.keys(uniqueY).length - margin.top - margin.bottom;
  
  
              container = d3.select(this);
              nv.utils.initSVG(container);
    
              // Setup Scales
              xScale.domain(xDomain || sortObjByVals(uniqueX))
                    .rangeBands(xRange || [0, availableWidth-cellBorderWidth/2]);
              yScale.domain(yDomain || sortObjByVals(uniqueY))
                    .rangeBands(yRange || [0, availableHeight-cellBorderWidth/2]);
              colorScale = cellsAreNumeric() ? d3.scale.quantize() : d3.scale.ordinal();
              colorScale.domain(colorDomain || getColorDomain())
                    .range(colorRange || RdYlBu);
  
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-heatMapWrap').data([prepedData]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-heatMapWrap');
              wrapEnter
                  .append('g')
                  .attr('class','cellWrap')
  
              wrap.watchTransition(renderWatch, 'nv-wrap: heatMapWrap')
                  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              var gridWrap = wrapEnter
                  .append('g')
                  .attr('class','cellGrid')
                  .style('opacity',1e-6)
  
              var gridLinesV = wrap.select('.cellGrid').selectAll('.gridLines.verticalGrid')
                  .data(Object.values(uniqueX).concat([Object.values(uniqueX).length]))
                  
              gridLinesV.enter()
                  .append('line')
                  .attr('class','gridLines verticalGrid')
  
              gridLinesV.exit()
                  .remove()
  
              var gridLinesH = wrap.select('.cellGrid').selectAll('.gridLines.horizontalGrid')
                  .data(Object.values(uniqueY).concat([Object.values(uniqueY).length]))
                  
              gridLinesH.enter()
                  .append('line')
                  .attr('class','gridLines horizontalGrid')
  
              gridLinesH.exit()
                  .remove()
  
              var cellWrap = wrap.select('.cellWrap')
                  .selectAll(".nv-cell")
                  .data(function(d) { return d; }, function(e) { return getIdx(e); })
  
              var xMetaWrap = wrapEnter
                  .append('g')
                  .attr('class','xMetaWrap')
                  .attr("transform", function() { return "translate(0," + (-xMetaHeight()-cellBorderWidth-metaOffset) + ")" })
  
              var xMetas = wrap.select('.xMetaWrap').selectAll('.x-meta')
                  .data(uniqueXMeta)
  
              var xMetaEnter = xMetas
                  .enter()
                  .append('rect')
                  .attr('class','x-meta meta')
                  .attr("width", cellWidth-cellBorderWidth)
                  .attr("height", xMetaHeight())
                  .attr("transform", "translate(0,0)")
                  .attr("fill", function(d) { return xMetaColorScale(d); })
  
              var yMetaWrap = wrapEnter
                  .append('g')
                  .attr('class','yMetaWrap')
                  .attr("transform", function(d,i) { return "translate(" + (-yMetaWidth()-cellBorderWidth-metaOffset) + ",0)" })
  
              var yMetas = wrap.select('.yMetaWrap').selectAll('.y-meta')
                  .data(uniqueYMeta)
  
              var yMetaEnter = yMetas
                  .enter()
                  .append('rect')
                  .attr('class','y-meta meta')
                  .attr("width", yMetaWidth())
                  .attr("height", cellHeight-cellBorderWidth)
                  .attr("transform", function(d,i) { return "translate(0,0)" })
                  .attr("fill", function(d,i) { return yMetaColorScale(d); })
  
              xMetas.exit().remove()
              yMetas.exit().remove()
            
              // CELLS    
              var cellsEnter = cellWrap
                  .enter()
                  .append('g')
                  .style('opacity', 1e-6)
                  .attr("transform", function(d) { return "translate(0," + getIY(d) * cellHeight + ")" }) // enter all g's here for a sweep-right transition
                  .attr('data-row', function(d) { return getIY(d) })
                  .attr('data-column', function(d) { return getIX(d) });
  
              cellsEnter
                  .append("rect") 
  
              cellsEnter
                  .append('text')
                  .attr('text-anchor', 'middle')
                  .attr("dy", 4)
                  .attr("class","cell-text")
  
              
              // transition cell (rect) size
              cellWrap.selectAll('rect')
                  .watchTransition(renderWatch, 'heatMap: rect')
                  .attr("width", cellWidth-cellBorderWidth)
                  .attr("height", cellHeight-cellBorderWidth)
                  .attr('rx', cellRadius)
                  .attr('ry', cellRadius)
                  .style('stroke', function(d) { return cellColor(d) })
  
              // transition cell (g) position, opacity and fill
              cellWrap
                  .attr("class",function(d) { return isNaN(getCellValue(d)) ? 'nv-cell cell-missing' : 'nv-cell'}) 
                  .watchTransition(renderWatch, 'heatMap: cells')
                  .style({
                      'opacity': 1,
                      'fill': function(d) { return cellColor(d) },
                  })
                  .attr("transform", function(d) { return "translate(" + getIX(d) * cellWidth + "," + getIY(d) * cellHeight + ")" })
                  .attr("class",function(d) { return isNaN(getCellValue(d)) ? 'nv-cell cell-missing' : 'nv-cell'}) 
  
              cellWrap.exit().remove();
  
              // transition text position and fill
              cellWrap.selectAll('text')
                  .watchTransition(renderWatch, 'heatMap: cells text')
                  .text(function(d) { return cellValueLabel(d); })
                  .attr("x", function(d) { return (cellWidth-cellBorderWidth) / 2; })
                  .attr("y", function(d) { return (cellHeight-cellBorderWidth) / 2; })
                  .style("fill", function(d) { return cellTextColor(cellColor(d)) })
                  .style('opacity', function() { return showCellValues ? 1 : 0 })
  
              // transition grid
              wrap.selectAll('.verticalGrid')
                  .watchTransition(renderWatch, 'heatMap: gridLines') 
                  .attr('y1',0)
                  .attr('y2',availableHeight-cellBorderWidth)
                  .attr('x1',function(d) { return d*cellWidth-cellBorderWidth/2; })
                  .attr('x2',function(d) { return d*cellWidth-cellBorderWidth/2; })
  
              var numHLines = Object.keys(uniqueY).length;
              wrap.selectAll('.horizontalGrid')
                  .watchTransition(renderWatch, 'heatMap: gridLines') 
                  .attr('x1',function(d) { return (d == 0 || d == numHLines) ? -cellBorderWidth : 0 })
                  .attr('x2',function(d) { return (d == 0 || d == numHLines) ? availableWidth : availableWidth-cellBorderWidth})
                  .attr('y1',function(d) { return d*cellHeight-cellBorderWidth/2; })
                  .attr('y2',function(d) { return d*cellHeight-cellBorderWidth/2; })
  
              wrap.select('.cellGrid')
                  .watchTransition(renderWatch, 'heatMap: gridLines')
                  .style({
                      'stroke-width': cellBorderWidth,
                      'opacity': function() { return showGrid ? 1 : 1e-6 },
                  })
  
              var xMetaRect = wrap.selectAll('.x-meta')
              var yMetaRect = wrap.selectAll('.y-meta')
              var allMetaRect = wrap.selectAll('.meta')
  
              // transition meta rect size
              xMetas
                  .watchTransition(renderWatch, 'heatMap: xMetaRect') 
                  .attr("width", cellWidth-cellBorderWidth)
                  .attr("height", xMetaHeight())
                  .attr("transform", function(d,i) { return "translate(" + (i * cellWidth) + ",0)" })
  
              yMetas
                  .watchTransition(renderWatch, 'heatMap: yMetaRect') 
                  .attr("width", yMetaWidth())
                  .attr("height", cellHeight-cellBorderWidth)
                  .attr("transform", function(d,i) { return "translate(0," + (i * cellHeight) + ")" })
  
  
              // transition position of meta wrap g & opacity
              wrap.select('.xMetaWrap')
                  .watchTransition(renderWatch, 'heatMap: xMetaWrap') 
                  .attr("transform", function(d,i) { return "translate(0," + (-xMetaHeight()-cellBorderWidth-metaOffset) + ")" })
                  .style("opacity", function() { return xMeta !== false ? 1 : 0 })
              wrap.select('.yMetaWrap')
                  .watchTransition(renderWatch, 'heatMap: yMetaWrap') 
                  .attr("transform", function(d,i) { return "translate(" + (-yMetaWidth()-cellBorderWidth-metaOffset) + ",0)" })
                  .style("opacity", function() { return yMeta !== false ? 1 : 0 })
  
              // TOOLTIPS
              cellWrap
                  .on('mouseover', function(d,i) {
  
                      var idx = getIdx(d);
                      var ix = getIX(d);
                      var iy = getIY(d);
  
                      // set the proper classes for all cells
                      // hover row gets class .row-hover
                      // hover column gets class .column-hover
                      // hover cell gets class .cell-hover
                      // all remaining cells get class .no-hover
                      d3.selectAll('.nv-cell').each(function(e) {
                          if (idx == getIdx(e)) {
                              d3.select(this).classed('cell-hover', true);
                              d3.select(this).classed('no-hover', false);
                          } else {
                              d3.select(this).classed('no-hover', true);
                              d3.select(this).classed('cell-hover', false);
                          }
                          if (ix == getIX(e)) {
                              d3.select(this).classed('no-hover', false);
                              d3.select(this).classed('column-hover', true);
                          }
                          if (iy == getIY(e)) {
                              d3.select(this).classed('no-hover', false);
                              d3.select(this).classed('row-hover', true);
                          }
                      })
      
                      // set hover classes for column metadata
                      d3.selectAll('.x-meta').each(function(e, j) {
                          if (j == ix) {
                              d3.select(this).classed('cell-hover', true);
                              d3.select(this).classed('no-hover', false);
                          } else {
                              d3.select(this).classed('no-hover', true);
                              d3.select(this).classed('cell-hover', false);
                          }
                      });
  
                      // set hover class for row metadata
                      d3.selectAll('.y-meta').each(function(e, j) {
                          if (j == iy) {
                              d3.select(this).classed('cell-hover', true);
                              d3.select(this).classed('no-hover', false);
                          } else {
                              d3.select(this).classed('no-hover', true);
                              d3.select(this).classed('cell-hover', false);
                          }
                      });
                      
                      dispatch.elementMouseover({
                          value: getKeyByValue(uniqueX, ix) + ' & ' + getKeyByValue(uniqueY, iy), 
                          series: {
                                  value: cellValueLabel(d), 
                                  color: d3.select(this).select('rect').style("fill")
                                  },
                          e: d3.event,
                      });
  
                  })
                  .on('mouseout', function(d,i) {
  
                      // allow tooltip to remain even when mouse is over the
                      // space between the cell;
                      // this prevents cells from "flashing" when transitioning
                      // between cells
                      var bBox = d3.select(this).select('rect').node().getBBox();
                      var coordinates = d3.mouse(d3.select('.nv-heatMap').node());
                      var x = coordinates[0];
                      var y = coordinates[1];
  
                      // we only trigger mouseout when mouse moves outside of
                      // .nv-heatMap
                      if (x + cellBorderWidth >= availableWidth || y + cellBorderWidth >= availableHeight || x < 0 || y < 0) {
                          // remove all hover classes
                          removeAllHoverClasses();
  
                          dispatch.elementMouseout({e: d3.event});
                      }
                  })
                  .on('mousemove', function(d,i) {
  
                      dispatch.elementMousemove({e: d3.event});
                  })
  
              allMetaRect
                  .on('mouseover', function(d,i) {
  
                      // true if hovering over a row metadata rect
                      var isColMeta = d3.select(this).attr('class').indexOf('x-meta') != -1 ? true : false;
  
                      // apply proper .row-hover & .column-hover
                      // classes to cells
                      d3.selectAll('.nv-cell').each(function(e) {
  
                          if (isColMeta && i == getIX(e)) {
                              d3.select(this).classed('column-hover', true);
                              d3.select(this).classed('no-hover', false);
                          } else if (!isColMeta && i-uniqueXMeta.length == getIY(e)) {
                              // since allMetaRect selects all the meta rects, the index for the y's will
                              // be offset by the number of x rects. TODO - write seperate tooltip sections
                              // for x meta rect & y meta rect
                              d3.select(this).classed('row-hover', true);
                              d3.select(this).classed('no-hover', false);
                          } else {
                              d3.select(this).classed('no-hover', true);
                              d3.select(this).classed('column-hover', false);
                              d3.select(this).classed('row-hover', false);
                          }
                          d3.select(this).classed('cell-hover', false);
                      })
  
                      // apply proper .row-hover & .column-hover
                      // classes to meta rects
                      d3.selectAll('.meta').classed('no-hover', true);
                      d3.select(this).classed('cell-hover', true);
                      d3.select(this).classed('no-hover', false);
  
                      dispatch.elementMouseover({
                          value: isColMeta ? 'Column meta' : 'Row meta',
                          series: { value: d, color: d3.select(this).style('fill'), }
                      });
                  })
                  .on('mouseout', function(d,i) {
  
                      // true if hovering over a row metadata rect
                      var isColMeta = d3.select(this).attr('class').indexOf('x-meta') != -1 ? true : false;
  
                      // allow tooltip to remain even when mouse is over the
                      // space between the cell;
                      // this prevents cells from "flashing" when transitioning
                      // between cells
                      var bBox = d3.select(this).node().getBBox();
                      var coordinates = d3.mouse(d3.select(isColMeta ? '.xMetaWrap' : '.yMetaWrap').node());
                      var x = coordinates[0];
                      var y = coordinates[1];
  
                      if ( y < 0 || x < 0 || 
                          (isColMeta && x + cellBorderWidth >= availableWidth) ||
                          (!isColMeta && y + cellBorderWidth >= availableHeight)
                      ) {
                          // remove all hover classes
                          removeAllHoverClasses();
  
                          dispatch.elementMouseout({e: d3.event});
                      }
                  })
                  .on('mousemove', function(d,i) {
                      dispatch.elementMousemove({e: d3.event});
                  })
  
          });
  
  
          renderWatch.renderEnd('heatMap immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:   {get: function(){return width;}, set: function(_){width=_;}},
          height:  {get: function(){return height;}, set: function(_){height=_;}},
          showCellValues: {get: function(){return showCellValues;}, set: function(_){showCellValues=_;}},
          x:       {get: function(){return getX;}, set: function(_){getX=_;}}, // data attribute for horizontal axis
          y:       {get: function(){return getY;}, set: function(_){getY=_;}}, // data attribute for vertical axis
          cellValue:       {get: function(){return getCellValue;}, set: function(_){getCellValue=_;}}, // data attribute that sets cell value and color
          missingDataColor:  {get: function(){return missingDataColor;}, set: function(_){missingDataColor=_;}},
          missingDataLabel:  {get: function(){return missingDataLabel;}, set: function(_){missingDataLabel=_;}},
          xScale:  {get: function(){return xScale;}, set: function(_){xScale=_;}},
          yScale:  {get: function(){return yScale;}, set: function(_){yScale=_;}},
          colorScale:  {get: function(){return colorScale;}, set: function(_){colorScale=_;}}, // scale to map cell values to colors
          xDomain:  {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain:  {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
          colorRange:  {get: function(){return colorRange;}, set: function(_){colorRange=_;}},
          colorDomain:  {get: function(){return colorDomain;}, set: function(_){colorDomain=_;}},
          xMeta:  {get: function(){return xMeta;}, set: function(_){xMeta=_;}},
          yMeta:  {get: function(){return yMeta;}, set: function(_){yMeta=_;}},
          xMetaColorScale:  {get: function(){return color;}, set: function(_){color = nv.utils.getColor(_);}},
          yMetaColorScale:  {get: function(){return color;}, set: function(_){color = nv.utils.getColor(_);}},
          cellAspectRatio:  {get: function(){return cellAspectRatio;}, set: function(_){cellAspectRatio=_;}}, // cell width / height
          cellRadius:  {get: function(){return cellRadius;}, set: function(_){cellRadius=_;}}, // cell width / height
          cellHeight:  {get: function(){return cellHeight;}}, // TODO - should not be exposed since we don't want user setting this
          cellWidth:   {get: function(){return cellWidth;}}, // TODO - should not be exposed since we don't want user setting this
          normalize:   {get: function(){return normalize;}, set: function(_){normalize=_;}},
          cellBorderWidth:     {get: function(){return cellBorderWidth;}, set: function(_){cellBorderWidth=_;}},
          highContrastText:    {get: function(){return highContrastText;}, set: function(_){highContrastText=_;}},
          cellValueFormat:     {get: function(){return cellValueFormat;}, set: function(_){cellValueFormat=_;}},
          id:                  {get: function(){return id;}, set: function(_){id=_;}},
          metaOffset:          {get: function(){return metaOffset;}, set: function(_){metaOffset=_;}},
          xMetaHeight:         {get: function(){return xMetaHeight;}, set: function(_){xMetaHeight=_;}},
          yMetaWidth:          {get: function(){return yMetaWidth;}, set: function(_){yMetaWidth=_;}},
          showGrid:          {get: function(){return showGrid;}, set: function(_){showGrid=_;}},
  
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
          }}
      });
  
      nv.utils.initOptions(chart);
  
  
      return chart;
  };
  /* Heatmap Chart Type
  
  A heatmap is a graphical representation of data where the individual values
  contained in a matrix are represented as colors within cells. Furthermore,
  metadata can be associated with each of the matrix rows or columns. By grouping
  these rows/columns together by a given metadata value, data trends can be spotted.
  
  Format for input data should be:
  var data = [
      {day: 'mo', hour: '1a', value: 16, timeperiod: 'early morning', weekperiod: 'week', category: 1},
      {day: 'mo', hour: '2a', value: 20, timeperiod: 'early morning', weekperiod: 'week', category: 2},
      {day: 'mo', hour: '3a', value: 0, timeperiod: 'early morning', weekperiod: 'week', category: 1},
      ...
  ]
  where the keys 'day' and 'hour' specify the row/column of the heatmap, 'value' specifies the  cell
  value and the keys 'timeperiod', 'weekperiod' and 'week' are extra metadata that can be associated
  with rows/columns.
  
  
  Options for chart:
  */
  nv.models.heatMapChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var heatMap = nv.models.heatMap()
          , legend = nv.models.legend()
          , legendRowMeta = nv.models.legend()
          , legendColumnMeta = nv.models.legend()
          , tooltip = nv.models.tooltip()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
          ;
  
  
      var margin = {top: 20, right: 10, bottom: 50, left: 60}
          , marginTop = null
          , width = null
          , height = null
          , color = nv.utils.getColor()
          , showLegend = true
          , staggerLabels = false
          , showXAxis = true
          , showYAxis = true
          , alignYAxis = 'left'
          , alignXAxis = 'top'
          , rotateLabels = 0
          , title = false
          , x
          , y
          , noData = null
          , dispatch = d3.dispatch('beforeUpdate','renderEnd')
          , duration = 250
          ;
  
      xAxis
          .orient(alignXAxis)
          .showMaxMin(false)
          .tickFormat(function(d) { return d })
      ;
      yAxis
          .orient(alignYAxis)
          .showMaxMin(false)
          .tickFormat(function(d) { return d })
      ;
  
      tooltip
          .duration(0)
          .headerEnabled(true)
          .keyFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          })
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      // https://bl.ocks.org/mbostock/4573883
      // get max/min range for all the quantized cell values
      // returns an array where each element is [start,stop]
      // of color bin
      function quantizeLegendValues() {
  
          var e = heatMap.colorScale(), legendVals;
  
          if (typeof e.domain()[0] === 'string') { // if color scale is ordinal
  
              legendVals = e.domain();
  
          } else { // if color scale is numeric
  
              legendVals = e.range().map(function(color) {
                var d = e.invertExtent(color);
                if (d[0] === null) d[0] = e.domain()[0];
                if (d[1] === null) d[1] = e.domain()[1];
                return d;
              })
  
          }
  
          return legendVals
  
      }
  
      // return true if row metadata specified by user
      function hasRowMeta() {
          return typeof heatMap.yMeta() === 'function'
      }
      // return true if col metadata specified by user
      function hasColumnMeta() {
          return typeof heatMap.xMeta() === 'function'
      }
  
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(heatMap);
          renderWatch.models(xAxis);
          renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this),
                  that = this;
              nv.utils.initSVG(container);
  
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() {
                  dispatch.beforeUpdate();
                  container.transition().duration(duration).call(chart);
              };
              chart.container = this;
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length) {
                  nv.utils.noData(chart, container);
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = heatMap.xScale();
              y = heatMap.yScale();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap').append('g');
              var g = wrap.select('g');
  
  
              gEnter.append('g').attr('class', 'nv-heatMap');
              gEnter.append('g').attr('class', 'nv-legendWrap');
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis')
  
              g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
  
              heatMap
                  .width(availableWidth)
                  .height(availableHeight);
  
  
              var heatMapWrap = g.select('.nv-heatMap')
                  .datum(data.filter(function(d) { return !d.disabled }));
  
  
              heatMapWrap.transition().call(heatMap);
  
  
              if (heatMap.cellAspectRatio()) {
                  availableHeight = heatMap.cellHeight() * y.domain().length;
                  heatMap.height(availableHeight);
              }
  
  
              // Setup Axes
              xAxis
                  .scale(x)
                  ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                  .tickSize(-availableHeight, 0);
  
              var axisX = g.select('.nv-x.nv-axis')
  
              axisX.call(xAxis)
                  .watchTransition(renderWatch, 'heatMap: axisX')
                  .selectAll('.tick')
                  .style('opacity', function() { return showXAxis ? 1 : 0 } )
  
              var xTicks = axisX.selectAll('g');
  
              xTicks
                  .selectAll('.tick text')
                  .attr('transform', function(d,i,j) {
                      var rot = rotateLabels != 0 ? rotateLabels : '0';
                      var stagger = staggerLabels ? j % 2 == 0 ? '5' : '17' : '0';
                      return 'translate(0, ' + stagger + ') rotate(' + rot + ' 0,0)';
                  })
                  .style('text-anchor', rotateLabels > 0 ? 'start' : rotateLabels < 0 ? 'end' : 'middle');
  
              // position text in center of meta rects
              var yPos = -5;
              if (hasColumnMeta()) {
                  axisX.selectAll('text').style('text-anchor', 'middle')
                  yPos = -heatMap.xMetaHeight()()/2 - heatMap.metaOffset() + 3;
              }
  
              // adjust position of axis based on presence of metadata group
              if (alignXAxis == 'bottom') {
                  axisX
                      .watchTransition(renderWatch, 'heatMap: axisX')
                      .attr("transform", "translate(0," + (availableHeight - yPos) + ")");
                  if (heatMap.xMeta() !== false) { // if showing x metadata
                      var pos = availableHeight+heatMap.metaOffset()+heatMap.cellBorderWidth()
                      g.select('.xMetaWrap')
                          .watchTransition(renderWatch, 'heatMap: xMetaWrap')
                          .attr("transform", function(d,i) { return "translate(0," + pos + ")" })
                  }
              } else {
                  axisX
                      .watchTransition(renderWatch, 'heatMap: axisX')
                      .attr("transform", "translate(0," + yPos + ")");
              }
  
  
              yAxis
                  .scale(y)
                  ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                  .tickSize( -availableWidth, 0);
  
              var axisY = g.select('.nv-y.nv-axis')
  
              axisY.call(yAxis)
                  .watchTransition(renderWatch, 'heatMap: axisY')
                  .selectAll('.tick')
                  .style('opacity', function() { return showYAxis ? 1 : 0 } )
  
              // position text in center of meta rects
              var xPos = -5;
              if (hasRowMeta()) {
                  axisY.selectAll('text').style('text-anchor', 'middle')
                  xPos = -heatMap.yMetaWidth()()/2 - heatMap.metaOffset();
              }
  
              // adjust position of axis based on presence of metadata group
              if (alignYAxis == 'right') {
                  axisY.attr("transform", "translate(" + (availableWidth - xPos) + ",0)");
                  if (heatMap.yMeta() !== false) { // if showing y meatdata
                      var pos = availableWidth+heatMap.metaOffset()+heatMap.cellBorderWidth()
                      g.select('.yMetaWrap')
                          .watchTransition(renderWatch, 'heatMap: yMetaWrap')
                          .attr("transform", function(d,i) { return "translate(" + pos + ",0)" })
                  }
              } else {
                  axisY.attr("transform", "translate(" + xPos + ",0)");
              }
  
  
  
              // Legend
              var legendWrap = g.select('.nv-legendWrap')
  
              legend
                  .width(availableWidth)
                  .color(heatMap.colorScale().range())
  
              var legendVal = quantizeLegendValues().map(function(d) {
                  if (Array.isArray(d)) { // if cell values are numeric
                      return {key: d[0].toFixed(1) + " - " + d[1].toFixed(1)};
                  } else { // if cell values are ordinal
                      return {key: d};
                  }
              })
              
  
              legendWrap
                  .datum(legendVal)
                  .call(legend)
                  .attr('transform', 'translate(0,' + (alignXAxis == 'top' ? availableHeight : -30) + ')'); // TODO: more intelligent offset (-30) when top aligning legend
  
              legendWrap
                  .watchTransition(renderWatch, 'heatMap: nv-legendWrap')
                  .style('opacity', function() { return showLegend ? 1 : 0 } )
  
          });
  
          // axis don't have a flag for disabling the zero line, so we do it manually
          d3.selectAll('.nv-axis').selectAll('line')
              .style('stroke-opacity', 0)
          d3.select('.nv-y').select('path.domain').remove()
  
          renderWatch.renderEnd('heatMap chart immediate');
  
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      heatMap.dispatch.on('elementMouseover.tooltip', function(evt) {
          tooltip.data(evt).hidden(false);
      });
  
      heatMap.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      heatMap.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.heatMap = heatMap;
      chart.legend = legend;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          noData:     {get: function(){return noData;}, set: function(_){noData=_;}},
          showXAxis:     {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis:     {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
          rotateLabels:  {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              heatMap.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
          }},
          alignYAxis: {get: function(){return alignYAxis;}, set: function(_){
              alignYAxis = _;
              yAxis.orient(_);
          }},
          alignXAxis: {get: function(){return alignXAxis;}, set: function(_){
              alignXAxis = _;
              xAxis.orient(_);
          }},
      });
  
      nv.utils.inheritOptions(chart, heatMap);
      nv.utils.initOptions(chart);
  
      return chart;
  }
  //TODO: consider deprecating and using multibar with single series for this
  nv.models.historicalBar = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = null
          , height = null
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container = null
          , x = d3.scale.linear()
          , y = d3.scale.linear()
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , forceX = []
          , forceY = [0]
          , padData = false
          , clipEdge = true
          , color = nv.utils.defaultColor()
          , xDomain
          , yDomain
          , xRange
          , yRange
          , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')
          , interactive = true
          ;
  
      var renderWatch = nv.utils.renderWatch(dispatch, 0);
  
      function chart(selection) {
          selection.each(function(data) {
              renderWatch.reset();
  
              container = d3.select(this);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              nv.utils.initSVG(container);
  
              // Setup Scales
              x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));
  
              if (padData)
                  x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
              else
                  x.range(xRange || [0, availableWidth]);
  
              y.domain(yDomain || d3.extent(data[0].values.map(getY).concat(forceY) ))
                  .range(yRange || [availableHeight, 0]);
  
              // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
              if (x.domain()[0] === x.domain()[1])
                  x.domain()[0] ?
                      x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                      : x.domain([-1,1]);
  
              if (y.domain()[0] === y.domain()[1])
                  y.domain()[0] ?
                      y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                      : y.domain([-1,1]);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-historicalBar-' + id).data([data[0].values]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBar-' + id);
              var defsEnter = wrapEnter.append('defs');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-bars');
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              container
                  .on('click', function(d,i) {
                      dispatch.chartClick({
                          data: d,
                          index: i,
                          pos: d3.event,
                          id: id
                      });
                  });
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-chart-clip-path-' + id)
                  .append('rect');
  
              wrap.select('#nv-chart-clip-path-' + id + ' rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');
  
              var bars = wrap.select('.nv-bars').selectAll('.nv-bar')
                  .data(function(d) { return d }, function(d,i) {return getX(d,i)});
              bars.exit().remove();
  
              bars.enter().append('rect')
                  .attr('x', 0 )
                  .attr('y', function(d,i) {  return nv.utils.NaNtoZero(y(Math.max(0, getY(d,i)))) })
                  .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.abs(y(getY(d,i)) - y(0))) })
                  .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; })
                  .on('mouseover', function(d,i) {
                      if (!interactive) return;
                      d3.select(this).classed('hover', true);
                      dispatch.elementMouseover({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
  
                  })
                  .on('mouseout', function(d,i) {
                      if (!interactive) return;
                      d3.select(this).classed('hover', false);
                      dispatch.elementMouseout({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('mousemove', function(d,i) {
                      if (!interactive) return;
                      dispatch.elementMousemove({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('click', function(d,i) {
                      if (!interactive) return;
                      var element = this;
                      dispatch.elementClick({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill"),
                          event: d3.event,
                          element: element
                      });
                      d3.event.stopPropagation();
                  })
                  .on('dblclick', function(d,i) {
                      if (!interactive) return;
                      dispatch.elementDblClick({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                      d3.event.stopPropagation();
                  });
  
              bars
                  .attr('fill', function(d,i) { return color(d, i); })
                  .attr('class', function(d,i,j) { return (getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i })
                  .watchTransition(renderWatch, 'bars')
                  .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; })
                  //TODO: better width calculations that don't assume always uniform data spacing;w
                  .attr('width', (availableWidth / data[0].values.length) * .9 );
  
              bars.watchTransition(renderWatch, 'bars')
                  .attr('y', function(d,i) {
                      var rval = getY(d,i) < 0 ?
                          y(0) :
                              y(0) - y(getY(d,i)) < 1 ?
                          y(0) - 1 :
                          y(getY(d,i));
                      return nv.utils.NaNtoZero(rval);
                  })
                  .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.max(Math.abs(y(getY(d,i)) - y(0)),1)) });
  
          });
  
          renderWatch.renderEnd('historicalBar immediate');
          return chart;
      }
  
      //Create methods to allow outside functions to highlight a specific bar.
      chart.highlightPoint = function(pointIndex, isHoverOver) {
          container
              .select(".nv-bars .nv-bar-0-" + pointIndex)
              .classed("hover", isHoverOver)
          ;
      };
  
      chart.clearHighlights = function() {
          container
              .select(".nv-bars .nv-bar.hover")
              .classed("hover", false)
          ;
      };
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:   {get: function(){return width;}, set: function(_){width=_;}},
          height:  {get: function(){return height;}, set: function(_){height=_;}},
          forceX:  {get: function(){return forceX;}, set: function(_){forceX=_;}},
          forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
          padData: {get: function(){return padData;}, set: function(_){padData=_;}},
          x:       {get: function(){return getX;}, set: function(_){getX=_;}},
          y:       {get: function(){return getY;}, set: function(_){getY=_;}},
          xScale:  {get: function(){return x;}, set: function(_){x=_;}},
          yScale:  {get: function(){return y;}, set: function(_){y=_;}},
          xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
          clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
          id:          {get: function(){return id;}, set: function(_){id=_;}},
          interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.historicalBarChart = function(bar_model) {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var bars = bar_model || nv.models.historicalBar()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
          , legend = nv.models.legend()
          , interactiveLayer = nv.interactiveGuideline()
          , tooltip = nv.models.tooltip()
          ;
  
  
      var margin = {top: 30, right: 90, bottom: 50, left: 90}
          , marginTop = null
          , color = nv.utils.defaultColor()
          , width = null
          , height = null
          , showLegend = false
          , showXAxis = true
          , showYAxis = true
          , rightAlignYAxis = false
          , useInteractiveGuideline = false
          , x
          , y
          , state = {}
          , defaultState = null
          , noData = null
          , dispatch = d3.dispatch('tooltipHide', 'stateChange', 'changeState', 'renderEnd')
          , transitionDuration = 250
          ;
  
      xAxis.orient('bottom').tickPadding(7);
      yAxis.orient( (rightAlignYAxis) ? 'right' : 'left');
      tooltip
          .duration(0)
          .headerEnabled(false)
          .valueFormatter(function(d, i) {
              return yAxis.tickFormat()(d, i);
          })
          .headerFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          });
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch, 0);
  
      function chart(selection) {
          selection.each(function(data) {
              renderWatch.reset();
              renderWatch.models(bars);
              if (showXAxis) renderWatch.models(xAxis);
              if (showYAxis) renderWatch.models(yAxis);
  
              var container = d3.select(this),
                  that = this;
              nv.utils.initSVG(container);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
              chart.container = this;
  
              //set state.disabled
              state.disabled = data.map(function(d) { return !!d.disabled });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              // Display noData message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container)
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = bars.xScale();
              y = bars.yScale();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-historicalBarChart').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBarChart').append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis');
              gEnter.append('g').attr('class', 'nv-barsWrap');
              gEnter.append('g').attr('class', 'nv-legendWrap');
              gEnter.append('g').attr('class', 'nv-interactive');
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  legend.width(availableWidth);
  
                  g.select('.nv-legendWrap')
                      .datum(data)
                      .call(legend);
  
                  if (!marginTop && legend.height() !== margin.top) {
                      margin.top = legend.height();
                      availableHeight = nv.utils.availableHeight(height, container, margin);
                  }
  
                  wrap.select('.nv-legendWrap')
                      .attr('transform', 'translate(0,' + (-margin.top) +')')
              }
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              if (rightAlignYAxis) {
                  g.select(".nv-y.nv-axis")
                      .attr("transform", "translate(" + availableWidth + ",0)");
              }
  
              //Set up interactive layer
              if (useInteractiveGuideline) {
                  interactiveLayer
                      .width(availableWidth)
                      .height(availableHeight)
                      .margin({left:margin.left, top:margin.top})
                      .svgContainer(container)
                      .xScale(x);
                  wrap.select(".nv-interactive").call(interactiveLayer);
              }
              bars
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled }));
  
              var barsWrap = g.select('.nv-barsWrap')
                  .datum(data.filter(function(d) { return !d.disabled }));
              barsWrap.transition().call(bars);
  
              // Setup Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize(-availableHeight, 0);
  
                  g.select('.nv-x.nv-axis')
                      .attr('transform', 'translate(0,' + y.range()[0] + ')');
                  g.select('.nv-x.nv-axis')
                      .transition()
                      .call(xAxis);
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                      .tickSize( -availableWidth, 0);
  
                  g.select('.nv-y.nv-axis')
                      .transition()
                      .call(yAxis);
              }
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              interactiveLayer.dispatch.on('elementMousemove', function(e) {
                  bars.clearHighlights();
  
                  var singlePoint, pointIndex, pointXLocation, allData = [];
                  data
                      .filter(function(series, i) {
                          series.seriesIndex = i;
                          return !series.disabled;
                      })
                      .forEach(function(series,i) {
                          pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                          bars.highlightPoint(pointIndex,true);
                          var point = series.values[pointIndex];
                          if (point === undefined) return;
                          if (singlePoint === undefined) singlePoint = point;
                          if (pointXLocation === undefined) pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                          allData.push({
                              key: series.key,
                              value: chart.y()(point, pointIndex),
                              color: color(series,series.seriesIndex),
                              data: series.values[pointIndex]
                          });
                      });
  
                  var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));
                  interactiveLayer.tooltip
                      .valueFormatter(function(d,i) {
                          return yAxis.tickFormat()(d);
                      })
                      .data({
                          value: xValue,
                          index: pointIndex,
                          series: allData
                      })();
  
                  interactiveLayer.renderGuideLine(pointXLocation);
  
              });
  
              interactiveLayer.dispatch.on("elementMouseout",function(e) {
                  dispatch.tooltipHide();
                  bars.clearHighlights();
              });
  
              legend.dispatch.on('legendClick', function(d,i) {
                  d.disabled = !d.disabled;
  
                  if (!data.filter(function(d) { return !d.disabled }).length) {
                      data.map(function(d) {
                          d.disabled = false;
                          wrap.selectAll('.nv-series').classed('disabled', false);
                          return d;
                      });
                  }
  
                  state.disabled = data.map(function(d) { return !!d.disabled });
                  dispatch.stateChange(state);
  
                  selection.transition().call(chart);
              });
  
              legend.dispatch.on('legendDblclick', function(d) {
                  //Double clicking should always enable current series, and disabled all others.
                  data.forEach(function(d) {
                      d.disabled = true;
                  });
                  d.disabled = false;
  
                  state.disabled = data.map(function(d) { return !!d.disabled });
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              dispatch.on('changeState', function(e) {
                  if (typeof e.disabled !== 'undefined') {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
  
                      state.disabled = e.disabled;
                  }
  
                  chart.update();
              });
          });
  
          renderWatch.renderEnd('historicalBarChart immediate');
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      bars.dispatch.on('elementMouseover.tooltip', function(evt) {
          evt['series'] = {
              key: chart.x()(evt.data),
              value: chart.y()(evt.data),
              color: evt.color
          };
          tooltip.data(evt).hidden(false);
      });
  
      bars.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      bars.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.bars = bars;
      chart.legend = legend;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.interactiveLayer = interactiveLayer;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              legend.color(color);
              bars.color(color);
          }},
          duration:    {get: function(){return transitionDuration;}, set: function(_){
              transitionDuration=_;
              renderWatch.reset(transitionDuration);
              yAxis.duration(transitionDuration);
              xAxis.duration(transitionDuration);
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( (_) ? 'right' : 'left');
          }},
          useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
              useInteractiveGuideline = _;
              if (_ === true) {
                  chart.interactive(false);
              }
          }}
      });
  
      nv.utils.inheritOptions(chart, bars);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  
  // ohlcChart is just a historical chart with ohlc bars and some tweaks
  nv.models.ohlcBarChart = function() {
      var chart = nv.models.historicalBarChart(nv.models.ohlcBar());
  
      // special default tooltip since we show multiple values per x
      chart.useInteractiveGuideline(true);
      chart.interactiveLayer.tooltip.contentGenerator(function(data) {
          // we assume only one series exists for this chart
          var d = data.series[0].data;
          // match line colors as defined in nv.d3.css
          var color = d.open < d.close ? "2ca02c" : "d62728";
          return '' +
              '<h3 style="color: #' + color + '">' + data.value + '</h3>' +
              '<table>' +
              '<tr><td>open:</td><td>' + chart.yAxis.tickFormat()(d.open) + '</td></tr>' +
              '<tr><td>close:</td><td>' + chart.yAxis.tickFormat()(d.close) + '</td></tr>' +
              '<tr><td>high</td><td>' + chart.yAxis.tickFormat()(d.high) + '</td></tr>' +
              '<tr><td>low:</td><td>' + chart.yAxis.tickFormat()(d.low) + '</td></tr>' +
              '</table>';
      });
      return chart;
  };
  
  // candlestickChart is just a historical chart with candlestick bars and some tweaks
  nv.models.candlestickBarChart = function() {
      var chart = nv.models.historicalBarChart(nv.models.candlestickBar());
  
      // special default tooltip since we show multiple values per x
      chart.useInteractiveGuideline(true);
      chart.interactiveLayer.tooltip.contentGenerator(function(data) {
          // we assume only one series exists for this chart
          var d = data.series[0].data;
          // match line colors as defined in nv.d3.css
          var color = d.open < d.close ? "2ca02c" : "d62728";
          return '' +
              '<h3 style="color: #' + color + '">' + data.value + '</h3>' +
              '<table>' +
              '<tr><td>open:</td><td>' + chart.yAxis.tickFormat()(d.open) + '</td></tr>' +
              '<tr><td>close:</td><td>' + chart.yAxis.tickFormat()(d.close) + '</td></tr>' +
              '<tr><td>high</td><td>' + chart.yAxis.tickFormat()(d.high) + '</td></tr>' +
              '<tr><td>low:</td><td>' + chart.yAxis.tickFormat()(d.low) + '</td></tr>' +
              '</table>';
      });
      return chart;
  };
  nv.models.legend = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 5, right: 0, bottom: 5, left: 0}
          , width = 400
          , height = 20
          , getKey = function(d) { return d.key }
          , keyFormatter = function (d) { return d }
          , color = nv.utils.getColor()
          , maxKeyLength = 20 //default value for key lengths
          , align = true
          , padding = 32 //define how much space between legend items. - recommend 32 for furious version
          , rightAlign = true
          , updateState = true   //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.
          , enableDoubleClick = true   //If true, legend will enable double click handling
          , radioButtonMode = false   //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)
          , expanded = false
          , dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange')
          , vers = 'classic' //Options are "classic" and "furious"
          ;
  
      function chart(selection) {
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right,
                  container = d3.select(this);
              nv.utils.initSVG(container);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-legend').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');
              var g = wrap.select('g');
  
              if (rightAlign)
                  wrap.attr('transform', 'translate(' + (- margin.right) + ',' + margin.top + ')');
              else
                  wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              var series = g.selectAll('.nv-series')
                  .data(function(d) {
                      if(vers != 'furious') return d;
  
                      return d.filter(function(n) {
                          return expanded ? true : !n.disengaged;
                      });
                  });
  
              var seriesEnter = series.enter().append('g').attr('class', 'nv-series');
              var seriesShape;
  
              var versPadding;
              switch(vers) {
                  case 'furious' :
                      versPadding = 23;
                      break;
                  case 'classic' :
                      versPadding = 20;
              }
  
              if(vers == 'classic') {
                  seriesEnter.append('circle')
                      .style('stroke-width', 2)
                      .attr('class','nv-legend-symbol')
                      .attr('r', 5);
  
                  seriesShape = series.select('.nv-legend-symbol');
              } else if (vers == 'furious') {
                  seriesEnter.append('rect')
                      .style('stroke-width', 2)
                      .attr('class','nv-legend-symbol')
                      .attr('rx', 3)
                      .attr('ry', 3);
                  seriesShape = series.select('.nv-legend-symbol');
  
                  seriesEnter.append('g')
                      .attr('class', 'nv-check-box')
                      .property('innerHTML','<path d="M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z" class="nv-box"></path><path d="M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511" class="nv-check"></path>')
                      .attr('transform', 'translate(-10,-8)scale(0.5)');
  
                  var seriesCheckbox = series.select('.nv-check-box');
  
                  seriesCheckbox.each(function(d,i) {
                      d3.select(this).selectAll('path')
                          .attr('stroke', setTextColor(d,i));
                  });
              }
  
              seriesEnter.append('text')
                  .attr('text-anchor', 'start')
                  .attr('class','nv-legend-text')
                  .attr('dy', '.32em')
                  .attr('dx', '8');
  
              var seriesText = series.select('text.nv-legend-text');
  
              series
                  .on('mouseover', function(d,i) {
                      dispatch.legendMouseover(d,i);  //TODO: Make consistent with other event objects
                  })
                  .on('mouseout', function(d,i) {
                      dispatch.legendMouseout(d,i);
                  })
                  .on('click', function(d,i) {
                      dispatch.legendClick(d,i);
                      // make sure we re-get data in case it was modified
                      var data = series.data();
                      if (updateState) {
                          if(vers =='classic') {
                              if (radioButtonMode) {
                                  //Radio button mode: set every series to disabled,
                                  //  and enable the clicked series.
                                  data.forEach(function(series) { series.disabled = true});
                                  d.disabled = false;
                              }
                              else {
                                  d.disabled = !d.disabled;
                                  if (data.every(function(series) { return series.disabled})) {
                                      //the default behavior of NVD3 legends is, if every single series
                                      // is disabled, turn all series' back on.
                                      data.forEach(function(series) { series.disabled = false});
                                  }
                              }
                          } else if(vers == 'furious') {
                              if(expanded) {
                                  d.disengaged = !d.disengaged;
                                  d.userDisabled = d.userDisabled == undefined ? !!d.disabled : d.userDisabled;
                                  d.disabled = d.disengaged || d.userDisabled;
                              } else if (!expanded) {
                                  d.disabled = !d.disabled;
                                  d.userDisabled = d.disabled;
                                  var engaged = data.filter(function(d) { return !d.disengaged; });
                                  if (engaged.every(function(series) { return series.userDisabled })) {
                                      //the default behavior of NVD3 legends is, if every single series
                                      // is disabled, turn all series' back on.
                                      data.forEach(function(series) {
                                          series.disabled = series.userDisabled = false;
                                      });
                                  }
                              }
                          }
                          dispatch.stateChange({
                              disabled: data.map(function(d) { return !!d.disabled }),
                              disengaged: data.map(function(d) { return !!d.disengaged })
                          });
  
                      }
                  })
                  .on('dblclick', function(d,i) {
                      if (enableDoubleClick) {
                          if (vers == 'furious' && expanded) return;
                          dispatch.legendDblclick(d, i);
                          if (updateState) {
                              // make sure we re-get data in case it was modified
                              var data = series.data();
                              //the default behavior of NVD3 legends, when double clicking one,
                              // is to set all other series' to false, and make the double clicked series enabled.
                              data.forEach(function (series) {
                                  series.disabled = true;
                                  if (vers == 'furious') series.userDisabled = series.disabled;
                              });
                              d.disabled = false;
                              if (vers == 'furious') d.userDisabled = d.disabled;
                              dispatch.stateChange({
                                  disabled: data.map(function (d) {
                                      return !!d.disabled
                                  })
                              });
                          }
                      }
                  });
  
              series.classed('nv-disabled', function(d) { return d.userDisabled });
              series.exit().remove();
  
              seriesText
                  .attr('fill', setTextColor)
                  .text(function (d) { return keyFormatter(getKey(d)) });
  
              //TODO: implement fixed-width and max-width options (max-width is especially useful with the align option)
              // NEW ALIGNING CODE, TODO: clean up
              var legendWidth = 0;
              if (align) {
  
                  var seriesWidths = [];
                  series.each(function(d,i) {
                      var legendText;
                      if (keyFormatter(getKey(d)) && keyFormatter(getKey(d)).length > maxKeyLength) {
                          var trimmedKey = keyFormatter(getKey(d)).substring(0, maxKeyLength);
                          legendText = d3.select(this).select('text').text(trimmedKey + "...");
                          d3.select(this).append("svg:title").text(keyFormatter(getKey(d)));
                      } else {
                          legendText = d3.select(this).select('text');
                      }
                      var nodeTextLength;
                      try {
                          nodeTextLength = legendText.node().getComputedTextLength();
                          // If the legendText is display:none'd (nodeTextLength == 0), simulate an error so we approximate, instead
                          if(nodeTextLength <= 0) throw Error();
                      }
                      catch(e) {
                          nodeTextLength = nv.utils.calcApproxTextWidth(legendText);
                      }
  
                      seriesWidths.push(nodeTextLength + padding);
                  });
  
                  var seriesPerRow = 0;
                  var columnWidths = [];
                  legendWidth = 0;
  
                  while ( legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {
                      columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];
                      legendWidth += seriesWidths[seriesPerRow++];
                  }
                  if (seriesPerRow === 0) seriesPerRow = 1; //minimum of one series per row
  
                  while ( legendWidth > availableWidth && seriesPerRow > 1 ) {
                      columnWidths = [];
                      seriesPerRow--;
  
                      for (var k = 0; k < seriesWidths.length; k++) {
                          if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0) )
                              columnWidths[k % seriesPerRow] = seriesWidths[k];
                      }
  
                      legendWidth = columnWidths.reduce(function(prev, cur, index, array) {
                          return prev + cur;
                      });
                  }
  
                  var xPositions = [];
                  for (var i = 0, curX = 0; i < seriesPerRow; i++) {
                      xPositions[i] = curX;
                      curX += columnWidths[i];
                  }
  
                  series
                      .attr('transform', function(d, i) {
                          return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * versPadding) + ')';
                      });
  
                  //position legend as far right as possible within the total width
                  if (rightAlign) {
                      g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');
                  }
                  else {
                      g.attr('transform', 'translate(0' + ',' + margin.top + ')');
                  }
  
                  height = margin.top + margin.bottom + (Math.ceil(seriesWidths.length / seriesPerRow) * versPadding);
  
              } else {
  
                  var ypos = 5,
                      newxpos = 5,
                      maxwidth = 0,
                      xpos;
                  series
                      .attr('transform', function(d, i) {
                          var length = d3.select(this).select('text').node().getComputedTextLength() + padding;
                          xpos = newxpos;
  
                          if (width < margin.left + margin.right + xpos + length) {
                              newxpos = xpos = 5;
                              ypos += versPadding;
                          }
  
                          newxpos += length;
                          if (newxpos > maxwidth) maxwidth = newxpos;
  
                          if(legendWidth < xpos + maxwidth) {
                              legendWidth = xpos + maxwidth;
                          }
                          return 'translate(' + xpos + ',' + ypos + ')';
                      });
  
                  //position legend as far right as possible within the total width
                  g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');
  
                  height = margin.top + margin.bottom + ypos + 15;
              }
  
              if(vers == 'furious') {
                  // Size rectangles after text is placed
                  seriesShape
                      .attr('width', function(d,i) {
                          return seriesText[0][i].getComputedTextLength() + 27;
                      })
                      .attr('height', 18)
                      .attr('y', -9)
                      .attr('x', -15);
  
                  // The background for the expanded legend (UI)
                  gEnter.insert('rect',':first-child')
                      .attr('class', 'nv-legend-bg')
                      .attr('fill', '#eee')
                      // .attr('stroke', '#444')
                      .attr('opacity',0);
  
                  var seriesBG = g.select('.nv-legend-bg');
  
                  seriesBG
                  .transition().duration(300)
                      .attr('x', -versPadding )
                      .attr('width', legendWidth + versPadding - 12)
                      .attr('height', height + 10)
                      .attr('y', -margin.top - 10)
                      .attr('opacity', expanded ? 1 : 0);
  
  
              }
  
              seriesShape
                  .style('fill', setBGColor)
                  .style('fill-opacity', setBGOpacity)
                  .style('stroke', setBGColor);
          });
  
          function setTextColor(d,i) {
              if(vers != 'furious') return '#000';
              if(expanded) {
                  return d.disengaged ? '#000' : '#fff';
              } else if (!expanded) {
                  if(!d.color) d.color = color(d,i);
                  return !!d.disabled ? d.color : '#fff';
              }
          }
  
          function setBGColor(d,i) {
              if(expanded && vers == 'furious') {
                  return d.disengaged ? '#eee' : d.color || color(d,i);
              } else {
                  return d.color || color(d,i);
              }
          }
  
  
          function setBGOpacity(d,i) {
              if(expanded && vers == 'furious') {
                  return 1;
              } else {
                  return !!d.disabled ? 0 : 1;
              }
          }
  
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:          {get: function(){return width;}, set: function(_){width=_;}},
          height:         {get: function(){return height;}, set: function(_){height=_;}},
          key:            {get: function(){return getKey;}, set: function(_){getKey=_;}},
          keyFormatter:   {get: function(){return keyFormatter;}, set: function(_){keyFormatter=_;}},
          align:          {get: function(){return align;}, set: function(_){align=_;}},
          maxKeyLength:   {get: function(){return maxKeyLength;}, set: function(_){maxKeyLength=_;}},
          rightAlign:     {get: function(){return rightAlign;}, set: function(_){rightAlign=_;}},
          padding:        {get: function(){return padding;}, set: function(_){padding=_;}},
          updateState:    {get: function(){return updateState;}, set: function(_){updateState=_;}},
          enableDoubleClick: {get: function(){return enableDoubleClick;}, set: function(_){enableDoubleClick=_;}},
          radioButtonMode:{get: function(){return radioButtonMode;}, set: function(_){radioButtonMode=_;}},
          expanded:       {get: function(){return expanded;}, set: function(_){expanded=_;}},
          vers:           {get: function(){return vers;}, set: function(_){vers=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.line = function() {
      "use strict";
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var  scatter = nv.models.scatter()
          ;
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 960
          , height = 500
          , container = null
          , strokeWidth = 1.5
          , color = nv.utils.defaultColor() // a function that returns a color
          , getX = function(d) { return d.x } // accessor to get the x value from a data point
          , getY = function(d) { return d.y } // accessor to get the y value from a data point
          , defined = function(d,i) { return !isNaN(getY(d,i)) && getY(d,i) !== null } // allows a line to be not continuous when it is not defined
          , isArea = function(d) { return d.area } // decides if a line is an area or just a line
          , clipEdge = false // if true, masks lines within x and y scale
          , x //can be accessed via chart.xScale()
          , y //can be accessed via chart.yScale()
          , interpolate = "linear" // controls the line interpolation
          , duration = 250
          , dispatch = d3.dispatch('elementClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
          ;
  
      scatter
          .pointSize(16) // default size
          .pointDomain([16,256]) //set to speed up calculation, needs to be unset if there is a custom size accessor
      ;
  
      //============================================================
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var x0, y0 //used to store previous scales
          , renderWatch = nv.utils.renderWatch(dispatch, duration)
          ;
  
      //============================================================
  
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(scatter);
          selection.each(function(data) {
              container = d3.select(this);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
              nv.utils.initSVG(container);
  
              // Setup Scales
              x = scatter.xScale();
              y = scatter.yScale();
  
              x0 = x0 || x;
              y0 = y0 || y;
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-line').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-line');
              var defsEnter = wrapEnter.append('defs');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-groups');
              gEnter.append('g').attr('class', 'nv-scatterWrap');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              scatter
                  .width(availableWidth)
                  .height(availableHeight);
  
              var scatterWrap = wrap.select('.nv-scatterWrap');
              scatterWrap.call(scatter);
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-edge-clip-' + scatter.id())
                  .append('rect');
  
              wrap.select('#nv-edge-clip-' + scatter.id() + ' rect')
                  .attr('width', availableWidth)
                  .attr('height', (availableHeight > 0) ? availableHeight : 0);
  
              g   .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');
              scatterWrap
                  .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');
  
              var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                  .data(function(d) { return d }, function(d) { return d.key });
              groups.enter().append('g')
                  .style('stroke-opacity', 1e-6)
                  .style('stroke-width', function(d) { return d.strokeWidth || strokeWidth })
                  .style('fill-opacity', 1e-6);
  
              groups.exit().remove();
  
              groups
                  .attr('class', function(d,i) {
                      return (d.classed || '') + ' nv-group nv-series-' + i;
                  })
                  .classed('hover', function(d) { return d.hover })
                  .style('fill', function(d,i){ return color(d, i) })
                  .style('stroke', function(d,i){ return color(d, i)});
              groups.watchTransition(renderWatch, 'line: groups')
                  .style('stroke-opacity', 1)
                  .style('fill-opacity', function(d) { return d.fillOpacity || .5});
  
              var areaPaths = groups.selectAll('path.nv-area')
                  .data(function(d) { return isArea(d) ? [d] : [] }); // this is done differently than lines because I need to check if series is an area
              areaPaths.enter().append('path')
                  .attr('class', 'nv-area')
                  .attr('d', function(d) {
                      return d3.svg.area()
                          .interpolate(interpolate)
                          .defined(defined)
                          .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
                          .y0(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
                          .y1(function(d,i) { return y0( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })
                          //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this
                          .apply(this, [d.values])
                  });
              groups.exit().selectAll('path.nv-area')
                  .remove();
  
              areaPaths.watchTransition(renderWatch, 'line: areaPaths')
                  .attr('d', function(d) {
                      return d3.svg.area()
                          .interpolate(interpolate)
                          .defined(defined)
                          .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
                          .y0(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
                          .y1(function(d,i) { return y( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })
                          //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this
                          .apply(this, [d.values])
                  });
  
              var linePaths = groups.selectAll('path.nv-line')
                  .data(function(d) { return [d.values] });
  
              linePaths.enter().append('path')
                  .attr('class', 'nv-line')
                  .attr('d',
                      d3.svg.line()
                      .interpolate(interpolate)
                      .defined(defined)
                      .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
                      .y(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
              );
  
              linePaths.watchTransition(renderWatch, 'line: linePaths')
                  .attr('d',
                      d3.svg.line()
                      .interpolate(interpolate)
                      .defined(defined)
                      .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
                      .y(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
              );
  
              //store old scales for use in transitions on update
              x0 = x.copy();
              y0 = y.copy();
          });
          renderWatch.renderEnd('line immediate');
          return chart;
      }
  
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.scatter = scatter;
      // Pass through events
      scatter.dispatch.on('elementClick', function(){ dispatch.elementClick.apply(this, arguments); });
      scatter.dispatch.on('elementMouseover', function(){ dispatch.elementMouseover.apply(this, arguments); });
      scatter.dispatch.on('elementMouseout', function(){ dispatch.elementMouseout.apply(this, arguments); });
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          defined: {get: function(){return defined;}, set: function(_){defined=_;}},
          interpolate:      {get: function(){return interpolate;}, set: function(_){interpolate=_;}},
          clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              scatter.duration(duration);
          }},
          isArea: {get: function(){return isArea;}, set: function(_){
              isArea = d3.functor(_);
          }},
          x: {get: function(){return getX;}, set: function(_){
              getX = _;
              scatter.x(_);
          }},
          y: {get: function(){return getY;}, set: function(_){
              getY = _;
              scatter.y(_);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              scatter.color(color);
          }}
      });
  
      nv.utils.inheritOptions(chart, scatter);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  nv.models.lineChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var lines = nv.models.line()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
          , legend = nv.models.legend()
          , interactiveLayer = nv.interactiveGuideline()
          , tooltip = nv.models.tooltip()
          , focus = nv.models.focus(nv.models.line())
          ;
  
      var margin = {top: 30, right: 20, bottom: 50, left: 60}
          , marginTop = null
          , color = nv.utils.defaultColor()
          , width = null
          , height = null
          , showLegend = true
          , legendPosition = 'top'
          , showXAxis = true
          , showYAxis = true
          , rightAlignYAxis = false
          , useInteractiveGuideline = false
          , x
          , y
          , focusEnable = false
          , state = nv.utils.state()
          , defaultState = null
          , noData = null
          , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd')
          , duration = 250
          ;
  
      // set options on sub-objects for this chart
      xAxis.orient('bottom').tickPadding(7);
      yAxis.orient(rightAlignYAxis ? 'right' : 'left');
  
      lines.clipEdge(true).duration(0);
  
      tooltip.valueFormatter(function(d, i) {
          return yAxis.tickFormat()(d, i);
      }).headerFormatter(function(d, i) {
          return xAxis.tickFormat()(d, i);
      });
  
      interactiveLayer.tooltip.valueFormatter(function(d, i) {
          return yAxis.tickFormat()(d, i);
      }).headerFormatter(function(d, i) {
          return xAxis.tickFormat()(d, i);
      });
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      var stateGetter = function(data) {
          return function(){
              return {
                  active: data.map(function(d) { return !d.disabled; })
              };
          };
      };
  
      var stateSetter = function(data) {
          return function(state) {
              if (state.active !== undefined)
                  data.forEach(function(series,i) {
                      series.disabled = !state.active[i];
                  });
          };
      };
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(lines);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this);
              nv.utils.initSVG(container);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);
              chart.update = function() {
                  if( duration === 0 ) {
                      container.call( chart );
                  } else {
                      container.transition().duration(duration).call(chart);
                  }
              };
              chart.container = this;
  
              state
                  .setter(stateSetter(data), chart.update)
                  .getter(stateGetter(data))
                  .update();
  
              // DEPRECATED set state.disabled
              state.disabled = data.map(function(d) { return !!d.disabled; });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              // Display noData message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length; }).length) {
                  nv.utils.noData(chart, container);
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              /* Update `main' graph on brush update. */
              focus.dispatch.on("onBrush", function(extent) {
                  onBrush(extent);
              });
  
              // Setup Scales
              x = lines.xScale();
              y = lines.yScale();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-lineChart').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineChart').append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-legendWrap');
  
              var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
              focusEnter.append('g').attr('class', 'nv-background').append('rect');
              focusEnter.append('g').attr('class', 'nv-x nv-axis');
              focusEnter.append('g').attr('class', 'nv-y nv-axis');
              focusEnter.append('g').attr('class', 'nv-linesWrap');
              focusEnter.append('g').attr('class', 'nv-interactive');
  
              var contextEnter = gEnter.append('g').attr('class', 'nv-focusWrap');
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  legend.width(availableWidth);
  
                  g.select('.nv-legendWrap')
                      .datum(data)
                      .call(legend);
  
                  if (legendPosition === 'bottom') {
                       margin.bottom = xAxis.height() + legend.height();
                       availableHeight = nv.utils.availableHeight(height, container, margin);
                       g.select('.nv-legendWrap')
                           .attr('transform', 'translate(0,' + (availableHeight + xAxis.height())  +')');
                  } else if (legendPosition === 'top') {
                      if (!marginTop && legend.height() !== margin.top) {
                          margin.top = legend.height();
                          availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);
                      }
  
                      wrap.select('.nv-legendWrap')
                          .attr('transform', 'translate(0,' + (-margin.top) +')');
                  }
              }
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              if (rightAlignYAxis) {
                  g.select(".nv-y.nv-axis")
                      .attr("transform", "translate(" + availableWidth + ",0)");
              }
  
              //Set up interactive layer
              if (useInteractiveGuideline) {
                  interactiveLayer
                      .width(availableWidth)
                      .height(availableHeight)
                      .margin({left:margin.left, top:margin.top})
                      .svgContainer(container)
                      .xScale(x);
                  wrap.select(".nv-interactive").call(interactiveLayer);
              }
  
              g.select('.nv-focus .nv-background rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              lines
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled; }));
  
              var linesWrap = g.select('.nv-linesWrap')
                  .datum(data.filter(function(d) { return !d.disabled; }));
  
  
              // Setup Main (Focus) Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      ._ticks(nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize(-availableHeight, 0);
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                      .tickSize( -availableWidth, 0);
              }
  
              //============================================================
              // Update Axes
              //============================================================
              function updateXAxis() {
                if(showXAxis) {
                  g.select('.nv-focus .nv-x.nv-axis')
                    .transition()
                    .duration(duration)
                    .call(xAxis)
                  ;
                }
              }
  
              function updateYAxis() {
                if(showYAxis) {
                  g.select('.nv-focus .nv-y.nv-axis')
                    .transition()
                    .duration(duration)
                    .call(yAxis)
                  ;
                }
              }
  
              g.select('.nv-focus .nv-x.nv-axis')
                  .attr('transform', 'translate(0,' + availableHeight + ')');
  
              //============================================================
              // Update Focus
              //============================================================
              if (!focusEnable && focus.brush.extent() === null) {
                  linesWrap.transition().call(lines);
                  updateXAxis();
                  updateYAxis();
              } else {
                  focus.width(availableWidth);
                  g.select('.nv-focusWrap')
                      .style('display', focusEnable ? 'initial' : 'none')
                      .attr('transform', 'translate(0,' + ( availableHeight + margin.bottom + focus.margin().top) + ')')
                      .call(focus);
                  var extent = focus.brush.empty() ? focus.xDomain() : focus.brush.extent();
                  if (extent !== null) {
                      onBrush(extent);
                  }
              }
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              legend.dispatch.on('stateChange', function(newState) {
                  for (var key in newState)
                      state[key] = newState[key];
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              interactiveLayer.dispatch.on('elementMousemove', function(e) {
                  lines.clearHighlights();
                  var singlePoint, pointIndex, pointXLocation, allData = [];
                  data
                      .filter(function(series, i) {
                          series.seriesIndex = i;
                          return !series.disabled && !series.disableTooltip;
                      })
                      .forEach(function(series,i) {
                          var extent = focus.brush.extent() !== null ? (focus.brush.empty() ? focus.xScale().domain() : focus.brush.extent()) : x.domain();
                          var currentValues = series.values.filter(function(d,i) {
                              // Checks if the x point is between the extents, handling case where extent[0] is greater than extent[1]
                              // (e.g. x domain is manually set to reverse the x-axis)
                              if(extent[0] <= extent[1]) {
                                  return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                              } else {
                                  return lines.x()(d,i) >= extent[1] && lines.x()(d,i) <= extent[0];
                              }
                          });
  
                          if (currentValues.length > 0) {
                              pointIndex = nv.interactiveBisect(currentValues, e.pointXValue, lines.x());
                              var point = currentValues[pointIndex];
                              var pointYValue = chart.y()(point, pointIndex);
                              if (pointYValue !== null) {
                                  lines.highlightPoint(i, series.values.indexOf(point), true);
                              }
                              if (point === undefined) return;
                              if (singlePoint === undefined) singlePoint = point;
                              if (pointXLocation === undefined) pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                              allData.push({
                                  key: series.key,
                                  value: pointYValue,
                                  color: color(series,series.seriesIndex),
                                  data: point
                              });
                          }
                      });
                  //Highlight the tooltip entry based on which point the mouse is closest to.
                  if (allData.length > 2) {
                      var yValue = chart.yScale().invert(e.mouseY);
                      var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                      var threshold = 0.03 * domainExtent;
                      var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value;}),yValue,threshold);
                      if (indexToHighlight !== null)
                          allData[indexToHighlight].highlight = true;
                  }
  
                  var defaultValueFormatter = function(d,i) {
                      return d == null ? "N/A" : yAxis.tickFormat()(d);
                  };
  
                  if (typeof pointIndex !== 'undefined') {
                      interactiveLayer.tooltip
                          .valueFormatter(interactiveLayer.tooltip.valueFormatter() || defaultValueFormatter)
                          .data({
                              value: chart.x()( singlePoint,pointIndex ),
                              index: pointIndex,
                              series: allData
                          })();
  
                      interactiveLayer.renderGuideLine(pointXLocation);
                  }
              });
  
              interactiveLayer.dispatch.on('elementClick', function(e) {
                  var pointXLocation, allData = [];
  
                  data.filter(function(series, i) {
                      series.seriesIndex = i;
                      return !series.disabled;
                  }).forEach(function(series) {
                      var pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                      var point = series.values[pointIndex];
                      if (typeof point === 'undefined') return;
                      if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                      var yPos = chart.yScale()(chart.y()(point,pointIndex));
                      allData.push({
                          point: point,
                          pointIndex: pointIndex,
                          pos: [pointXLocation, yPos],
                          seriesIndex: series.seriesIndex,
                          series: series
                      });
                  });
  
                  lines.dispatch.elementClick(allData);
              });
  
              interactiveLayer.dispatch.on("elementMouseout",function(e) {
                  lines.clearHighlights();
              });
  
              dispatch.on('changeState', function(e) {
                  if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
  
                      state.disabled = e.disabled;
                  }
                  chart.update();
              });
  
              //============================================================
              // Functions
              //------------------------------------------------------------
  
              // Taken from crossfilter (http://square.github.com/crossfilter/)
              function resizePath(d) {
                  var e = +(d == 'e'),
                      x = e ? 1 : -1,
                      y = availableHeight / 3;
                  return 'M' + (0.5 * x) + ',' + y
                      + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                      + 'V' + (2 * y - 6)
                      + 'A6,6 0 0 ' + e + ' ' + (0.5 * x) + ',' + (2 * y)
                      + 'Z'
                      + 'M' + (2.5 * x) + ',' + (y + 8)
                      + 'V' + (2 * y - 8)
                      + 'M' + (4.5 * x) + ',' + (y + 8)
                      + 'V' + (2 * y - 8);
              }
  
              function onBrush(extent) {
                  // Update Main (Focus)
                  var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
                      .datum(
                      data.filter(function(d) { return !d.disabled; })
                          .map(function(d,i) {
                              return {
                                  key: d.key,
                                  area: d.area,
                                  classed: d.classed,
                                  values: d.values.filter(function(d,i) {
                                      return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                                  }),
                                  disableTooltip: d.disableTooltip
                              };
                          })
                  );
                  focusLinesWrap.transition().duration(duration).call(lines);
  
                  // Update Main (Focus) Axes
                  updateXAxis();
                  updateYAxis();
              }
          });
  
          renderWatch.renderEnd('lineChart immediate');
          return chart;
      }
  
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      lines.dispatch.on('elementMouseover.tooltip', function(evt) {
          if(!evt.series.disableTooltip){
              tooltip.data(evt).hidden(false);
          }
      });
  
      lines.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.lines = lines;
      chart.legend = legend;
      chart.focus = focus;
      chart.xAxis = xAxis;
      chart.x2Axis = focus.xAxis
      chart.yAxis = yAxis;
      chart.y2Axis = focus.yAxis
      chart.interactiveLayer = interactiveLayer;
      chart.tooltip = tooltip;
      chart.state = state;
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          legendPosition: {get: function(){return legendPosition;}, set: function(_){legendPosition=_;}},
          showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
          // Focus options, mostly passed onto focus model.
          focusEnable:    {get: function(){return focusEnable;}, set: function(_){focusEnable=_;}},
          focusHeight:     {get: function(){return focus.height();}, set: function(_){focus.height(_);}},
          focusShowAxisX:    {get: function(){return focus.showXAxis();}, set: function(_){focus.showXAxis(_);}},
          focusShowAxisY:    {get: function(){return focus.showYAxis();}, set: function(_){focus.showYAxis(_);}},
          brushExtent: {get: function(){return focus.brushExtent();}, set: function(_){focus.brushExtent(_);}},
  
          // options that require extra logic in the setter
          focusMargin: {get: function(){return focus.margin}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              focus.margin.right  = _.right  !== undefined ? _.right  : focus.margin.right;
              focus.margin.bottom = _.bottom !== undefined ? _.bottom : focus.margin.bottom;
              focus.margin.left   = _.left   !== undefined ? _.left   : focus.margin.left;
          }},
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              lines.duration(duration);
              focus.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              legend.color(color);
              lines.color(color);
              focus.color(color);
          }},
          interpolate: {get: function(){return lines.interpolate();}, set: function(_){
              lines.interpolate(_);
              focus.interpolate(_);
          }},
          xTickFormat: {get: function(){return xAxis.tickFormat();}, set: function(_){
              xAxis.tickFormat(_);
              focus.xTickFormat(_);
          }},
          yTickFormat: {get: function(){return yAxis.tickFormat();}, set: function(_){
              yAxis.tickFormat(_);
              focus.yTickFormat(_);
          }},
          x: {get: function(){return lines.x();}, set: function(_){
              lines.x(_);
              focus.x(_);
          }},
          y: {get: function(){return lines.y();}, set: function(_){
              lines.y(_);
              focus.y(_);
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( rightAlignYAxis ? 'right' : 'left');
          }},
          useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
              useInteractiveGuideline = _;
              if (useInteractiveGuideline) {
                  lines.interactive(false);
                  lines.useVoronoi(false);
              }
          }}
      });
  
      nv.utils.inheritOptions(chart, lines);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.lineWithFocusChart = function() {
    return nv.models.lineChart()
      .margin({ bottom: 30 })
      .focusEnable( true );
  };
  nv.models.linePlusBarChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var lines = nv.models.line()
          , lines2 = nv.models.line()
          , bars = nv.models.historicalBar()
          , bars2 = nv.models.historicalBar()
          , xAxis = nv.models.axis()
          , x2Axis = nv.models.axis()
          , y1Axis = nv.models.axis()
          , y2Axis = nv.models.axis()
          , y3Axis = nv.models.axis()
          , y4Axis = nv.models.axis()
          , legend = nv.models.legend()
          , brush = d3.svg.brush()
          , tooltip = nv.models.tooltip()
          ;
  
      var margin = {top: 30, right: 30, bottom: 30, left: 60}
          , marginTop = null
          , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
          , width = null
          , height = null
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , color = nv.utils.defaultColor()
          , showLegend = true
          , focusEnable = true
          , focusShowAxisY = false
          , focusShowAxisX = true
          , focusHeight = 50
          , extent
          , brushExtent = null
          , x
          , x2
          , y1
          , y2
          , y3
          , y4
          , noData = null
          , dispatch = d3.dispatch('brush', 'stateChange', 'changeState')
          , transitionDuration = 0
          , state = nv.utils.state()
          , defaultState = null
          , legendLeftAxisHint = ' (left axis)'
          , legendRightAxisHint = ' (right axis)'
          , switchYAxisOrder = false
          ;
  
      lines.clipEdge(true);
      lines2.interactive(false);
      // We don't want any points emitted for the focus chart's scatter graph.
      lines2.pointActive(function(d) { return false });
      xAxis.orient('bottom').tickPadding(5);
      y1Axis.orient('left');
      y2Axis.orient('right');
      x2Axis.orient('bottom').tickPadding(5);
      y3Axis.orient('left');
      y4Axis.orient('right');
  
      tooltip.headerEnabled(true).headerFormatter(function(d, i) {
          return xAxis.tickFormat()(d, i);
      });
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var getBarsAxis = function() {
          return switchYAxisOrder
              ? { main: y2Axis, focus: y4Axis }
              : { main: y1Axis, focus: y3Axis }
      }
  
      var getLinesAxis = function() {
          return switchYAxisOrder
              ? { main: y1Axis, focus: y3Axis }
              : { main: y2Axis, focus: y4Axis }
      }
  
      var stateGetter = function(data) {
          return function(){
              return {
                  active: data.map(function(d) { return !d.disabled })
              };
          }
      };
  
      var stateSetter = function(data) {
          return function(state) {
              if (state.active !== undefined)
                  data.forEach(function(series,i) {
                      series.disabled = !state.active[i];
                  });
          }
      };
  
      var allDisabled = function(data) {
        return data.every(function(series) {
          return series.disabled;
        });
      }
  
      function chart(selection) {
          selection.each(function(data) {
              var container = d3.select(this),
                  that = this;
              nv.utils.initSVG(container);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight1 = nv.utils.availableHeight(height, container, margin)
                      - (focusEnable ? focusHeight : 0),
                  availableHeight2 = focusHeight - margin2.top - margin2.bottom;
  
              chart.update = function() { container.transition().duration(transitionDuration).call(chart); };
              chart.container = this;
  
              state
                  .setter(stateSetter(data), chart.update)
                  .getter(stateGetter(data))
                  .update();
  
              // DEPRECATED set state.disableddisabled
              state.disabled = data.map(function(d) { return !!d.disabled });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container)
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              var dataBars = data.filter(function(d) { return !d.disabled && d.bar });
              var dataLines = data.filter(function(d) { return !d.bar }); // removed the !d.disabled clause here to fix Issue #240
  
              if (dataBars.length && !switchYAxisOrder) {
                  x = bars.xScale();
              } else {
                  x = lines.xScale();
              }
  
              x2 = x2Axis.scale();
  
              // select the scales and series based on the position of the yAxis
              y1 = switchYAxisOrder ? lines.yScale() : bars.yScale();
              y2 = switchYAxisOrder ? bars.yScale() : lines.yScale();
              y3 = switchYAxisOrder ? lines2.yScale() : bars2.yScale();
              y4 = switchYAxisOrder ? bars2.yScale() : lines2.yScale();
  
              var series1 = data
                  .filter(function(d) { return !d.disabled && (switchYAxisOrder ? !d.bar : d.bar) })
                  .map(function(d) {
                      return d.values.map(function(d,i) {
                          return { x: getX(d,i), y: getY(d,i) }
                      })
                  });
  
              var series2 = data
                  .filter(function(d) { return !d.disabled && (switchYAxisOrder ? d.bar : !d.bar) })
                  .map(function(d) {
                      return d.values.map(function(d,i) {
                          return { x: getX(d,i), y: getY(d,i) }
                      })
                  });
  
              x.range([0, availableWidth]);
  
              x2  .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x } ))
                  .range([0, availableWidth]);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-linePlusBar').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-legendWrap');
  
              // this is the main chart
              var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
              focusEnter.append('g').attr('class', 'nv-x nv-axis');
              focusEnter.append('g').attr('class', 'nv-y1 nv-axis');
              focusEnter.append('g').attr('class', 'nv-y2 nv-axis');
              focusEnter.append('g').attr('class', 'nv-barsWrap');
              focusEnter.append('g').attr('class', 'nv-linesWrap');
  
              // context chart is where you can focus in
              var contextEnter = gEnter.append('g').attr('class', 'nv-context');
              contextEnter.append('g').attr('class', 'nv-x nv-axis');
              contextEnter.append('g').attr('class', 'nv-y1 nv-axis');
              contextEnter.append('g').attr('class', 'nv-y2 nv-axis');
              contextEnter.append('g').attr('class', 'nv-barsWrap');
              contextEnter.append('g').attr('class', 'nv-linesWrap');
              contextEnter.append('g').attr('class', 'nv-brushBackground');
              contextEnter.append('g').attr('class', 'nv-x nv-brush');
  
              //============================================================
              // Legend
              //------------------------------------------------------------
  
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  var legendWidth = legend.align() ? availableWidth / 2 : availableWidth;
                  var legendXPosition = legend.align() ? legendWidth : 0;
  
                  legend.width(legendWidth);
  
                  g.select('.nv-legendWrap')
                      .datum(data.map(function(series) {
                          series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                          if(switchYAxisOrder) {
                              series.key = series.originalKey + (series.bar ? legendRightAxisHint : legendLeftAxisHint);
                          } else {
                              series.key = series.originalKey + (series.bar ? legendLeftAxisHint : legendRightAxisHint);
                          }
                          return series;
                      }))
                      .call(legend);
  
                  if (!marginTop && legend.height() !== margin.top) {
                      margin.top = legend.height();
                      // FIXME: shouldn't this be "- (focusEnabled ? focusHeight : 0)"?
                      availableHeight1 = nv.utils.availableHeight(height, container, margin) - focusHeight;
                  }
  
                  g.select('.nv-legendWrap')
                      .attr('transform', 'translate(' + legendXPosition + ',' + (-margin.top) +')');
              }
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              //============================================================
              // Context chart (focus chart) components
              //------------------------------------------------------------
  
              // hide or show the focus context chart
              g.select('.nv-context').style('display', focusEnable ? 'initial' : 'none');
  
              bars2
                  .width(availableWidth)
                  .height(availableHeight2)
                  .color(data.map(function (d, i) {
                      return d.color || color(d, i);
                  }).filter(function (d, i) {
                      return !data[i].disabled && data[i].bar
                  }));
              lines2
                  .width(availableWidth)
                  .height(availableHeight2)
                  .color(data.map(function (d, i) {
                      return d.color || color(d, i);
                  }).filter(function (d, i) {
                      return !data[i].disabled && !data[i].bar
                  }));
  
              var bars2Wrap = g.select('.nv-context .nv-barsWrap')
                  .datum(dataBars.length ? dataBars : [
                      {values: []}
                  ]);
              var lines2Wrap = g.select('.nv-context .nv-linesWrap')
                  .datum(allDisabled(dataLines) ?
                         [{values: []}] :
                         dataLines.filter(function(dataLine) {
                           return !dataLine.disabled;
                         }));
  
              g.select('.nv-context')
                  .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')');
  
              bars2Wrap.transition().call(bars2);
              lines2Wrap.transition().call(lines2);
  
              // context (focus chart) axis controls
              if (focusShowAxisX) {
                  x2Axis
                      ._ticks( nv.utils.calcTicksX(availableWidth / 100, data))
                      .tickSize(-availableHeight2, 0);
                  g.select('.nv-context .nv-x.nv-axis')
                      .attr('transform', 'translate(0,' + y3.range()[0] + ')');
                  g.select('.nv-context .nv-x.nv-axis').transition()
                      .call(x2Axis);
              }
  
              if (focusShowAxisY) {
                  y3Axis
                      .scale(y3)
                      ._ticks( availableHeight2 / 36 )
                      .tickSize( -availableWidth, 0);
                  y4Axis
                      .scale(y4)
                      ._ticks( availableHeight2 / 36 )
                      .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none
  
                  g.select('.nv-context .nv-y3.nv-axis')
                      .style('opacity', dataBars.length ? 1 : 0)
                      .attr('transform', 'translate(0,' + x2.range()[0] + ')');
                  g.select('.nv-context .nv-y2.nv-axis')
                      .style('opacity', dataLines.length ? 1 : 0)
                      .attr('transform', 'translate(' + x2.range()[1] + ',0)');
  
                  g.select('.nv-context .nv-y1.nv-axis').transition()
                      .call(y3Axis);
                  g.select('.nv-context .nv-y2.nv-axis').transition()
                      .call(y4Axis);
              }
  
              // Setup Brush
              brush.x(x2).on('brush', onBrush);
  
              if (brushExtent) brush.extent(brushExtent);
  
              var brushBG = g.select('.nv-brushBackground').selectAll('g')
                  .data([brushExtent || brush.extent()]);
  
              var brushBGenter = brushBG.enter()
                  .append('g');
  
              brushBGenter.append('rect')
                  .attr('class', 'left')
                  .attr('x', 0)
                  .attr('y', 0)
                  .attr('height', availableHeight2);
  
              brushBGenter.append('rect')
                  .attr('class', 'right')
                  .attr('x', 0)
                  .attr('y', 0)
                  .attr('height', availableHeight2);
  
              var gBrush = g.select('.nv-x.nv-brush')
                  .call(brush);
              gBrush.selectAll('rect')
                  //.attr('y', -5)
                  .attr('height', availableHeight2);
              gBrush.selectAll('.resize').append('path').attr('d', resizePath);
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              legend.dispatch.on('stateChange', function(newState) {
                  for (var key in newState)
                      state[key] = newState[key];
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              // Update chart from a state object passed to event handler
              dispatch.on('changeState', function(e) {
                  if (typeof e.disabled !== 'undefined') {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
                      state.disabled = e.disabled;
                  }
                  chart.update();
              });
  
              //============================================================
              // Functions
              //------------------------------------------------------------
  
              // Taken from crossfilter (http://square.github.com/crossfilter/)
              function resizePath(d) {
                  var e = +(d == 'e'),
                      x = e ? 1 : -1,
                      y = availableHeight2 / 3;
                  return 'M' + (.5 * x) + ',' + y
                      + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                      + 'V' + (2 * y - 6)
                      + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
                      + 'Z'
                      + 'M' + (2.5 * x) + ',' + (y + 8)
                      + 'V' + (2 * y - 8)
                      + 'M' + (4.5 * x) + ',' + (y + 8)
                      + 'V' + (2 * y - 8);
              }
  
  
              function updateBrushBG() {
                  if (!brush.empty()) brush.extent(brushExtent);
                  brushBG
                      .data([brush.empty() ? x2.domain() : brushExtent])
                      .each(function(d,i) {
                          var leftWidth = x2(d[0]) - x2.range()[0],
                              rightWidth = x2.range()[1] - x2(d[1]);
                          d3.select(this).select('.left')
                              .attr('width',  leftWidth < 0 ? 0 : leftWidth);
  
                          d3.select(this).select('.right')
                              .attr('x', x2(d[1]))
                              .attr('width', rightWidth < 0 ? 0 : rightWidth);
                      });
              }
  
              function onBrush() {
                  brushExtent = brush.empty() ? null : brush.extent();
                  extent = brush.empty() ? x2.domain() : brush.extent();
                  dispatch.brush({extent: extent, brush: brush});
                  updateBrushBG();
  
                  // Prepare Main (Focus) Bars and Lines
                  bars
                      .width(availableWidth)
                      .height(availableHeight1)
                      .color(data.map(function(d,i) {
                          return d.color || color(d, i);
                      }).filter(function(d,i) { return !data[i].disabled && data[i].bar }));
  
                  lines
                      .width(availableWidth)
                      .height(availableHeight1)
                      .color(data.map(function(d,i) {
                          return d.color || color(d, i);
                      }).filter(function(d,i) { return !data[i].disabled && !data[i].bar }));
  
                  var focusBarsWrap = g.select('.nv-focus .nv-barsWrap')
                      .datum(!dataBars.length ? [{values:[]}] :
                          dataBars
                              .map(function(d,i) {
                                  return {
                                      key: d.key,
                                      values: d.values.filter(function(d,i) {
                                          return bars.x()(d,i) >= extent[0] && bars.x()(d,i) <= extent[1];
                                      })
                                  }
                              })
                  );
  
                  var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
                      .datum(allDisabled(dataLines) ? [{values:[]}] :
                             dataLines
                             .filter(function(dataLine) { return !dataLine.disabled; })
                             .map(function(d,i) {
                                  return {
                                      area: d.area,
                                      fillOpacity: d.fillOpacity,
                                      strokeWidth: d.strokeWidth,
                                      key: d.key,
                                      values: d.values.filter(function(d,i) {
                                          return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                                      })
                                  }
                              })
                  );
  
                  // Update Main (Focus) X Axis
                  if (dataBars.length && !switchYAxisOrder) {
                      x = bars.xScale();
                  } else {
                      x = lines.xScale();
                  }
  
                  xAxis
                      .scale(x)
                      ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize(-availableHeight1, 0);
  
                  xAxis.domain([Math.ceil(extent[0]), Math.floor(extent[1])]);
  
                  g.select('.nv-x.nv-axis').transition().duration(transitionDuration)
                      .call(xAxis);
  
                  // Update Main (Focus) Bars and Lines
                  focusBarsWrap.transition().duration(transitionDuration).call(bars);
                  focusLinesWrap.transition().duration(transitionDuration).call(lines);
  
                  // Setup and Update Main (Focus) Y Axes
                  g.select('.nv-focus .nv-x.nv-axis')
                      .attr('transform', 'translate(0,' + y1.range()[0] + ')');
  
                  y1Axis
                      .scale(y1)
                      ._ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                      .tickSize(-availableWidth, 0);
                  y2Axis
                      .scale(y2)
                      ._ticks( nv.utils.calcTicksY(availableHeight1/36, data) );
  
                  // Show the y2 rules only if y1 has none
                  if(!switchYAxisOrder) {
                      y2Axis.tickSize(dataBars.length ? 0 : -availableWidth, 0);
                  } else {
                      y2Axis.tickSize(dataLines.length ? 0 : -availableWidth, 0);
                  }
  
                  // Calculate opacity of the axis
                  var barsOpacity = dataBars.length ? 1 : 0;
                  var linesOpacity = dataLines.length && !allDisabled(dataLines) ? 1 : 0;
  
                  var y1Opacity = switchYAxisOrder ? linesOpacity : barsOpacity;
                  var y2Opacity = switchYAxisOrder ? barsOpacity : linesOpacity;
  
                  g.select('.nv-focus .nv-y1.nv-axis')
                      .style('opacity', y1Opacity);
                  g.select('.nv-focus .nv-y2.nv-axis')
                      .style('opacity', y2Opacity)
                      .attr('transform', 'translate(' + x.range()[1] + ',0)');
  
                  g.select('.nv-focus .nv-y1.nv-axis').transition().duration(transitionDuration)
                      .call(y1Axis);
                  g.select('.nv-focus .nv-y2.nv-axis').transition().duration(transitionDuration)
                      .call(y2Axis);
              }
  
              onBrush();
  
          });
  
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      lines.dispatch.on('elementMouseover.tooltip', function(evt) {
          tooltip
              .duration(100)
              .valueFormatter(function(d, i) {
                  return getLinesAxis().main.tickFormat()(d, i);
              })
              .data(evt)
              .hidden(false);
      });
  
      lines.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true)
      });
  
      bars.dispatch.on('elementMouseover.tooltip', function(evt) {
          evt.value = chart.x()(evt.data);
          evt['series'] = {
              value: chart.y()(evt.data),
              color: evt.color
          };
          tooltip
              .duration(0)
              .valueFormatter(function(d, i) {
                  return getBarsAxis().main.tickFormat()(d, i);
              })
              .data(evt)
              .hidden(false);
      });
  
      bars.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      bars.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
  
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.legend = legend;
      chart.lines = lines;
      chart.lines2 = lines2;
      chart.bars = bars;
      chart.bars2 = bars2;
      chart.xAxis = xAxis;
      chart.x2Axis = x2Axis;
      chart.y1Axis = y1Axis;
      chart.y2Axis = y2Axis;
      chart.y3Axis = y3Axis;
      chart.y4Axis = y4Axis;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          brushExtent:    {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
          focusEnable:    {get: function(){return focusEnable;}, set: function(_){focusEnable=_;}},
          focusHeight:    {get: function(){return focusHeight;}, set: function(_){focusHeight=_;}},
          focusShowAxisX:    {get: function(){return focusShowAxisX;}, set: function(_){focusShowAxisX=_;}},
          focusShowAxisY:    {get: function(){return focusShowAxisY;}, set: function(_){focusShowAxisY=_;}},
          legendLeftAxisHint:    {get: function(){return legendLeftAxisHint;}, set: function(_){legendLeftAxisHint=_;}},
          legendRightAxisHint:    {get: function(){return legendRightAxisHint;}, set: function(_){legendRightAxisHint=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          focusMargin: {get: function(){return margin2;}, set: function(_){
              margin2.top    = _.top    !== undefined ? _.top    : margin2.top;
              margin2.right  = _.right  !== undefined ? _.right  : margin2.right;
              margin2.bottom = _.bottom !== undefined ? _.bottom : margin2.bottom;
              margin2.left   = _.left   !== undefined ? _.left   : margin2.left;
          }},
          duration: {get: function(){return transitionDuration;}, set: function(_){
              transitionDuration = _;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              legend.color(color);
          }},
          x: {get: function(){return getX;}, set: function(_){
              getX = _;
              lines.x(_);
              lines2.x(_);
              bars.x(_);
              bars2.x(_);
          }},
          y: {get: function(){return getY;}, set: function(_){
              getY = _;
              lines.y(_);
              lines2.y(_);
              bars.y(_);
              bars2.y(_);
          }},
          switchYAxisOrder:    {get: function(){return switchYAxisOrder;}, set: function(_){
              // Switch the tick format for the yAxis
              if(switchYAxisOrder !== _) {
                  var y1 = y1Axis;
                  y1Axis = y2Axis;
                  y2Axis = y1;
  
                  var y3 = y3Axis;
                  y3Axis = y4Axis;
                  y4Axis = y3;
              }
              switchYAxisOrder=_;
  
              y1Axis.orient('left');
              y2Axis.orient('right');
              y3Axis.orient('left');
              y4Axis.orient('right');
          }}
      });
  
      nv.utils.inheritOptions(chart, lines);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.multiBar = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 960
          , height = 500
          , x = d3.scale.ordinal()
          , y = d3.scale.linear()
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container = null
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
          , clipEdge = true
          , stacked = false
          , stackOffset = 'zero' // options include 'silhouette', 'wiggle', 'expand', 'zero', or a custom function
          , color = nv.utils.defaultColor()
          , hideable = false
          , barColor = null // adding the ability to set the color for each rather than the whole group
          , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled
          , duration = 500
          , xDomain
          , yDomain
          , xRange
          , yRange
          , groupSpacing = 0.1
          , fillOpacity = 0.75
          , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var x0, y0 //used to store previous scales
          , renderWatch = nv.utils.renderWatch(dispatch, duration)
          ;
  
      var last_datalength = 0;
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right,
                  availableHeight = height - margin.top - margin.bottom;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
              var nonStackableCount = 0;
              // This function defines the requirements for render complete
              var endFn = function(d, i) {
                  if (d.series === data.length - 1 && i === data[0].values.length - 1)
                      return true;
                  return false;
              };
  
              if(hideable && data.length) hideable = [{
                  values: data[0].values.map(function(d) {
                          return {
                              x: d.x,
                              y: 0,
                              series: d.series,
                              size: 0.01
                          };}
                  )}];
  
              if (stacked) {
                  var parsed = d3.layout.stack()
                      .offset(stackOffset)
                      .values(function(d){ return d.values })
                      .y(getY)
                  (!data.length && hideable ? hideable : data);
  
                  parsed.forEach(function(series, i){
                      // if series is non-stackable, use un-parsed data
                      if (series.nonStackable) {
                          data[i].nonStackableSeries = nonStackableCount++;
                          parsed[i] = data[i];
                      } else {
                          // don't stack this seires on top of the nonStackable seriees
                          if (i > 0 && parsed[i - 1].nonStackable){
                              parsed[i].values.map(function(d,j){
                                  d.y0 -= parsed[i - 1].values[j].y;
                                  d.y1 = d.y0 + d.y;
                              });
                          }
                      }
                  });
                  data = parsed;
              }
              //add series index and key to each data point for reference
              data.forEach(function(series, i) {
                  series.values.forEach(function(point) {
                      point.series = i;
                      point.key = series.key;
                  });
              });
  
              // HACK for negative value stacking
              if (stacked && data.length > 0) {
                  data[0].values.map(function(d,i) {
                      var posBase = 0, negBase = 0;
                      data.map(function(d, idx) {
                          if (!data[idx].nonStackable) {
                              var f = d.values[i]
                              f.size = Math.abs(f.y);
                              if (f.y<0)  {
                                  f.y1 = negBase;
                                  negBase = negBase - f.size;
                              } else
                              {
                                  f.y1 = f.size + posBase;
                                  posBase = posBase + f.size;
                              }
                          }
  
                      });
                  });
              }
              // Setup Scales
              // remap and flatten the data for use in calculating the scales' domains
              var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                  data.map(function(d, idx) {
                      return d.values.map(function(d,i) {
                          return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1, idx:idx }
                      })
                  });
  
              x.domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                  .rangeBands(xRange || [0, availableWidth], groupSpacing);
  
              y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) {
                  var domain = d.y;
                  // increase the domain range if this series is stackable
                  if (stacked && !data[d.idx].nonStackable) {
                      if (d.y > 0){
                          domain = d.y1
                      } else {
                          domain = d.y1 + d.y
                      }
                  }
                  return domain;
              }).concat(forceY)))
              .range(yRange || [availableHeight, 0]);
  
              // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
              if (x.domain()[0] === x.domain()[1])
                  x.domain()[0] ?
                      x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                      : x.domain([-1,1]);
  
              if (y.domain()[0] === y.domain()[1])
                  y.domain()[0] ?
                      y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                      : y.domain([-1,1]);
  
              x0 = x0 || x;
              y0 = y0 || y;
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-multibar').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibar');
              var defsEnter = wrapEnter.append('defs');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-groups');
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-edge-clip-' + id)
                  .append('rect');
              wrap.select('#nv-edge-clip-' + id + ' rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');
  
              var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                  .data(function(d) { return d }, function(d,i) { return i });
              groups.enter().append('g')
                  .style('stroke-opacity', 1e-6)
                  .style('fill-opacity', 1e-6);
  
              var exitTransition = renderWatch
                  .transition(groups.exit().selectAll('rect.nv-bar'), 'multibarExit', Math.min(100, duration))
                  .attr('y', function(d, i, j) {
                      var yVal = y0(0) || 0;
                      if (stacked) {
                          if (data[d.series] && !data[d.series].nonStackable) {
                              yVal = y0(d.y0);
                          }
                      }
                      return yVal;
                  })
                  .attr('height', 0)
                  .remove();
              if (exitTransition.delay)
                  exitTransition.delay(function(d,i) {
                      var delay = i * (duration / (last_datalength + 1)) - i;
                      return delay;
                  });
              groups
                  .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                  .classed('hover', function(d) { return d.hover })
                  .style('fill', function(d,i){ return color(d, i) })
                  .style('stroke', function(d,i){ return color(d, i) });
              groups
                  .style('stroke-opacity', 1)
                  .style('fill-opacity', fillOpacity);
  
              var bars = groups.selectAll('rect.nv-bar')
                  .data(function(d) { return (hideable && !data.length) ? hideable.values : d.values });
              bars.exit().remove();
  
              var barsEnter = bars.enter().append('rect')
                      .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
                      .attr('x', function(d,i,j) {
                          return stacked && !data[j].nonStackable ? 0 : (j * x.rangeBand() / data.length )
                      })
                      .attr('y', function(d,i,j) { return y0(stacked && !data[j].nonStackable ? d.y0 : 0) || 0 })
                      .attr('height', 0)
                      .attr('width', function(d,i,j) { return x.rangeBand() / (stacked && !data[j].nonStackable ? 1 : data.length) })
                      .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })
                  ;
              bars
                  .style('fill', function(d,i,j){ return color(d, j, i);  })
                  .style('stroke', function(d,i,j){ return color(d, j, i); })
                  .on('mouseover', function(d,i,j) {
                      d3.select(this).classed('hover', true);
                      dispatch.elementMouseover({
                          data: d,
                          index: i,
                          series: data[j],
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('mouseout', function(d,i,j) {
                      d3.select(this).classed('hover', false);
                      dispatch.elementMouseout({
                          data: d,
                          index: i,
                          series: data[j],
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('mousemove', function(d,i,j) {
                      dispatch.elementMousemove({
                          data: d,
                          index: i,
                          series: data[j],
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('click', function(d,i,j) {
                      var element = this;
                      dispatch.elementClick({
                          data: d,
                          index: i,
                          series: data[j],
                          color: d3.select(this).style("fill"),
                          event: d3.event,
                          element: element
                      });
                      d3.event.stopPropagation();
                  })
                  .on('dblclick', function(d,i,j) {
                      dispatch.elementDblClick({
                          data: d,
                          index: i,
                          series: data[j],
                          color: d3.select(this).style("fill")
                      });
                      d3.event.stopPropagation();
                  });
              bars
                  .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
                  .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })
  
              if (barColor) {
                  if (!disabled) disabled = data.map(function() { return true });
                  bars
                      .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })
                      .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });
              }
  
              var barSelection =
                  bars.watchTransition(renderWatch, 'multibar', Math.min(250, duration))
                      .delay(function(d,i) {
                          return i * duration / data[0].values.length;
                      });
              if (stacked){
                  barSelection
                      .attr('y', function(d,i,j) {
                          var yVal = 0;
                          // if stackable, stack it on top of the previous series
                          if (!data[j].nonStackable) {
                              yVal = y(d.y1);
                          } else {
                              if (getY(d,i) < 0){
                                  yVal = y(0);
                              } else {
                                  if (y(0) - y(getY(d,i)) < -1){
                                      yVal = y(0) - 1;
                                  } else {
                                      yVal = y(getY(d, i)) || 0;
                                  }
                              }
                          }
                          return yVal;
                      })
                      .attr('height', function(d,i,j) {
                          if (!data[j].nonStackable) {
                              return Math.max(Math.abs(y(d.y+d.y0) - y(d.y0)), 0);
                          } else {
                              return Math.max(Math.abs(y(getY(d,i)) - y(0)), 0) || 0;
                          }
                      })
                      .attr('x', function(d,i,j) {
                          var width = 0;
                          if (data[j].nonStackable) {
                              width = d.series * x.rangeBand() / data.length;
                              if (data.length !== nonStackableCount){
                                  width = data[j].nonStackableSeries * x.rangeBand()/(nonStackableCount*2);
                              }
                          }
                          return width;
                      })
                      .attr('width', function(d,i,j){
                          if (!data[j].nonStackable) {
                              return x.rangeBand();
                          } else {
                              // if all series are nonStacable, take the full width
                              var width = (x.rangeBand() / nonStackableCount);
                              // otherwise, nonStackable graph will be only taking the half-width
                              // of the x rangeBand
                              if (data.length !== nonStackableCount) {
                                  width = x.rangeBand()/(nonStackableCount*2);
                              }
                              return width;
                          }
                      });
              }
              else {
                  barSelection
                      .attr('x', function(d,i) {
                          return d.series * x.rangeBand() / data.length;
                      })
                      .attr('width', x.rangeBand() / data.length)
                      .attr('y', function(d,i) {
                          return getY(d,i) < 0 ?
                              y(0) :
                                  y(0) - y(getY(d,i)) < 1 ?
                              y(0) - 1 :
                              y(getY(d,i)) || 0;
                      })
                      .attr('height', function(d,i) {
                          return Math.max(Math.abs(y(getY(d,i)) - y(0)),1) || 0;
                      });
              }
  
              //store old scales for use in transitions on update
              x0 = x.copy();
              y0 = y.copy();
  
              // keep track of the last data value length for transition calculations
              if (data[0] && data[0].values) {
                  last_datalength = data[0].values.length;
              }
  
          });
  
          renderWatch.renderEnd('multibar immediate');
  
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:   {get: function(){return width;}, set: function(_){width=_;}},
          height:  {get: function(){return height;}, set: function(_){height=_;}},
          x:       {get: function(){return getX;}, set: function(_){getX=_;}},
          y:       {get: function(){return getY;}, set: function(_){getY=_;}},
          xScale:  {get: function(){return x;}, set: function(_){x=_;}},
          yScale:  {get: function(){return y;}, set: function(_){y=_;}},
          xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
          forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
          stacked: {get: function(){return stacked;}, set: function(_){stacked=_;}},
          stackOffset: {get: function(){return stackOffset;}, set: function(_){stackOffset=_;}},
          clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
          disabled:    {get: function(){return disabled;}, set: function(_){disabled=_;}},
          id:          {get: function(){return id;}, set: function(_){id=_;}},
          hideable:    {get: function(){return hideable;}, set: function(_){hideable=_;}},
          groupSpacing:{get: function(){return groupSpacing;}, set: function(_){groupSpacing=_;}},
          fillOpacity: {get: function(){return fillOpacity;}, set: function(_){fillOpacity=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          barColor:  {get: function(){return barColor;}, set: function(_){
              barColor = _ ? nv.utils.getColor(_) : null;
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  nv.models.multiBarChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var multibar = nv.models.multiBar()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
          , interactiveLayer = nv.interactiveGuideline()
          , legend = nv.models.legend()
          , controls = nv.models.legend()
          , tooltip = nv.models.tooltip()
          ;
  
      var margin = {top: 30, right: 20, bottom: 50, left: 60}
          , marginTop = null
          , width = null
          , height = null
          , color = nv.utils.defaultColor()
          , showControls = true
          , controlLabels = {}
          , showLegend = true
          , legendPosition = null
          , showXAxis = true
          , showYAxis = true
          , rightAlignYAxis = false
          , reduceXTicks = true // if false a tick will show for every data point
          , staggerLabels = false
          , wrapLabels = false
          , rotateLabels = 0
          , x //can be accessed via chart.xScale()
          , y //can be accessed via chart.yScale()
          , state = nv.utils.state()
          , defaultState = null
          , noData = null
          , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd')
          , controlWidth = function() { return showControls ? 180 : 0 }
          , duration = 250
          , useInteractiveGuideline = false
          ;
  
      state.stacked = false // DEPRECATED Maintained for backward compatibility
  
      multibar.stacked(false);
      xAxis
          .orient('bottom')
          .tickPadding(7)
          .showMaxMin(false)
          .tickFormat(function(d) { return d })
      ;
      yAxis
          .orient((rightAlignYAxis) ? 'right' : 'left')
          .tickFormat(d3.format(',.1f'))
      ;
  
      tooltip
          .duration(0)
          .valueFormatter(function(d, i) {
              return yAxis.tickFormat()(d, i);
          })
          .headerFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          });
  
      interactiveLayer.tooltip
          .valueFormatter(function(d, i) {
              return d == null ? "N/A" : yAxis.tickFormat()(d, i);
          })
          .headerFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          });
  
      interactiveLayer.tooltip
          .valueFormatter(function (d, i) {
              return d == null ? "N/A" : yAxis.tickFormat()(d, i);
          })
          .headerFormatter(function (d, i) {
              return xAxis.tickFormat()(d, i);
          });
  
      interactiveLayer.tooltip
          .duration(0)
          .valueFormatter(function(d, i) {
              return yAxis.tickFormat()(d, i);
          })
          .headerFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          });
  
      controls.updateState(false);
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
      var stacked = false;
  
      var stateGetter = function(data) {
          return function(){
              return {
                  active: data.map(function(d) { return !d.disabled }),
                  stacked: stacked
              };
          }
      };
  
      var stateSetter = function(data) {
          return function(state) {
              if (state.stacked !== undefined)
                  stacked = state.stacked;
              if (state.active !== undefined)
                  data.forEach(function(series,i) {
                      series.disabled = !state.active[i];
                  });
          }
      };
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(multibar);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this),
                  that = this;
              nv.utils.initSVG(container);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() {
                  if (duration === 0)
                      container.call(chart);
                  else
                      container.transition()
                          .duration(duration)
                          .call(chart);
              };
              chart.container = this;
  
              state
                  .setter(stateSetter(data), chart.update)
                  .getter(stateGetter(data))
                  .update();
  
              // DEPRECATED set state.disableddisabled
              state.disabled = data.map(function(d) { return !!d.disabled });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              // Display noData message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container)
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = multibar.xScale();
              y = multibar.yScale();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis');
              gEnter.append('g').attr('class', 'nv-barsWrap');
              gEnter.append('g').attr('class', 'nv-legendWrap');
              gEnter.append('g').attr('class', 'nv-controlsWrap');
              gEnter.append('g').attr('class', 'nv-interactive');
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  if (legendPosition === 'bottom') {
                      legend.width(availableWidth - margin.right);
  
                       g.select('.nv-legendWrap')
                           .datum(data)
                           .call(legend);
  
                       margin.bottom = xAxis.height() + legend.height();
                       availableHeight = nv.utils.availableHeight(height, container, margin);
                       g.select('.nv-legendWrap')
                           .attr('transform', 'translate(0,' + (availableHeight + xAxis.height())  +')');
                  } else {
                      legend.width(availableWidth - controlWidth());
  
                      g.select('.nv-legendWrap')
                          .datum(data)
                          .call(legend);
  
                      if (!marginTop && legend.height() !== margin.top) {
                          margin.top = legend.height();
                          availableHeight = nv.utils.availableHeight(height, container, margin);
                      }
  
                      g.select('.nv-legendWrap')
                          .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
                  }
              }
  
              // Controls
              if (!showControls) {
                   g.select('.nv-controlsWrap').selectAll('*').remove();
              } else {
                  var controlsData = [
                      { key: controlLabels.grouped || 'Grouped', disabled: multibar.stacked() },
                      { key: controlLabels.stacked || 'Stacked', disabled: !multibar.stacked() }
                  ];
  
                  controls.width(controlWidth()).color(['#444', '#444', '#444']);
                  g.select('.nv-controlsWrap')
                      .datum(controlsData)
                      .attr('transform', 'translate(0,' + (-margin.top) +')')
                      .call(controls);
              }
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
              if (rightAlignYAxis) {
                  g.select(".nv-y.nv-axis")
                      .attr("transform", "translate(" + availableWidth + ",0)");
              }
  
              // Main Chart Component(s)
              multibar
                  .disabled(data.map(function(series) { return series.disabled }))
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled }));
  
  
              var barsWrap = g.select('.nv-barsWrap')
                  .datum(data.filter(function(d) { return !d.disabled }));
  
              barsWrap.call(multibar);
  
              // Setup Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize(-availableHeight, 0);
  
                  g.select('.nv-x.nv-axis')
                      .attr('transform', 'translate(0,' + y.range()[0] + ')');
                  g.select('.nv-x.nv-axis')
                      .call(xAxis);
  
                  var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');
  
                  xTicks
                      .selectAll('line, text')
                      .style('opacity', 1)
  
                  if (staggerLabels) {
                      var getTranslate = function(x,y) {
                          return "translate(" + x + "," + y + ")";
                      };
  
                      var staggerUp = 5, staggerDown = 17;  //pixels to stagger by
                      // Issue #140
                      xTicks
                          .selectAll("text")
                          .attr('transform', function(d,i,j) {
                              return  getTranslate(0, (j % 2 == 0 ? staggerUp : staggerDown));
                          });
  
                      var totalInBetweenTicks = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
                      g.selectAll(".nv-x.nv-axis .nv-axisMaxMin text")
                          .attr("transform", function(d,i) {
                              return getTranslate(0, (i === 0 || totalInBetweenTicks % 2 !== 0) ? staggerDown : staggerUp);
                          });
                  }
  
                  if (wrapLabels) {
                      g.selectAll('.tick text')
                          .call(nv.utils.wrapTicks, chart.xAxis.rangeBand())
                  }
  
                  if (reduceXTicks)
                      xTicks
                          .filter(function(d,i) {
                              return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
                          })
                          .selectAll('text, line')
                          .style('opacity', 0);
  
                  if(rotateLabels)
                      xTicks
                          .selectAll('.tick text')
                          .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')
                          .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');
  
                  g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text')
                      .style('opacity', 1);
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                      .tickSize( -availableWidth, 0);
  
                  g.select('.nv-y.nv-axis')
                      .call(yAxis);
              }
  
              //Set up interactive layer
              if (useInteractiveGuideline) {
                  interactiveLayer
                      .width(availableWidth)
                      .height(availableHeight)
                      .margin({left:margin.left, top:margin.top})
                      .svgContainer(container)
                      .xScale(x);
                  wrap.select(".nv-interactive").call(interactiveLayer);
              }
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              legend.dispatch.on('stateChange', function(newState) {
                  for (var key in newState)
                      state[key] = newState[key];
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              controls.dispatch.on('legendClick', function(d,i) {
                  if (!d.disabled) return;
                  controlsData = controlsData.map(function(s) {
                      s.disabled = true;
                      return s;
                  });
                  d.disabled = false;
  
                  switch (d.key) {
                      case 'Grouped':
                      case controlLabels.grouped:
                          multibar.stacked(false);
                          break;
                      case 'Stacked':
                      case controlLabels.stacked:
                          multibar.stacked(true);
                          break;
                  }
  
                  state.stacked = multibar.stacked();
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              // Update chart from a state object passed to event handler
              dispatch.on('changeState', function(e) {
                  if (typeof e.disabled !== 'undefined') {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
                      state.disabled = e.disabled;
                  }
                  if (typeof e.stacked !== 'undefined') {
                      multibar.stacked(e.stacked);
                      state.stacked = e.stacked;
                      stacked = e.stacked;
                  }
                  chart.update();
              });
  
              if (useInteractiveGuideline) {
                  interactiveLayer.dispatch.on('elementMousemove', function(e) {
                      if (e.pointXValue == undefined) return;
  
                      var singlePoint, pointIndex, pointXLocation, xValue, allData = [];
                      data
                          .filter(function(series, i) {
                              series.seriesIndex = i;
                              return !series.disabled;
                          })
                          .forEach(function(series,i) {
                              pointIndex = x.domain().indexOf(e.pointXValue)
  
                              var point = series.values[pointIndex];
                              if (point === undefined) return;
  
                              xValue = point.x;
                              if (singlePoint === undefined) singlePoint = point;
                              if (pointXLocation === undefined) pointXLocation = e.mouseX
                              allData.push({
                                  key: series.key,
                                  value: chart.y()(point, pointIndex),
                                  color: color(series,series.seriesIndex),
                                  data: series.values[pointIndex]
                              });
                          });
  
                      interactiveLayer.tooltip
                          .data({
                              value: xValue,
                              index: pointIndex,
                              series: allData
                          })();
  
                      interactiveLayer.renderGuideLine(pointXLocation);
                  });
  
                  interactiveLayer.dispatch.on("elementMouseout",function(e) {
                      interactiveLayer.tooltip.hidden(true);
                  });
              }
              else {
                  multibar.dispatch.on('elementMouseover.tooltip', function(evt) {
                      evt.value = chart.x()(evt.data);
                      evt['series'] = {
                          key: evt.data.key,
                          value: chart.y()(evt.data),
                          color: evt.color
                      };
                      tooltip.data(evt).hidden(false);
                  });
  
                  multibar.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true);
                  });
  
                  multibar.dispatch.on('elementMousemove.tooltip', function(evt) {
                      tooltip();
                  });
              }
          });
  
          renderWatch.renderEnd('multibarchart immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.multibar = multibar;
      chart.legend = legend;
      chart.controls = controls;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.state = state;
      chart.tooltip = tooltip;
      chart.interactiveLayer = interactiveLayer;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          legendPosition: {get: function(){return legendPosition;}, set: function(_){legendPosition=_;}},
          showControls: {get: function(){return showControls;}, set: function(_){showControls=_;}},
          controlLabels: {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
          showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
          reduceXTicks:    {get: function(){return reduceXTicks;}, set: function(_){reduceXTicks=_;}},
          rotateLabels:    {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},
          staggerLabels:    {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
          wrapLabels:   {get: function(){return wrapLabels;}, set: function(_){wrapLabels=!!_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              multibar.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
              renderWatch.reset(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              legend.color(color);
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( rightAlignYAxis ? 'right' : 'left');
          }},
          useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
              useInteractiveGuideline = _;
          }},
          barColor:  {get: function(){return multibar.barColor;}, set: function(_){
              multibar.barColor(_);
              legend.color(function(d,i) {return d3.rgb('#ccc').darker(i * 1.5).toString();})
          }}
      });
  
      nv.utils.inheritOptions(chart, multibar);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.multiBarHorizontal = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 960
          , height = 500
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container = null
          , x = d3.scale.ordinal()
          , y = d3.scale.linear()
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , getYerr = function(d) { return d.yErr }
          , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
          , color = nv.utils.defaultColor()
          , barColor = null // adding the ability to set the color for each rather than the whole group
          , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled
          , stacked = false
          , showValues = false
          , showBarLabels = false
          , valuePadding = 60
          , groupSpacing = 0.1
          , fillOpacity = 0.75
          , valueFormat = d3.format(',.2f')
          , delay = 1200
          , xDomain
          , yDomain
          , xRange
          , yRange
          , duration = 250
          , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var x0, y0; //used to store previous scales
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right,
                  availableHeight = height - margin.top - margin.bottom;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
  
              if (stacked)
                  data = d3.layout.stack()
                      .offset('zero')
                      .values(function(d){ return d.values })
                      .y(getY)
                  (data);
  
              //add series index and key to each data point for reference
              data.forEach(function(series, i) {
                  series.values.forEach(function(point) {
                      point.series = i;
                      point.key = series.key;
                  });
              });
  
              // HACK for negative value stacking
              if (stacked)
                  data[0].values.map(function(d,i) {
                      var posBase = 0, negBase = 0;
                      data.map(function(d) {
                          var f = d.values[i]
                          f.size = Math.abs(f.y);
                          if (f.y<0)  {
                              f.y1 = negBase - f.size;
                              negBase = negBase - f.size;
                          } else
                          {
                              f.y1 = posBase;
                              posBase = posBase + f.size;
                          }
                      });
                  });
  
              // Setup Scales
              // remap and flatten the data for use in calculating the scales' domains
              var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                  data.map(function(d) {
                      return d.values.map(function(d,i) {
                          return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1 }
                      })
                  });
  
              x.domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                  .rangeBands(xRange || [0, availableHeight], groupSpacing);
  
              y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return stacked ? (d.y > 0 ? d.y1 + d.y : d.y1 ) : d.y }).concat(forceY)))
  
              if (showValues && !stacked)
                  y.range(yRange || [(y.domain()[0] < 0 ? valuePadding : 0), availableWidth - (y.domain()[1] > 0 ? valuePadding : 0) ]);
              else
                  y.range(yRange || [0, availableWidth]);
  
              x0 = x0 || x;
              y0 = y0 || d3.scale.linear().domain(y.domain()).range([y(0),y(0)]);
  
              // Setup containers and skeleton of chart
              var wrap = d3.select(this).selectAll('g.nv-wrap.nv-multibarHorizontal').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibarHorizontal');
              var defsEnter = wrapEnter.append('defs');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-groups');
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                  .data(function(d) { return d }, function(d,i) { return i });
              groups.enter().append('g')
                  .style('stroke-opacity', 1e-6)
                  .style('fill-opacity', 1e-6);
              groups.exit().watchTransition(renderWatch, 'multibarhorizontal: exit groups')
                  .style('stroke-opacity', 1e-6)
                  .style('fill-opacity', 1e-6)
                  .remove();
              groups
                  .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                  .classed('hover', function(d) { return d.hover })
                  .style('fill', function(d,i){ return color(d, i) })
                  .style('stroke', function(d,i){ return color(d, i) });
              groups.watchTransition(renderWatch, 'multibarhorizontal: groups')
                  .style('stroke-opacity', 1)
                  .style('fill-opacity', fillOpacity);
  
              var bars = groups.selectAll('g.nv-bar')
                  .data(function(d) { return d.values });
              bars.exit().remove();
  
              var barsEnter = bars.enter().append('g')
                  .attr('transform', function(d,i,j) {
                      return 'translate(' + y0(stacked ? d.y0 : 0) + ',' + (stacked ? 0 : (j * x.rangeBand() / data.length ) + x(getX(d,i))) + ')'
                  });
  
              barsEnter.append('rect')
                  .attr('width', 0)
                  .attr('height', x.rangeBand() / (stacked ? 1 : data.length) )
  
              bars
                  .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
                      d3.select(this).classed('hover', true);
                      dispatch.elementMouseover({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('mouseout', function(d,i) {
                      d3.select(this).classed('hover', false);
                      dispatch.elementMouseout({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('mouseout', function(d,i) {
                      dispatch.elementMouseout({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('mousemove', function(d,i) {
                      dispatch.elementMousemove({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                  })
                  .on('click', function(d,i) {
                      var element = this;
                      dispatch.elementClick({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill"),
                          event: d3.event,
                          element: element
                      });
                      d3.event.stopPropagation();
                  })
                  .on('dblclick', function(d,i) {
                      dispatch.elementDblClick({
                          data: d,
                          index: i,
                          color: d3.select(this).style("fill")
                      });
                      d3.event.stopPropagation();
                  });
  
              if (getYerr(data[0],0)) {
                  barsEnter.append('polyline');
  
                  bars.select('polyline')
                      .attr('fill', 'none')
                      .attr('points', function(d,i) {
                          var xerr = getYerr(d,i)
                              , mid = 0.8 * x.rangeBand() / ((stacked ? 1 : data.length) * 2);
                          xerr = xerr.length ? xerr : [-Math.abs(xerr), Math.abs(xerr)];
                          xerr = xerr.map(function(e) { return y(e + ((getY(d,i) < 0) ? 0 : getY(d,i))) - y(0); });
                          var a = [[xerr[0],-mid], [xerr[0],mid], [xerr[0],0], [xerr[1],0], [xerr[1],-mid], [xerr[1],mid]];
                          return a.map(function (path) { return path.join(',') }).join(' ');
                      })
                      .attr('transform', function(d,i) {
                          var mid = x.rangeBand() / ((stacked ? 1 : data.length) * 2);
                          return 'translate(0, ' + mid + ')';
                      });
              }
  
              barsEnter.append('text');
  
              if (showValues && !stacked) {
                  bars.select('text')
                      .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'end' : 'start' })
                      .attr('y', x.rangeBand() / (data.length * 2))
                      .attr('dy', '.32em')
                      .text(function(d,i) {
                          var t = valueFormat(getY(d,i))
                              , yerr = getYerr(d,i);
                          if (yerr === undefined)
                              return t;
                          if (!yerr.length)
                              return t + '±' + valueFormat(Math.abs(yerr));
                          return t + '+' + valueFormat(Math.abs(yerr[1])) + '-' + valueFormat(Math.abs(yerr[0]));
                      });
                  bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                      .select('text')
                      .attr('x', function(d,i) { return getY(d,i) < 0 ? -4 : y(getY(d,i)) - y(0) + 4 })
              } else {
                  bars.selectAll('text').text('');
              }
  
              if (showBarLabels && !stacked) {
                  barsEnter.append('text').classed('nv-bar-label',true);
                  bars.select('text.nv-bar-label')
                      .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'start' : 'end' })
                      .attr('y', x.rangeBand() / (data.length * 2))
                      .attr('dy', '.32em')
                      .text(function(d,i) { return getX(d,i) });
                  bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                      .select('text.nv-bar-label')
                      .attr('x', function(d,i) { return getY(d,i) < 0 ? y(0) - y(getY(d,i)) + 4 : -4 });
              }
              else {
                  bars.selectAll('text.nv-bar-label').text('');
              }
  
              bars
                  .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
  
              if (barColor) {
                  if (!disabled) disabled = data.map(function() { return true });
                  bars
                      .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })
                      .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });
              }
  
              if (stacked)
                  bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                      .attr('transform', function(d,i) {
                          return 'translate(' + y(d.y1) + ',' + x(getX(d,i)) + ')'
                      })
                      .select('rect')
                      .attr('width', function(d,i) {
                          return Math.abs(y(getY(d,i) + d.y0) - y(d.y0)) || 0
                      })
                      .attr('height', x.rangeBand() );
              else
                  bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                      .attr('transform', function(d,i) {
                          //TODO: stacked must be all positive or all negative, not both?
                          return 'translate(' +
                              (getY(d,i) < 0 ? y(getY(d,i)) : y(0))
                              + ',' +
                              (d.series * x.rangeBand() / data.length
                                  +
                                  x(getX(d,i)) )
                              + ')'
                      })
                      .select('rect')
                      .attr('height', x.rangeBand() / data.length )
                      .attr('width', function(d,i) {
                          return Math.max(Math.abs(y(getY(d,i)) - y(0)),1) || 0
                      });
  
              //store old scales for use in transitions on update
              x0 = x.copy();
              y0 = y.copy();
  
          });
  
          renderWatch.renderEnd('multibarHorizontal immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:   {get: function(){return width;}, set: function(_){width=_;}},
          height:  {get: function(){return height;}, set: function(_){height=_;}},
          x:       {get: function(){return getX;}, set: function(_){getX=_;}},
          y:       {get: function(){return getY;}, set: function(_){getY=_;}},
          yErr:       {get: function(){return getYerr;}, set: function(_){getYerr=_;}},
          xScale:  {get: function(){return x;}, set: function(_){x=_;}},
          yScale:  {get: function(){return y;}, set: function(_){y=_;}},
          xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
          forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
          stacked: {get: function(){return stacked;}, set: function(_){stacked=_;}},
          showValues: {get: function(){return showValues;}, set: function(_){showValues=_;}},
          // this shows the group name, seems pointless?
          //showBarLabels:    {get: function(){return showBarLabels;}, set: function(_){showBarLabels=_;}},
          disabled:     {get: function(){return disabled;}, set: function(_){disabled=_;}},
          id:           {get: function(){return id;}, set: function(_){id=_;}},
          valueFormat:  {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
          valuePadding: {get: function(){return valuePadding;}, set: function(_){valuePadding=_;}},
          groupSpacing: {get: function(){return groupSpacing;}, set: function(_){groupSpacing=_;}},
          fillOpacity:  {get: function(){return fillOpacity;}, set: function(_){fillOpacity=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          barColor:  {get: function(){return barColor;}, set: function(_){
              barColor = _ ? nv.utils.getColor(_) : null;
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.multiBarHorizontalChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var multibar = nv.models.multiBarHorizontal()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
          , legend = nv.models.legend().height(30)
          , controls = nv.models.legend().height(30)
          , tooltip = nv.models.tooltip()
          ;
  
      var margin = {top: 30, right: 20, bottom: 50, left: 60}
          , marginTop = null
          , width = null
          , height = null
          , color = nv.utils.defaultColor()
          , showControls = true
          , controlsPosition = 'top'        
          , controlLabels = {}
          , showLegend = true
          , legendPosition = 'top'
          , showXAxis = true
          , showYAxis = true
          , stacked = false
          , x //can be accessed via chart.xScale()
          , y //can be accessed via chart.yScale()
          , state = nv.utils.state()
          , defaultState = null
          , noData = null
          , dispatch = d3.dispatch('stateChange', 'changeState','renderEnd')
          , controlWidth = function() { return showControls ? 180 : 0 }
          , duration = 250
          ;
  
      state.stacked = false; // DEPRECATED Maintained for backward compatibility
  
      multibar.stacked(stacked);
  
      xAxis
          .orient('left')
          .tickPadding(5)
          .showMaxMin(false)
          .tickFormat(function(d) { return d })
      ;
      yAxis
          .orient('bottom')
          .tickFormat(d3.format(',.1f'))
      ;
  
      tooltip
          .duration(0)
          .valueFormatter(function(d, i) {
              return yAxis.tickFormat()(d, i);
          })
          .headerFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          });
  
      controls.updateState(false);
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var stateGetter = function(data) {
          return function(){
              return {
                  active: data.map(function(d) { return !d.disabled }),
                  stacked: stacked
              };
          }
      };
  
      var stateSetter = function(data) {
          return function(state) {
              if (state.stacked !== undefined)
                  stacked = state.stacked;
              if (state.active !== undefined)
                  data.forEach(function(series,i) {
                      series.disabled = !state.active[i];
                  });
          }
      };
  
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(multibar);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this),
                  that = this;
              nv.utils.initSVG(container);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() { container.transition().duration(duration).call(chart) };
              chart.container = this;
  
              stacked = multibar.stacked();
  
              state
                  .setter(stateSetter(data), chart.update)
                  .getter(stateGetter(data))
                  .update();
  
              // DEPRECATED set state.disableddisabled
              state.disabled = data.map(function(d) { return !!d.disabled });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container)
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = multibar.xScale();
              y = multibar.yScale().clamp(true);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-multiBarHorizontalChart').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarHorizontalChart').append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis')
                  .append('g').attr('class', 'nv-zeroLine')
                  .append('line');
              gEnter.append('g').attr('class', 'nv-barsWrap');
              gEnter.append('g').attr('class', 'nv-legendWrap');
              gEnter.append('g').attr('class', 'nv-controlsWrap');
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  legend.width(availableWidth - controlWidth());
  
                  g.select('.nv-legendWrap')
                      .datum(data)
                      .call(legend);
                  if (legendPosition === 'bottom') {
                       margin.bottom = xAxis.height() + legend.height();
                       availableHeight = nv.utils.availableHeight(height, container, margin);
                       g.select('.nv-legendWrap')
                           .attr('transform', 'translate(' + controlWidth() + ',' + (availableHeight + xAxis.height())  +')');
                  } else if (legendPosition === 'top') {
  
                      if (!marginTop && legend.height() !== margin.top) {
                          margin.top = legend.height();
                          availableHeight = nv.utils.availableHeight(height, container, margin);
                      }
  
                      g.select('.nv-legendWrap')
                          .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
                  }                    
              }
  
              // Controls
              if (!showControls) {
                   g.select('.nv-controlsWrap').selectAll('*').remove();
              } else {
                  var controlsData = [
                      { key: controlLabels.grouped || 'Grouped', disabled: multibar.stacked() },
                      { key: controlLabels.stacked || 'Stacked', disabled: !multibar.stacked() }
                  ];
  
                  controls.width(controlWidth()).color(['#444', '#444', '#444']);
  
                  if (controlsPosition === 'bottom') {
                       margin.bottom = xAxis.height() + legend.height();
                       availableHeight = nv.utils.availableHeight(height, container, margin);
                      g.select('.nv-controlsWrap')
                          .datum(controlsData)
                          .attr('transform', 'translate(0,' + (availableHeight + xAxis.height()) +')')
                          .call(controls);  
  
                  } else if (controlsPosition === 'top') {
                      g.select('.nv-controlsWrap')
                          .datum(controlsData)
                          .attr('transform', 'translate(0,' + (-margin.top) +')')
                          .call(controls);                        
                  }
              }
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              // Main Chart Component(s)
              multibar
                  .disabled(data.map(function(series) { return series.disabled }))
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled }));
  
              var barsWrap = g.select('.nv-barsWrap')
                  .datum(data.filter(function(d) { return !d.disabled }));
  
              barsWrap.transition().call(multibar);
  
              // Setup Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      ._ticks( nv.utils.calcTicksY(availableHeight/24, data) )
                      .tickSize(-availableWidth, 0);
  
                  g.select('.nv-x.nv-axis').call(xAxis);
  
                  var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
  
                  xTicks
                      .selectAll('line, text');
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize( -availableHeight, 0);
  
                  g.select('.nv-y.nv-axis')
                      .attr('transform', 'translate(0,' + availableHeight + ')');
                  g.select('.nv-y.nv-axis').call(yAxis);
              }
  
              // Zero line
              g.select(".nv-zeroLine line")
                  .attr("x1", y(0))
                  .attr("x2", y(0))
                  .attr("y1", 0)
                  .attr("y2", -availableHeight)
              ;
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              legend.dispatch.on('stateChange', function(newState) {
                  for (var key in newState)
                      state[key] = newState[key];
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              controls.dispatch.on('legendClick', function(d,i) {
                  if (!d.disabled) return;
                  controlsData = controlsData.map(function(s) {
                      s.disabled = true;
                      return s;
                  });
                  d.disabled = false;
  
                  switch (d.key) {
                      case 'Grouped':
                      case controlLabels.grouped:
                          multibar.stacked(false);
                          break;
                      case 'Stacked':
                      case controlLabels.stacked:
                          multibar.stacked(true);
                          break;
                  }
  
                  state.stacked = multibar.stacked();
                  dispatch.stateChange(state);
                  stacked = multibar.stacked();
  
                  chart.update();
              });
  
              // Update chart from a state object passed to event handler
              dispatch.on('changeState', function(e) {
  
                  if (typeof e.disabled !== 'undefined') {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
  
                      state.disabled = e.disabled;
                  }
  
                  if (typeof e.stacked !== 'undefined') {
                      multibar.stacked(e.stacked);
                      state.stacked = e.stacked;
                      stacked = e.stacked;
                  }
  
                  chart.update();
              });
          });
          renderWatch.renderEnd('multibar horizontal chart immediate');
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      multibar.dispatch.on('elementMouseover.tooltip', function(evt) {
          evt.value = chart.x()(evt.data);
          evt['series'] = {
              key: evt.data.key,
              value: chart.y()(evt.data),
              color: evt.color
          };
          tooltip.data(evt).hidden(false);
      });
  
      multibar.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      multibar.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.multibar = multibar;
      chart.legend = legend;
      chart.controls = controls;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.state = state;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          legendPosition: {get: function(){return legendPosition;}, set: function(_){legendPosition=_;}},
          controlsPosition: {get: function(){return controlsPosition;}, set: function(_){controlsPosition=_;}},
          showControls: {get: function(){return showControls;}, set: function(_){showControls=_;}},
          controlLabels: {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
          showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              multibar.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              legend.color(color);
          }},
          barColor:  {get: function(){return multibar.barColor;}, set: function(_){
              multibar.barColor(_);
              legend.color(function(d,i) {return d3.rgb('#ccc').darker(i * 1.5).toString();})
          }}
      });
  
      nv.utils.inheritOptions(chart, multibar);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  nv.models.multiChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 30, right: 20, bottom: 50, left: 60},
          marginTop = null,
          color = nv.utils.defaultColor(),
          width = null,
          height = null,
          showLegend = true,
          noData = null,
          yDomain1,
          yDomain2,
          getX = function(d) { return d.x },
          getY = function(d) { return d.y},
          interpolate = 'linear',
          useVoronoi = true,
          interactiveLayer = nv.interactiveGuideline(),
          useInteractiveGuideline = false,
          legendRightAxisHint = ' (right axis)',
          duration = 250
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var x = d3.scale.linear(),
          yScale1 = d3.scale.linear(),
          yScale2 = d3.scale.linear(),
  
          lines1 = nv.models.line().yScale(yScale1).duration(duration),
          lines2 = nv.models.line().yScale(yScale2).duration(duration),
  
          scatters1 = nv.models.scatter().yScale(yScale1).duration(duration),
          scatters2 = nv.models.scatter().yScale(yScale2).duration(duration),
  
          bars1 = nv.models.multiBar().stacked(false).yScale(yScale1).duration(duration),
          bars2 = nv.models.multiBar().stacked(false).yScale(yScale2).duration(duration),
  
          stack1 = nv.models.stackedArea().yScale(yScale1).duration(duration),
          stack2 = nv.models.stackedArea().yScale(yScale2).duration(duration),
  
          xAxis = nv.models.axis().scale(x).orient('bottom').tickPadding(5).duration(duration),
          yAxis1 = nv.models.axis().scale(yScale1).orient('left').duration(duration),
          yAxis2 = nv.models.axis().scale(yScale2).orient('right').duration(duration),
  
          legend = nv.models.legend().height(30),
          tooltip = nv.models.tooltip(),
          dispatch = d3.dispatch();
  
      var charts = [lines1, lines2, scatters1, scatters2, bars1, bars2, stack1, stack2];
  
      function chart(selection) {
          selection.each(function(data) {
              var container = d3.select(this),
                  that = this;
              nv.utils.initSVG(container);
  
              chart.update = function() { container.transition().call(chart); };
              chart.container = this;
  
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              var dataLines1 = data.filter(function(d) {return d.type == 'line' && d.yAxis == 1});
              var dataLines2 = data.filter(function(d) {return d.type == 'line' && d.yAxis == 2});
              var dataScatters1 = data.filter(function(d) {return d.type == 'scatter' && d.yAxis == 1});
              var dataScatters2 = data.filter(function(d) {return d.type == 'scatter' && d.yAxis == 2});
              var dataBars1 =  data.filter(function(d) {return d.type == 'bar'  && d.yAxis == 1});
              var dataBars2 =  data.filter(function(d) {return d.type == 'bar'  && d.yAxis == 2});
              var dataStack1 = data.filter(function(d) {return d.type == 'area' && d.yAxis == 1});
              var dataStack2 = data.filter(function(d) {return d.type == 'area' && d.yAxis == 2});
  
              // Display noData message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container);
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              var series1 = data.filter(function(d) {return !d.disabled && d.yAxis == 1})
                  .map(function(d) {
                      return d.values.map(function(d,i) {
                          return { x: getX(d), y: getY(d) }
                      })
                  });
  
              var series2 = data.filter(function(d) {return !d.disabled && d.yAxis == 2})
                  .map(function(d) {
                      return d.values.map(function(d,i) {
                          return { x: getX(d), y: getY(d) }
                      })
                  });
  
              x   .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x }))
                  .range([0, availableWidth]);
  
              var wrap = container.selectAll('g.wrap.multiChart').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'wrap nvd3 multiChart').append('g');
  
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y1 nv-axis');
              gEnter.append('g').attr('class', 'nv-y2 nv-axis');
              gEnter.append('g').attr('class', 'stack1Wrap');
              gEnter.append('g').attr('class', 'stack2Wrap');
              gEnter.append('g').attr('class', 'bars1Wrap');
              gEnter.append('g').attr('class', 'bars2Wrap');
              gEnter.append('g').attr('class', 'scatters1Wrap');
              gEnter.append('g').attr('class', 'scatters2Wrap');
              gEnter.append('g').attr('class', 'lines1Wrap');
              gEnter.append('g').attr('class', 'lines2Wrap');
              gEnter.append('g').attr('class', 'legendWrap');
              gEnter.append('g').attr('class', 'nv-interactive');
  
              var g = wrap.select('g');
  
              var color_array = data.map(function(d,i) {
                  return data[i].color || color(d, i);
              });
  
              // Legend
              if (!showLegend) {
                  g.select('.legendWrap').selectAll('*').remove();
              } else {
                  var legendWidth = legend.align() ? availableWidth / 2 : availableWidth;
                  var legendXPosition = legend.align() ? legendWidth : 0;
  
                  legend.width(legendWidth);
                  legend.color(color_array);
  
                  g.select('.legendWrap')
                      .datum(data.map(function(series) {
                          series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                          series.key = series.originalKey + (series.yAxis == 1 ? '' : legendRightAxisHint);
                          return series;
                      }))
                      .call(legend);
  
                  if (!marginTop && legend.height() !== margin.top) {
                      margin.top = legend.height();
                      availableHeight = nv.utils.availableHeight(height, container, margin);
                  }
  
                  g.select('.legendWrap')
                      .attr('transform', 'translate(' + legendXPosition + ',' + (-margin.top) +')');
              }
  
              lines1
                  .width(availableWidth)
                  .height(availableHeight)
                  .interpolate(interpolate)
                  .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'line'}));
              lines2
                  .width(availableWidth)
                  .height(availableHeight)
                  .interpolate(interpolate)
                  .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'line'}));
              scatters1
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'scatter'}));
              scatters2
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'scatter'}));
              bars1
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'bar'}));
              bars2
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'bar'}));
              stack1
                  .width(availableWidth)
                  .height(availableHeight)
                  .interpolate(interpolate)
                  .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'area'}));
              stack2
                  .width(availableWidth)
                  .height(availableHeight)
                  .interpolate(interpolate)
                  .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'area'}));
  
              g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              var lines1Wrap = g.select('.lines1Wrap')
                  .datum(dataLines1.filter(function(d){return !d.disabled}));
              var scatters1Wrap = g.select('.scatters1Wrap')
                  .datum(dataScatters1.filter(function(d){return !d.disabled}));
              var bars1Wrap = g.select('.bars1Wrap')
                  .datum(dataBars1.filter(function(d){return !d.disabled}));
              var stack1Wrap = g.select('.stack1Wrap')
                  .datum(dataStack1.filter(function(d){return !d.disabled}));
              var lines2Wrap = g.select('.lines2Wrap')
                  .datum(dataLines2.filter(function(d){return !d.disabled}));
              var scatters2Wrap = g.select('.scatters2Wrap')
                  .datum(dataScatters2.filter(function(d){return !d.disabled}));
              var bars2Wrap = g.select('.bars2Wrap')
                  .datum(dataBars2.filter(function(d){return !d.disabled}));
              var stack2Wrap = g.select('.stack2Wrap')
                  .datum(dataStack2.filter(function(d){return !d.disabled}));
  
              var extraValue1BarStacked = [];
              if (bars1.stacked() && dataBars1.length) {
                  var extraValue1BarStacked = dataBars1.filter(function(d){return !d.disabled}).map(function(a){return a.values});
                  
                  if (extraValue1BarStacked.length > 0)
                      extraValue1BarStacked = extraValue1BarStacked.reduce(function(a,b){
                          return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})
                      });
              }
              if (dataBars1.length) {
                  extraValue1BarStacked.push({x:0, y:0});
              }
              
              var extraValue2BarStacked = [];
              if (bars2.stacked() && dataBars2.length) {
                  var extraValue2BarStacked = dataBars2.filter(function(d){return !d.disabled}).map(function(a){return a.values});
                  
                  if (extraValue2BarStacked.length > 0)
                      extraValue2BarStacked = extraValue2BarStacked.reduce(function(a,b){
                          return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})
                      });
              }
              if (dataBars2.length) {
                  extraValue2BarStacked.push({x:0, y:0});
              }
              
              yScale1 .domain(yDomain1 || d3.extent(d3.merge(series1).concat(extraValue1BarStacked), function(d) { return d.y } ))
                  .range([0, availableHeight]);
  
              yScale2 .domain(yDomain2 || d3.extent(d3.merge(series2).concat(extraValue2BarStacked), function(d) { return d.y } ))
                  .range([0, availableHeight]);
  
              lines1.yDomain(yScale1.domain());
              scatters1.yDomain(yScale1.domain());
              bars1.yDomain(yScale1.domain());
              stack1.yDomain(yScale1.domain());
  
              lines2.yDomain(yScale2.domain());
              scatters2.yDomain(yScale2.domain());
              bars2.yDomain(yScale2.domain());
              stack2.yDomain(yScale2.domain());
  
              if(dataStack1.length){d3.transition(stack1Wrap).call(stack1);}
              if(dataStack2.length){d3.transition(stack2Wrap).call(stack2);}
  
              if(dataBars1.length){d3.transition(bars1Wrap).call(bars1);}
              if(dataBars2.length){d3.transition(bars2Wrap).call(bars2);}
  
              if(dataLines1.length){d3.transition(lines1Wrap).call(lines1);}
              if(dataLines2.length){d3.transition(lines2Wrap).call(lines2);}
  
              if(dataScatters1.length){d3.transition(scatters1Wrap).call(scatters1);}
              if(dataScatters2.length){d3.transition(scatters2Wrap).call(scatters2);}
  
              xAxis
                  ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                  .tickSize(-availableHeight, 0);
  
              g.select('.nv-x.nv-axis')
                  .attr('transform', 'translate(0,' + availableHeight + ')');
              d3.transition(g.select('.nv-x.nv-axis'))
                  .call(xAxis);
  
              yAxis1
                  ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                  .tickSize( -availableWidth, 0);
  
  
              d3.transition(g.select('.nv-y1.nv-axis'))
                  .call(yAxis1);
  
              yAxis2
                  ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                  .tickSize( -availableWidth, 0);
  
              d3.transition(g.select('.nv-y2.nv-axis'))
                  .call(yAxis2);
  
              g.select('.nv-y1.nv-axis')
                  .classed('nv-disabled', series1.length ? false : true)
                  .attr('transform', 'translate(' + x.range()[0] + ',0)');
  
              g.select('.nv-y2.nv-axis')
                  .classed('nv-disabled', series2.length ? false : true)
                  .attr('transform', 'translate(' + x.range()[1] + ',0)');
  
              legend.dispatch.on('stateChange', function(newState) {
                  chart.update();
              });
  
              if(useInteractiveGuideline){
                  interactiveLayer
                      .width(availableWidth)
                      .height(availableHeight)
                      .margin({left:margin.left, top:margin.top})
                      .svgContainer(container)
                      .xScale(x);
                  wrap.select(".nv-interactive").call(interactiveLayer);
              }
  
              //============================================================
              // Event Handling/Dispatching
              //------------------------------------------------------------
  
              function mouseover_line(evt) {
                  var yaxis = evt.series.yAxis === 2 ? yAxis2 : yAxis1;
                  evt.value = evt.point.x;
                  evt.series = {
                      value: evt.point.y,
                      color: evt.point.color,
                      key: evt.series.key
                  };
                  tooltip
                      .duration(0)
                      .headerFormatter(function(d, i) {
                        return xAxis.tickFormat()(d, i);
                      })
                      .valueFormatter(function(d, i) {
                          return yaxis.tickFormat()(d, i);
                      })
                      .data(evt)
                      .hidden(false);
              }
  
              function mouseover_scatter(evt) {
                  var yaxis = evt.series.yAxis === 2 ? yAxis2 : yAxis1;
                  evt.value = evt.point.x;
                  evt.series = {
                      value: evt.point.y,
                      color: evt.point.color,
                      key: evt.series.key
                  };
                  tooltip
                      .duration(100)
                      .headerFormatter(function(d, i) {
                        return xAxis.tickFormat()(d, i);
                      })
                      .valueFormatter(function(d, i) {
                          return yaxis.tickFormat()(d, i);
                      })
                      .data(evt)
                      .hidden(false);
              }
  
              function mouseover_stack(evt) {
                  var yaxis = evt.series.yAxis === 2 ? yAxis2 : yAxis1;
                  evt.point['x'] = stack1.x()(evt.point);
                  evt.point['y'] = stack1.y()(evt.point);
                  tooltip
                      .duration(0)
                      .headerFormatter(function(d, i) {
                        return xAxis.tickFormat()(d, i);
                      })
                      .valueFormatter(function(d, i) {
                          return yaxis.tickFormat()(d, i);
                      })
                      .data(evt)
                      .hidden(false);
              }
  
              function mouseover_bar(evt) {
                  var yaxis = evt.series.yAxis === 2 ? yAxis2 : yAxis1;
  
                  evt.value = bars1.x()(evt.data);
                  evt['series'] = {
                      value: bars1.y()(evt.data),
                      color: evt.color,
                      key: evt.data.key
                  };
                  tooltip
                      .duration(0)
                      .headerFormatter(function(d, i) {
                        return xAxis.tickFormat()(d, i);
                      })
                      .valueFormatter(function(d, i) {
                          return yaxis.tickFormat()(d, i);
                      })
                      .data(evt)
                      .hidden(false);
              }
  
  
  
              function clearHighlights() {
                for(var i=0, il=charts.length; i < il; i++){
                  var chart = charts[i];
                  try {
                    chart.clearHighlights();
                  } catch(e){}
                }
              }
  
              function highlightPoint(serieIndex, pointIndex, b){
                for(var i=0, il=charts.length; i < il; i++){
                  var chart = charts[i];
                  try {
                    chart.highlightPoint(serieIndex, pointIndex, b);
                  } catch(e){}
                }
              }
  
              if(useInteractiveGuideline){
                  interactiveLayer.dispatch.on('elementMousemove', function(e) {
                      clearHighlights();
                      var singlePoint, pointIndex, pointXLocation, allData = [];
                      data
                      .filter(function(series, i) {
                          series.seriesIndex = i;
                          return !series.disabled;
                      })
                      .forEach(function(series,i) {
                          var extent = x.domain();
                          var currentValues = series.values.filter(function(d,i) {
                              return chart.x()(d,i) >= extent[0] && chart.x()(d,i) <= extent[1];
                          });
  
                          pointIndex = nv.interactiveBisect(currentValues, e.pointXValue, chart.x());
                          var point = currentValues[pointIndex];
                          var pointYValue = chart.y()(point, pointIndex);
                          if (pointYValue !== null) {
                              highlightPoint(i, pointIndex, true);
                          }
                          if (point === undefined) return;
                          if (singlePoint === undefined) singlePoint = point;
                          if (pointXLocation === undefined) pointXLocation = x(chart.x()(point,pointIndex));
                          allData.push({
                              key: series.key,
                              value: pointYValue,
                              color: color(series,series.seriesIndex),
                              data: point,
                              yAxis: series.yAxis == 2 ? yAxis2 : yAxis1
                          });
                      });
  
                      var defaultValueFormatter = function(d,i) {
                          var yAxis = allData[i].yAxis;
                          return d == null ? "N/A" : yAxis.tickFormat()(d);
                      };
  
                      interactiveLayer.tooltip
                          .headerFormatter(function(d, i) {
                              return xAxis.tickFormat()(d, i);
                          })
                          .valueFormatter(interactiveLayer.tooltip.valueFormatter() || defaultValueFormatter)
                          .data({
                              value: chart.x()( singlePoint,pointIndex ),
                              index: pointIndex,
                              series: allData
                          })();
  
                      interactiveLayer.renderGuideLine(pointXLocation);
                  });
  
                  interactiveLayer.dispatch.on("elementMouseout",function(e) {
                      clearHighlights();
                  });
              } else {
                  lines1.dispatch.on('elementMouseover.tooltip', mouseover_line);
                  lines2.dispatch.on('elementMouseover.tooltip', mouseover_line);
                  lines1.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true)
                  });
                  lines2.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true)
                  });
  
                  scatters1.dispatch.on('elementMouseover.tooltip', mouseover_scatter);
                  scatters2.dispatch.on('elementMouseover.tooltip', mouseover_scatter);
                  scatters1.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true)
                  });
                  scatters2.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true)
                  });
  
                  stack1.dispatch.on('elementMouseover.tooltip', mouseover_stack);
                  stack2.dispatch.on('elementMouseover.tooltip', mouseover_stack);
                  stack1.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true)
                  });
                  stack2.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true)
                  });
  
                  bars1.dispatch.on('elementMouseover.tooltip', mouseover_bar);
                  bars2.dispatch.on('elementMouseover.tooltip', mouseover_bar);
  
                  bars1.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true);
                  });
                  bars2.dispatch.on('elementMouseout.tooltip', function(evt) {
                      tooltip.hidden(true);
                  });
                  bars1.dispatch.on('elementMousemove.tooltip', function(evt) {
                      tooltip();
                  });
                  bars2.dispatch.on('elementMousemove.tooltip', function(evt) {
                      tooltip();
                  });
              }
          });
  
          return chart;
      }
  
      //============================================================
      // Global getters and setters
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.legend = legend;
      chart.lines1 = lines1;
      chart.lines2 = lines2;
      chart.scatters1 = scatters1;
      chart.scatters2 = scatters2;
      chart.bars1 = bars1;
      chart.bars2 = bars2;
      chart.stack1 = stack1;
      chart.stack2 = stack2;
      chart.xAxis = xAxis;
      chart.yAxis1 = yAxis1;
      chart.yAxis2 = yAxis2;
      chart.tooltip = tooltip;
      chart.interactiveLayer = interactiveLayer;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          xScale: {get: function(){return x;}, set: function(_){ x = _; xAxis.scale(x); }},
          yDomain1:      {get: function(){return yDomain1;}, set: function(_){yDomain1=_;}},
          yDomain2:    {get: function(){return yDomain2;}, set: function(_){yDomain2=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
          interpolate:    {get: function(){return interpolate;}, set: function(_){interpolate=_;}},
          legendRightAxisHint:    {get: function(){return legendRightAxisHint;}, set: function(_){legendRightAxisHint=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          x: {get: function(){return getX;}, set: function(_){
              getX = _;
              lines1.x(_);
              lines2.x(_);
              scatters1.x(_);
              scatters2.x(_);
              bars1.x(_);
              bars2.x(_);
              stack1.x(_);
              stack2.x(_);
          }},
          y: {get: function(){return getY;}, set: function(_){
              getY = _;
              lines1.y(_);
              lines2.y(_);
              scatters1.y(_);
              scatters2.y(_);
              stack1.y(_);
              stack2.y(_);
              bars1.y(_);
              bars2.y(_);
          }},
          useVoronoi: {get: function(){return useVoronoi;}, set: function(_){
              useVoronoi=_;
              lines1.useVoronoi(_);
              lines2.useVoronoi(_);
              stack1.useVoronoi(_);
              stack2.useVoronoi(_);
          }},
  
          useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
              useInteractiveGuideline = _;
              if (useInteractiveGuideline) {
                  lines1.interactive(false);
                  lines1.useVoronoi(false);
                  lines2.interactive(false);
                  lines2.useVoronoi(false);
                  stack1.interactive(false);
                  stack1.useVoronoi(false);
                  stack2.interactive(false);
                  stack2.useVoronoi(false);
                  scatters1.interactive(false);
                  scatters2.interactive(false);
              }
          }},
  
          duration: {get: function(){return duration;}, set: function(_) {
              duration = _;
              [lines1, lines2, stack1, stack2, scatters1, scatters2, xAxis, yAxis1, yAxis2].forEach(function(model){
                model.duration(duration);
              });
          }}
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.ohlcBar = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = null
          , height = null
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container = null
          , x = d3.scale.linear()
          , y = d3.scale.linear()
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , getOpen = function(d) { return d.open }
          , getClose = function(d) { return d.close }
          , getHigh = function(d) { return d.high }
          , getLow = function(d) { return d.low }
          , forceX = []
          , forceY = []
          , padData     = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
          , clipEdge = true
          , color = nv.utils.defaultColor()
          , interactive = false
          , xDomain
          , yDomain
          , xRange
          , yRange
          , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd', 'chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove')
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      function chart(selection) {
          selection.each(function(data) {
              container = d3.select(this);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              nv.utils.initSVG(container);
  
              // ohlc bar width.
              var w = (availableWidth / data[0].values.length) * .9;
  
              // Setup Scales
              x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));
  
              if (padData)
                  x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
              else
                  x.range(xRange || [5 + w/2, availableWidth - w/2 - 5]);
  
              y.domain(yDomain || [
                      d3.min(data[0].values.map(getLow).concat(forceY)),
                      d3.max(data[0].values.map(getHigh).concat(forceY))
                  ]
              ).range(yRange || [availableHeight, 0]);
  
              // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
              if (x.domain()[0] === x.domain()[1])
                  x.domain()[0] ?
                      x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                      : x.domain([-1,1]);
  
              if (y.domain()[0] === y.domain()[1])
                  y.domain()[0] ?
                      y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                      : y.domain([-1,1]);
  
              // Setup containers and skeleton of chart
              var wrap = d3.select(this).selectAll('g.nv-wrap.nv-ohlcBar').data([data[0].values]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-ohlcBar');
              var defsEnter = wrapEnter.append('defs');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-ticks');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              container
                  .on('click', function(d,i) {
                      dispatch.chartClick({
                          data: d,
                          index: i,
                          pos: d3.event,
                          id: id
                      });
                  });
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-chart-clip-path-' + id)
                  .append('rect');
  
              wrap.select('#nv-chart-clip-path-' + id + ' rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              g   .attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');
  
              var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick')
                  .data(function(d) { return d });
              ticks.exit().remove();
  
              ticks.enter().append('path')
                  .attr('class', function(d,i,j) { return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i })
                  .attr('d', function(d,i) {
                      return 'm0,0l0,'
                          + (y(getOpen(d,i))
                              - y(getHigh(d,i)))
                          + 'l'
                          + (-w/2)
                          + ',0l'
                          + (w/2)
                          + ',0l0,'
                          + (y(getLow(d,i)) - y(getOpen(d,i)))
                          + 'l0,'
                          + (y(getClose(d,i))
                              - y(getLow(d,i)))
                          + 'l'
                          + (w/2)
                          + ',0l'
                          + (-w/2)
                          + ',0z';
                  })
                  .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })
                  .attr('fill', function(d,i) { return color[0]; })
                  .attr('stroke', function(d,i) { return color[0]; })
                  .attr('x', 0 )
                  .attr('y', function(d,i) {  return y(Math.max(0, getY(d,i))) })
                  .attr('height', function(d,i) { return Math.abs(y(getY(d,i)) - y(0)) });
  
              // the bar colors are controlled by CSS currently
              ticks.attr('class', function(d,i,j) {
                  return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;
              });
  
              d3.transition(ticks)
                  .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })
                  .attr('d', function(d,i) {
                      var w = (availableWidth / data[0].values.length) * .9;
                      return 'm0,0l0,'
                          + (y(getOpen(d,i))
                              - y(getHigh(d,i)))
                          + 'l'
                          + (-w/2)
                          + ',0l'
                          + (w/2)
                          + ',0l0,'
                          + (y(getLow(d,i))
                              - y(getOpen(d,i)))
                          + 'l0,'
                          + (y(getClose(d,i))
                              - y(getLow(d,i)))
                          + 'l'
                          + (w/2)
                          + ',0l'
                          + (-w/2)
                          + ',0z';
                  });
          });
  
          return chart;
      }
  
  
      //Create methods to allow outside functions to highlight a specific bar.
      chart.highlightPoint = function(pointIndex, isHoverOver) {
          chart.clearHighlights();
          container.select(".nv-ohlcBar .nv-tick-0-" + pointIndex)
              .classed("hover", isHoverOver)
          ;
      };
  
      chart.clearHighlights = function() {
          container.select(".nv-ohlcBar .nv-tick.hover")
              .classed("hover", false)
          ;
      };
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:    {get: function(){return width;}, set: function(_){width=_;}},
          height:   {get: function(){return height;}, set: function(_){height=_;}},
          xScale:   {get: function(){return x;}, set: function(_){x=_;}},
          yScale:   {get: function(){return y;}, set: function(_){y=_;}},
          xDomain:  {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain:  {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:   {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:   {get: function(){return yRange;}, set: function(_){yRange=_;}},
          forceX:   {get: function(){return forceX;}, set: function(_){forceX=_;}},
          forceY:   {get: function(){return forceY;}, set: function(_){forceY=_;}},
          padData:  {get: function(){return padData;}, set: function(_){padData=_;}},
          clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
          id:       {get: function(){return id;}, set: function(_){id=_;}},
          interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},
  
          x:     {get: function(){return getX;}, set: function(_){getX=_;}},
          y:     {get: function(){return getY;}, set: function(_){getY=_;}},
          open:  {get: function(){return getOpen();}, set: function(_){getOpen=_;}},
          close: {get: function(){return getClose();}, set: function(_){getClose=_;}},
          high:  {get: function(){return getHigh;}, set: function(_){getHigh=_;}},
          low:   {get: function(){return getLow;}, set: function(_){getLow=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    != undefined ? _.top    : margin.top;
              margin.right  = _.right  != undefined ? _.right  : margin.right;
              margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   != undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }}
      });
  
      nv.utils.initOptions(chart);
      return chart;
  };
  // Code adapted from Jason Davies' "Parallel Coordinates"
  // http://bl.ocks.org/jasondavies/1341281
  nv.models.parallelCoordinates = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 30, right: 0, bottom: 10, left: 0}
          , width = null
          , height = null
          , availableWidth = null
          , availableHeight = null
          , x = d3.scale.ordinal()
          , y = {}
          , undefinedValuesLabel = "undefined values"
          , dimensionData = []
          , enabledDimensions = []
          , dimensionNames = []
          , displayBrush = true
          , color = nv.utils.defaultColor()
          , filters = []
          , active = []
          , dragging = []
          , axisWithUndefinedValues = []
          , lineTension = 1
          , foreground
          , background
          , dimensions
          , line = d3.svg.line()
          , axis = d3.svg.axis()
          , dispatch = d3.dispatch('brushstart', 'brush', 'brushEnd', 'dimensionsOrder', "stateChange", 'elementClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd', 'activeChanged')
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var container = d3.select(this);
              availableWidth = nv.utils.availableWidth(width, container, margin);
              availableHeight = nv.utils.availableHeight(height, container, margin);
  
              nv.utils.initSVG(container);
  
             //Convert old data to new format (name, values)
              if (data[0].values === undefined) {
                  var newData = [];
                  data.forEach(function (d) {
                          var val = {};
                          var key = Object.keys(d);
                          key.forEach(function (k) { if (k !== "name") val[k] = d[k] });
                          newData.push({ key: d.name, values: val });
                  });
                  data = newData;
              }
  
              var dataValues = data.map(function (d) {return d.values});
              if (active.length === 0) {
                  active = data;
              }; //set all active before first brush call
              
              dimensionNames = dimensionData.sort(function (a, b) { return a.currentPosition - b.currentPosition; }).map(function (d) { return d.key });
              enabledDimensions = dimensionData.filter(function (d) { return !d.disabled; });
              
              // Setup Scales
              x.rangePoints([0, availableWidth], 1).domain(enabledDimensions.map(function (d) { return d.key; }));
  
              //Set as true if all values on an axis are missing.
              // Extract the list of dimensions and create a scale for each.
              var oldDomainMaxValue = {};
              var displayMissingValuesline = false;
              var currentTicks = [];
              
              dimensionNames.forEach(function(d) {
                  var extent = d3.extent(dataValues, function (p) { return +p[d]; });
                  var min = extent[0];
                  var max = extent[1];
                  var onlyUndefinedValues = false;
                  //If there is no values to display on an axis, set the extent to 0
                  if (isNaN(min) || isNaN(max)) {
                      onlyUndefinedValues = true;
                      min = 0;
                      max = 0;
                  }
                  //Scale axis if there is only one value
                  if (min === max) {
                      min = min - 1;
                      max = max + 1;
                  }
                  var f = filters.filter(function (k) { return k.dimension == d; });
                  if (f.length !== 0) {
                      //If there is only NaN values, keep the existing domain.
                      if (onlyUndefinedValues) {
                          min = y[d].domain()[0];
                          max = y[d].domain()[1];
                      }
                          //If the brush extent is > max (< min), keep the extent value.
                      else if (!f[0].hasOnlyNaN && displayBrush) {
                          min = min > f[0].extent[0] ? f[0].extent[0] : min;
                          max = max < f[0].extent[1] ? f[0].extent[1] : max;
                      }
                          //If there is NaN values brushed be sure the brush extent is on the domain.
                      else if (f[0].hasNaN) {
                          max = max < f[0].extent[1] ? f[0].extent[1] : max;
                          oldDomainMaxValue[d] = y[d].domain()[1];
                          displayMissingValuesline = true;
                      }
                  }
                  //Use 90% of (availableHeight - 12) for the axis range, 12 reprensenting the space necessary to display "undefined values" text.
                  //The remaining 10% are used to display the missingValue line.
                  y[d] = d3.scale.linear()
                      .domain([min, max])
                      .range([(availableHeight - 12) * 0.9, 0]);
  
                  axisWithUndefinedValues = [];
                  y[d].brush = d3.svg.brush().y(y[d]).on('brushstart', brushstart).on('brush', brush).on('brushend', brushend);
              });
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-parallelCoordinates').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-parallelCoordinates');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-parallelCoordinates background');
              gEnter.append('g').attr('class', 'nv-parallelCoordinates foreground');
              gEnter.append('g').attr('class', 'nv-parallelCoordinates missingValuesline');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              line.interpolate('cardinal').tension(lineTension);
              axis.orient('left');
              var axisDrag = d3.behavior.drag()
                          .on('dragstart', dragStart)
                          .on('drag', dragMove)
                          .on('dragend', dragEnd);
  
              //Add missing value line at the bottom of the chart
              var missingValuesline, missingValueslineText;
              var step = x.range()[1] - x.range()[0];
              step = isNaN(step) ? x.range()[0] : step;
              if (!isNaN(step)) {
                  var lineData = [0 + step / 2, availableHeight - 12, availableWidth - step / 2, availableHeight - 12];
                  missingValuesline = wrap.select('.missingValuesline').selectAll('line').data([lineData]);
                  missingValuesline.enter().append('line');
                  missingValuesline.exit().remove();
                  missingValuesline.attr("x1", function(d) { return d[0]; })
                          .attr("y1", function(d) { return d[1]; })
                          .attr("x2", function(d) { return d[2]; })
                          .attr("y2", function(d) { return d[3]; });
      
                  //Add the text "undefined values" under the missing value line
                  missingValueslineText = wrap.select('.missingValuesline').selectAll('text').data([undefinedValuesLabel]);
                  missingValueslineText.append('text').data([undefinedValuesLabel]);
                  missingValueslineText.enter().append('text');
                  missingValueslineText.exit().remove();
                  missingValueslineText.attr("y", availableHeight)
                          //To have the text right align with the missingValues line, substract 92 representing the text size.
                          .attr("x", availableWidth - 92 - step / 2)
                          .text(function(d) { return d; });
              }
              // Add grey background lines for context.
              background = wrap.select('.background').selectAll('path').data(data);
              background.enter().append('path');
              background.exit().remove();
              background.attr('d', path);
  
              // Add blue foreground lines for focus.
              foreground = wrap.select('.foreground').selectAll('path').data(data);
              foreground.enter().append('path')
              foreground.exit().remove();
              foreground.attr('d', path)
                  .style("stroke-width", function (d, i) {
                  if (isNaN(d.strokeWidth)) { d.strokeWidth = 1;} return d.strokeWidth;})
                  .attr('stroke', function (d, i) { return d.color || color(d, i); });
              foreground.on("mouseover", function (d, i) {
                  d3.select(this).classed('hover', true).style("stroke-width", d.strokeWidth + 2 + "px").style("stroke-opacity", 1);
                  dispatch.elementMouseover({
                      label: d.name,
                      color: d.color || color(d, i),
                      values: d.values,
                      dimensions: enabledDimensions
                  });
  
              });
              foreground.on("mouseout", function (d, i) {
                  d3.select(this).classed('hover', false).style("stroke-width", d.strokeWidth + "px").style("stroke-opacity", 0.7);
                  dispatch.elementMouseout({
                      label: d.name,
                      index: i
                  });
              });
              foreground.on('mousemove', function (d, i) {
                  dispatch.elementMousemove();
              });
              foreground.on('click', function (d) {
                  dispatch.elementClick({
                      id: d.id
                  });
              });
              // Add a group element for each dimension.
              dimensions = g.selectAll('.dimension').data(enabledDimensions);
              var dimensionsEnter = dimensions.enter().append('g').attr('class', 'nv-parallelCoordinates dimension');
  
              dimensions.attr('transform', function(d) { return 'translate(' + x(d.key) + ',0)'; });
              dimensionsEnter.append('g').attr('class', 'nv-axis');
  
              // Add an axis and title.
              dimensionsEnter.append('text')
                  .attr('class', 'nv-label')
                  .style("cursor", "move")
                  .attr('dy', '-1em')
                  .attr('text-anchor', 'middle')
                  .on("mouseover", function(d, i) {
                      dispatch.elementMouseover({
                          label: d.tooltip || d.key,
                          color: d.color 
                      });
                  })
                  .on("mouseout", function(d, i) {
                      dispatch.elementMouseout({
                          label: d.tooltip
                      });
                  })
                  .on('mousemove', function (d, i) {
                      dispatch.elementMousemove();
                  })
                  .call(axisDrag);
  
              dimensionsEnter.append('g').attr('class', 'nv-brushBackground');
              dimensions.exit().remove();
              dimensions.select('.nv-label').text(function (d) { return d.key });
  
              // Add and store a brush for each axis.
              restoreBrush(displayBrush);
  
              var actives = dimensionNames.filter(function (p) { return !y[p].brush.empty(); }),
                      extents = actives.map(function (p) { return y[p].brush.extent(); });
              var formerActive = active.slice(0);
  
              //Restore active values
              active = [];
              foreground.style("display", function (d) {
                  var isActive = actives.every(function (p, i) {
                      if ((isNaN(d.values[p]) || isNaN(parseFloat(d.values[p]))) && extents[i][0] == y[p].brush.y().domain()[0]) {
                          return true;
                      }
                      return (extents[i][0] <= d.values[p] && d.values[p] <= extents[i][1]) && !isNaN(parseFloat(d.values[p]));
                  });
                  if (isActive)
                      active.push(d);
                  return !isActive ? "none" : null;
  
              });
  
              if (filters.length > 0 || !nv.utils.arrayEquals(active, formerActive)) {
                 dispatch.activeChanged(active);
              }
  
              // Returns the path for a given data point.
              function path(d) {
                  return line(enabledDimensions.map(function (p) {
                      //If value if missing, put the value on the missing value line
                      if (isNaN(d.values[p.key]) || isNaN(parseFloat(d.values[p.key])) || displayMissingValuesline) {
                          var domain = y[p.key].domain();
                          var range = y[p.key].range();
                          var min = domain[0] - (domain[1] - domain[0]) / 9;
  
                          //If it's not already the case, allow brush to select undefined values
                          if (axisWithUndefinedValues.indexOf(p.key) < 0) {
  
                              var newscale = d3.scale.linear().domain([min, domain[1]]).range([availableHeight - 12, range[1]]);
                              y[p.key].brush.y(newscale);
                              axisWithUndefinedValues.push(p.key);
                          }
                          if (isNaN(d.values[p.key]) || isNaN(parseFloat(d.values[p.key]))) {
                              return [x(p.key), y[p.key](min)];
                          }
                      }
  
                      //If parallelCoordinate contain missing values show the missing values line otherwise, hide it.
                      if (missingValuesline !== undefined) {
                          if (axisWithUndefinedValues.length > 0 || displayMissingValuesline) {
                              missingValuesline.style("display", "inline");
                              missingValueslineText.style("display", "inline");
                          } else {
                              missingValuesline.style("display", "none");
                              missingValueslineText.style("display", "none");
                          }
                      }
                      return [x(p.key), y[p.key](d.values[p.key])];
                  }));
              }
  
              function restoreBrush(visible) {
                  filters.forEach(function (f) {
                      //If filter brushed NaN values, keep the brush on the bottom of the axis.
                      var brushDomain = y[f.dimension].brush.y().domain();
                      if (f.hasOnlyNaN) {
                          f.extent[1] = (y[f.dimension].domain()[1] - brushDomain[0]) * (f.extent[1] - f.extent[0]) / (oldDomainMaxValue[f.dimension] - f.extent[0]) + brushDomain[0];
                      }
                      if (f.hasNaN) {
                          f.extent[0] = brushDomain[0];
                      }
                      if (visible)
                          y[f.dimension].brush.extent(f.extent);
                  });
                  
                  dimensions.select('.nv-brushBackground')
                      .each(function (d) {
                          d3.select(this).call(y[d.key].brush);
  
                      })
                      .selectAll('rect')
                      .attr('x', -8)
                      .attr('width', 16);
                  
                  updateTicks();
              }
              
              // Handles a brush event, toggling the display of foreground lines.
              function brushstart() {
                  //If brush aren't visible, show it before brushing again.
                  if (displayBrush === false) {
                      displayBrush = true;
                      restoreBrush(true);
                  }
              }
              
              // Handles a brush event, toggling the display of foreground lines.
              function brush() {
                  actives = dimensionNames.filter(function (p) { return !y[p].brush.empty(); });
                  extents = actives.map(function(p) { return y[p].brush.extent(); });
  
                  filters = []; //erase current filters
                  actives.forEach(function(d,i) {
                      filters[i] = {
                          dimension: d,
                          extent: extents[i],
                          hasNaN: false,
                          hasOnlyNaN: false
                      }
                  });
  
                  active = []; //erase current active list
                  foreground.style('display', function(d) {
                      var isActive = actives.every(function(p, i) {
                          if ((isNaN(d.values[p]) || isNaN(parseFloat(d.values[p]))) && extents[i][0] == y[p].brush.y().domain()[0]) return true;
                          return (extents[i][0] <= d.values[p] && d.values[p] <= extents[i][1]) && !isNaN(parseFloat(d.values[p]));
                      });
                      if (isActive) active.push(d);
                      return isActive ? null : 'none';
                  });
                  
                  updateTicks();
                  
                  dispatch.brush({
                      filters: filters,
                      active: active
                  });
              }
              function brushend() {
                  var hasActiveBrush = actives.length > 0 ? true : false;
                  filters.forEach(function (f) {
                      if (f.extent[0] === y[f.dimension].brush.y().domain()[0] && axisWithUndefinedValues.indexOf(f.dimension) >= 0)
                          f.hasNaN = true;
                      if (f.extent[1] < y[f.dimension].domain()[0])
                          f.hasOnlyNaN = true;
                  });
                  dispatch.brushEnd(active, hasActiveBrush);
              }           
              function updateTicks() {
                  dimensions.select('.nv-axis')
                      .each(function (d, i) {
                          var f = filters.filter(function (k) { return k.dimension == d.key; });
                          currentTicks[d.key] = y[d.key].domain();
                          
                          //If brush are available, display brush extent
                          if (f.length != 0 && displayBrush)
                          {
                              currentTicks[d.key] = [];
                              if (f[0].extent[1] > y[d.key].domain()[0]) 
                                  currentTicks[d.key] = [f[0].extent[1]];
                              if (f[0].extent[0] >= y[d.key].domain()[0])
                                  currentTicks[d.key].push(f[0].extent[0]);    
                          }
                              
                          d3.select(this).call(axis.scale(y[d.key]).tickFormat(d.format).tickValues(currentTicks[d.key]));
                  });
              }
              function dragStart(d) {
                  dragging[d.key] = this.parentNode.__origin__ = x(d.key);
                  background.attr("visibility", "hidden");
              }
              function dragMove(d) {
                  dragging[d.key] = Math.min(availableWidth, Math.max(0, this.parentNode.__origin__ += d3.event.x));
                  foreground.attr("d", path);
                  enabledDimensions.sort(function (a, b) { return dimensionPosition(a.key) - dimensionPosition(b.key); });
                  enabledDimensions.forEach(function (d, i) { return d.currentPosition = i; });
                  x.domain(enabledDimensions.map(function (d) { return d.key; }));
                  dimensions.attr("transform", function(d) { return "translate(" + dimensionPosition(d.key) + ")"; });
              }
              function dragEnd(d, i) {
                  delete this.parentNode.__origin__;
                  delete dragging[d.key];
                  d3.select(this.parentNode).attr("transform", "translate(" + x(d.key) + ")");
                  foreground
                    .attr("d", path);
                  background
                    .attr("d", path)
                    .attr("visibility", null);
  
                  dispatch.dimensionsOrder(enabledDimensions);
              }
              function dimensionPosition(d) {
                  var v = dragging[d];
                  return v == null ? x(d) : v;
              }
          });
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:         {get: function(){return width;},           set: function(_){width= _;}},
          height:        {get: function(){return height;},          set: function(_){height= _;}},
          dimensionData: { get: function () { return dimensionData; }, set: function (_) { dimensionData = _; } },
          displayBrush: { get: function () { return displayBrush; }, set: function (_) { displayBrush = _; } },
          filters: { get: function () { return filters; }, set: function (_) { filters = _; } },
          active: { get: function () { return active; }, set: function (_) { active = _; } },
          lineTension:   {get: function(){return lineTension;},     set: function(_){lineTension = _;}},
          undefinedValuesLabel : {get: function(){return undefinedValuesLabel;}, set: function(_){undefinedValuesLabel=_;}},
          
          // deprecated options
          dimensions: {get: function () { return dimensionData.map(function (d){return d.key}); }, set: function (_) {
              // deprecated after 1.8.1
              nv.deprecated('dimensions', 'use dimensionData instead');
              if (dimensionData.length === 0) {
                  _.forEach(function (k) { dimensionData.push({ key: k }) })
              } else {
                  _.forEach(function (k, i) { dimensionData[i].key= k })
              }
          }},
          dimensionNames: {get: function () { return dimensionData.map(function (d){return d.key}); }, set: function (_) {
              // deprecated after 1.8.1
              nv.deprecated('dimensionNames', 'use dimensionData instead');
              dimensionNames = [];
              if (dimensionData.length === 0) {
                  _.forEach(function (k) { dimensionData.push({ key: k }) })
              } else {
                  _.forEach(function (k, i) { dimensionData[i].key = k })
              }
   
          }},
          dimensionFormats: {get: function () { return dimensionData.map(function (d) { return d.format }); }, set: function (_) {
              // deprecated after 1.8.1
              nv.deprecated('dimensionFormats', 'use dimensionData instead');
              if (dimensionData.length === 0) {
                  _.forEach(function (f) { dimensionData.push({ format: f }) })
              } else {
                  _.forEach(function (f, i) { dimensionData[i].format = f })
              }
  
          }},
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    =  _.top    !== undefined ? _.top    : margin.top;
              margin.right  =  _.right  !== undefined ? _.right  : margin.right;
              margin.bottom =  _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   =  _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }}
      });
      nv.utils.initOptions(chart);
      return chart;
  };
  nv.models.parallelCoordinatesChart = function () {
          "use strict";
          //============================================================
          // Public Variables with Default Settings
          //------------------------------------------------------------
  
          var parallelCoordinates = nv.models.parallelCoordinates()
          var legend = nv.models.legend()
          var tooltip = nv.models.tooltip();
          var dimensionTooltip = nv.models.tooltip();
  
          var margin = { top: 0, right: 0, bottom: 0, left: 0 }
          , marginTop = null
          , width = null
          , height = null
          , showLegend = true
          , color = nv.utils.defaultColor()
          , state = nv.utils.state()
          , dimensionData = []
          , displayBrush = true
          , defaultState = null
          , noData = null
          , nanValue = "undefined"
          , dispatch = d3.dispatch('dimensionsOrder', 'brushEnd', 'stateChange', 'changeState', 'renderEnd')
          , controlWidth = function () { return showControls ? 180 : 0 }
          ;
  
        //============================================================
  
      //============================================================
          // Private Variables
          //------------------------------------------------------------
  
          var renderWatch = nv.utils.renderWatch(dispatch);
  
          var stateGetter = function(data) {
              return function() {
                  return {
                      active: data.map(function(d) { return !d.disabled })
                  };
              }
          };
  
          var stateSetter = function(data) {
              return function(state) {
                  if(state.active !== undefined) {
                      data.forEach(function(series, i) {
                          series.disabled = !state.active[i];
                      });
                  }
              }
          };
  
          tooltip.contentGenerator(function(data) {
              var str = '<table><thead><tr><td class="legend-color-guide"><div style="background-color:' + data.color + '"></div></td><td><strong>' + data.key + '</strong></td></tr></thead>';
              if(data.series.length !== 0)
              {
                  str = str + '<tbody><tr><td height ="10px"></td></tr>';
                  data.series.forEach(function(d){
                      str = str + '<tr><td class="legend-color-guide"><div style="background-color:' + d.color + '"></div></td><td class="key">' + d.key + '</td><td class="value">' + d.value + '</td></tr>';
                  });
                  str = str + '</tbody>';
              }
              str = str + '</table>';
              return str;
          });
  
          //============================================================
          // Chart function
          //------------------------------------------------------------
  
          function chart(selection) {
              renderWatch.reset();
              renderWatch.models(parallelCoordinates);
  
              selection.each(function(data) {
                  var container = d3.select(this);
                  nv.utils.initSVG(container);
  
                  var that = this;
  
                  var availableWidth = nv.utils.availableWidth(width, container, margin),
                      availableHeight = nv.utils.availableHeight(height, container, margin);
  
                  chart.update = function() { container.call(chart); };
                  chart.container = this;
  
                  state.setter(stateSetter(dimensionData), chart.update)
                      .getter(stateGetter(dimensionData))
                      .update();
  
                  //set state.disabled
                  state.disabled = dimensionData.map(function (d) { return !!d.disabled });
  
                  //Keep dimensions position in memory
                  dimensionData = dimensionData.map(function (d) {d.disabled = !!d.disabled; return d});
                  dimensionData.forEach(function (d, i) {
                      d.originalPosition = isNaN(d.originalPosition) ? i : d.originalPosition;
                      d.currentPosition = isNaN(d.currentPosition) ? i : d.currentPosition;
                  });
  
                 if (!defaultState) {
                      var key;
                      defaultState = {};
                      for(key in state) {
                          if(state[key] instanceof Array)
                              defaultState[key] = state[key].slice(0);
                          else
                              defaultState[key] = state[key];
                      }
                  }
  
                  // Display No Data message if there's nothing to show.
                  if(!data || !data.length) {
                      nv.utils.noData(chart, container);
                      return chart;
                  } else {
                      container.selectAll('.nv-noData').remove();
                  }
  
                  //------------------------------------------------------------
                  // Setup containers and skeleton of chart
  
                  var wrap = container.selectAll('g.nv-wrap.nv-parallelCoordinatesChart').data([data]);
                  var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-parallelCoordinatesChart').append('g');
  
                  var g = wrap.select('g');
  
                  gEnter.append('g').attr('class', 'nv-parallelCoordinatesWrap');
                  gEnter.append('g').attr('class', 'nv-legendWrap');
  
                  g.select("rect")
                      .attr("width", availableWidth)
                      .attr("height", (availableHeight > 0) ? availableHeight : 0);
  
                  // Legend
                  if (!showLegend) {
                      g.select('.nv-legendWrap').selectAll('*').remove();
                  } else {
                      legend.width(availableWidth)
                          .color(function (d) { return "rgb(188,190,192)"; });
  
                      g.select('.nv-legendWrap')
                          .datum(dimensionData.sort(function (a, b) { return a.originalPosition - b.originalPosition; }))
                          .call(legend);
  
                      if (!marginTop && legend.height() !== margin.top) {
                          margin.top = legend.height();
                          availableHeight = nv.utils.availableHeight(height, container, margin);
                      }
                      wrap.select('.nv-legendWrap')
                         .attr('transform', 'translate( 0 ,' + (-margin.top) + ')');
                  }
                  wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
                  // Main Chart Component(s)
                  parallelCoordinates
                      .width(availableWidth)
                      .height(availableHeight)
                      .dimensionData(dimensionData)
                      .displayBrush(displayBrush);
  
              var parallelCoordinatesWrap = g.select('.nv-parallelCoordinatesWrap ')
                    .datum(data);
  
              parallelCoordinatesWrap.transition().call(parallelCoordinates);
  
          //============================================================
                  // Event Handling/Dispatching (in chart's scope)
                  //------------------------------------------------------------
                  //Display reset brush button
              parallelCoordinates.dispatch.on('brushEnd', function (active, hasActiveBrush) {
                  if (hasActiveBrush) {
                      displayBrush = true;
                      dispatch.brushEnd(active);
                  } else {
  
                      displayBrush = false;
                  }
              });
  
              legend.dispatch.on('stateChange', function(newState) {
                  for(var key in newState) {
                      state[key] = newState[key];
                  }
                  dispatch.stateChange(state);
                  chart.update();
              });
  
                  //Update dimensions order and display reset sorting button
              parallelCoordinates.dispatch.on('dimensionsOrder', function (e) {
                  dimensionData.sort(function (a, b) { return a.currentPosition - b.currentPosition; });
                  var isSorted = false;
                  dimensionData.forEach(function (d, i) {
                      d.currentPosition = i;
                      if (d.currentPosition !== d.originalPosition)
                          isSorted = true;
                  });
                  dispatch.dimensionsOrder(dimensionData, isSorted);
              });
  
          // Update chart from a state object passed to event handler
                  dispatch.on('changeState', function (e) {
  
                      if (typeof e.disabled !== 'undefined') {
                          dimensionData.forEach(function (series, i) {
                              series.disabled = e.disabled[i];
                          });
                          state.disabled = e.disabled;
                      }
                      chart.update();
                  });
              });
  
              renderWatch.renderEnd('parraleleCoordinateChart immediate');
              return chart;
          }
  
      //============================================================
          // Event Handling/Dispatching (out of chart's scope)
          //------------------------------------------------------------
  
          parallelCoordinates.dispatch.on('elementMouseover.tooltip', function (evt) {
              var tp = {
                  key: evt.label,
                  color: evt.color,
                  series: []
               }
              if(evt.values){
                  Object.keys(evt.values).forEach(function (d) {
                      var dim = evt.dimensions.filter(function (dd) {return dd.key === d;})[0];
                      if(dim){
                          var v;
                          if (isNaN(evt.values[d]) || isNaN(parseFloat(evt.values[d]))) {
                              v = nanValue;
                          } else {
                              v = dim.format(evt.values[d]);
                          }
                          tp.series.push({ idx: dim.currentPosition, key: d, value: v, color: dim.color });
                      }
                  });
                  tp.series.sort(function(a,b) {return a.idx - b.idx});
               }
              tooltip.data(tp).hidden(false);
          });
  
          parallelCoordinates.dispatch.on('elementMouseout.tooltip', function(evt) {
              tooltip.hidden(true)
          });
  
          parallelCoordinates.dispatch.on('elementMousemove.tooltip', function () {
              tooltip();
          });
       //============================================================
          // Expose Public Variables
          //------------------------------------------------------------
  
      // expose chart's sub-components
          chart.dispatch = dispatch;
          chart.parallelCoordinates = parallelCoordinates;
          chart.legend = legend;
          chart.tooltip = tooltip;
          chart.options = nv.utils.optionsFunc.bind(chart);
  
          chart._options = Object.create({}, {
              // simple options, just get/set the necessary values
              width: { get: function () { return width; }, set: function (_) { width = _; } },
              height: { get: function () { return height; }, set: function (_) { height = _; } },
              showLegend: { get: function () { return showLegend; }, set: function (_) { showLegend = _; } },
              defaultState: { get: function () { return defaultState; }, set: function (_) { defaultState = _; } },
              dimensionData: { get: function () { return dimensionData; }, set: function (_) { dimensionData = _; } },
              displayBrush: { get: function () { return displayBrush; }, set: function (_) { displayBrush = _; } },
              noData: { get: function () { return noData; }, set: function (_) { noData = _; } },
              nanValue: { get: function () { return nanValue; }, set: function (_) { nanValue = _; } },
  
              // options that require extra logic in the setter
              margin: {
                  get: function () { return margin; },
                  set: function (_) {
                      if (_.top !== undefined) {
                          margin.top = _.top;
                          marginTop = _.top;
                      }
                      margin.right = _.right !== undefined ? _.right : margin.right;
                      margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
                      margin.left = _.left !== undefined ? _.left : margin.left;
                  }
              },
              color: {get: function(){return color;}, set: function(_){
                      color = nv.utils.getColor(_);
                      legend.color(color);
                      parallelCoordinates.color(color);
                  }}
          });
  
          nv.utils.inheritOptions(chart, parallelCoordinates);
          nv.utils.initOptions(chart);
  
          return chart;
      };
  nv.models.pie = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 500
          , height = 500
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container = null
          , color = nv.utils.defaultColor()
          , valueFormat = d3.format(',.2f')
          , showLabels = true
          , labelsOutside = false
          , labelType = "key"
          , labelThreshold = .02 //if slice percentage is under this, don't show label
          , hideOverlapLabels = false //Hide labels that don't fit in slice
          , donut = false
          , title = false
          , growOnHover = true
          , titleOffset = 0
          , labelSunbeamLayout = false
          , startAngle = false
          , padAngle = false
          , endAngle = false
          , cornerRadius = 0
          , donutRatio = 0.5
          , duration = 250
          , arcsRadius = []
          , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')
          ;
  
      var arcs = [];
      var arcsOver = [];
  
      //============================================================
      // chart function
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right
                  , availableHeight = height - margin.top - margin.bottom
                  , radius = Math.min(availableWidth, availableHeight) / 2
                  , arcsRadiusOuter = []
                  , arcsRadiusInner = []
                  ;
  
              container = d3.select(this)
              if (arcsRadius.length === 0) {
                  var outer = radius - radius / 10;
                  var inner = donutRatio * radius;
                  for (var i = 0; i < data[0].length; i++) {
                      arcsRadiusOuter.push(outer);
                      arcsRadiusInner.push(inner);
                  }
              } else {
                  if(growOnHover){
                      arcsRadiusOuter = arcsRadius.map(function (d) { return (d.outer - d.outer / 10) * radius; });
                      arcsRadiusInner = arcsRadius.map(function (d) { return (d.inner - d.inner / 10) * radius; });
                      donutRatio = d3.min(arcsRadius.map(function (d) { return (d.inner - d.inner / 10); }));
                  } else {
                      arcsRadiusOuter = arcsRadius.map(function (d) { return d.outer * radius; });
                      arcsRadiusInner = arcsRadius.map(function (d) { return d.inner * radius; });
                      donutRatio = d3.min(arcsRadius.map(function (d) { return d.inner; }));
                  }
              }
              nv.utils.initSVG(container);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('.nv-wrap.nv-pie').data(data);
              var wrapEnter = wrap.enter().append('g').attr('class','nvd3 nv-wrap nv-pie nv-chart-' + id);
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
              var g_pie = gEnter.append('g').attr('class', 'nv-pie');
              gEnter.append('g').attr('class', 'nv-pieLabels');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
              g.select('.nv-pie').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');
              g.select('.nv-pieLabels').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');
  
              //
              container.on('click', function(d,i) {
                  dispatch.chartClick({
                      data: d,
                      index: i,
                      pos: d3.event,
                      id: id
                  });
              });
  
              arcs = [];
              arcsOver = [];
              for (var i = 0; i < data[0].length; i++) {
  
                  var arc = d3.svg.arc().outerRadius(arcsRadiusOuter[i]);
                  var arcOver = d3.svg.arc().outerRadius(arcsRadiusOuter[i] + 5);
  
                  if (startAngle !== false) {
                      arc.startAngle(startAngle);
                      arcOver.startAngle(startAngle);
                  }
                  if (endAngle !== false) {
                      arc.endAngle(endAngle);
                      arcOver.endAngle(endAngle);
                  }
                  if (donut) {
                      arc.innerRadius(arcsRadiusInner[i]);
                      arcOver.innerRadius(arcsRadiusInner[i]);
                  }
  
                  if (arc.cornerRadius && cornerRadius) {
                      arc.cornerRadius(cornerRadius);
                      arcOver.cornerRadius(cornerRadius);
                  }
  
                  arcs.push(arc);
                  arcsOver.push(arcOver);
              }
  
              // Setup the Pie chart and choose the data element
              var pie = d3.layout.pie()
                  .sort(null)
                  .value(function(d) { return d.disabled ? 0 : getY(d) });
  
              // padAngle added in d3 3.5
              if (pie.padAngle && padAngle) {
                  pie.padAngle(padAngle);
              }
  
              // if title is specified and donut, put it in the middle
              if (donut && title) {
                  g_pie.append("text").attr('class', 'nv-pie-title');
  
                  wrap.select('.nv-pie-title')
                      .style("text-anchor", "middle")
                      .text(function (d) {
                          return title;
                      })
                      .style("font-size", (Math.min(availableWidth, availableHeight)) * donutRatio * 2 / (title.length + 2) + "px")
                      .attr("dy", "0.35em") // trick to vertically center text
                      .attr('transform', function(d, i) {
                          return 'translate(0, '+ titleOffset + ')';
                      });
              }
  
              var slices = wrap.select('.nv-pie').selectAll('.nv-slice').data(pie);
              var pieLabels = wrap.select('.nv-pieLabels').selectAll('.nv-label').data(pie);
  
              slices.exit().remove();
              pieLabels.exit().remove();
  
              var ae = slices.enter().append('g');
              ae.attr('class', 'nv-slice');
              ae.on('mouseover', function(d, i) {
                  d3.select(this).classed('hover', true);
                  if (growOnHover) {
                      d3.select(this).select("path").transition()
                          .duration(70)
                          .attr("d", arcsOver[i]);
                  }
                  dispatch.elementMouseover({
                      data: d.data,
                      index: i,
                      color: d3.select(this).style("fill"),
                      percent: (d.endAngle - d.startAngle) / (2 * Math.PI)
                  });
              });
              ae.on('mouseout', function(d, i) {
                  d3.select(this).classed('hover', false);
                  if (growOnHover) {
                      d3.select(this).select("path").transition()
                          .duration(50)
                          .attr("d", arcs[i]);
                  }
                  dispatch.elementMouseout({data: d.data, index: i});
              });
              ae.on('mousemove', function(d, i) {
                  dispatch.elementMousemove({data: d.data, index: i});
              });
              ae.on('click', function(d, i) {
                  var element = this;
                  dispatch.elementClick({
                      data: d.data,
                      index: i,
                      color: d3.select(this).style("fill"),
                      event: d3.event,
                      element: element
                  });
              });
              ae.on('dblclick', function(d, i) {
                  dispatch.elementDblClick({
                      data: d.data,
                      index: i,
                      color: d3.select(this).style("fill")
                  });
              });
  
              slices.attr('fill', function(d,i) { return color(d.data, i); });
              slices.attr('stroke', function(d,i) { return color(d.data, i); });
  
              var paths = ae.append('path').each(function(d) {
                  this._current = d;
              });
  
              slices.select('path')
                  .transition()
                  .duration(duration)
                  .attr('d', function (d, i) { return arcs[i](d); })
                  .attrTween('d', arcTween);
  
              if (showLabels) {
                  // This does the normal label
                  var labelsArc = [];
                  for (var i = 0; i < data[0].length; i++) {
                      labelsArc.push(arcs[i]);
  
                      if (labelsOutside) {
                          if (donut) {
                              labelsArc[i] = d3.svg.arc().outerRadius(arcs[i].outerRadius());
                              if (startAngle !== false) labelsArc[i].startAngle(startAngle);
                              if (endAngle !== false) labelsArc[i].endAngle(endAngle);
                          }
                      } else if (!donut) {
                              labelsArc[i].innerRadius(0);
                      }
                  }
  
                  pieLabels.enter().append("g").classed("nv-label",true).each(function(d,i) {
                      var group = d3.select(this);
  
                      group.attr('transform', function (d, i) {
                          if (labelSunbeamLayout) {
                              d.outerRadius = arcsRadiusOuter[i] + 10; // Set Outer Coordinate
                              d.innerRadius = arcsRadiusOuter[i] + 15; // Set Inner Coordinate
                              var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                              if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                                  rotateAngle -= 90;
                              } else {
                                  rotateAngle += 90;
                              }
                              return 'translate(' + labelsArc[i].centroid(d) + ') rotate(' + rotateAngle + ')';
                          } else {
                              d.outerRadius = radius + 10; // Set Outer Coordinate
                              d.innerRadius = radius + 15; // Set Inner Coordinate
                              return 'translate(' + labelsArc[i].centroid(d) + ')'
                          }
                      });
  
                      group.append('rect')
                          .style('stroke', '#fff')
                          .style('fill', '#fff')
                          .attr("rx", 3)
                          .attr("ry", 3);
  
                      group.append('text')
                          .style('text-anchor', labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle') //center the text on it's origin or begin/end if orthogonal aligned
                          .style('fill', '#000')
                  });
  
                  var labelLocationHash = {};
                  var avgHeight = 14;
                  var avgWidth = 140;
                  var createHashKey = function(coordinates) {
                      return Math.floor(coordinates[0]/avgWidth) * avgWidth + ',' + Math.floor(coordinates[1]/avgHeight) * avgHeight;
                  };
                  var getSlicePercentage = function(d) {
                      return (d.endAngle - d.startAngle) / (2 * Math.PI);
                  };
  
                  pieLabels.watchTransition(renderWatch, 'pie labels').attr('transform', function (d, i) {
                      if (labelSunbeamLayout) {
                          d.outerRadius = arcsRadiusOuter[i] + 10; // Set Outer Coordinate
                          d.innerRadius = arcsRadiusOuter[i] + 15; // Set Inner Coordinate
                          var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                          if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                              rotateAngle -= 90;
                          } else {
                              rotateAngle += 90;
                          }
                          return 'translate(' + labelsArc[i].centroid(d) + ') rotate(' + rotateAngle + ')';
                      } else {
                          d.outerRadius = radius + 10; // Set Outer Coordinate
                          d.innerRadius = radius + 15; // Set Inner Coordinate
  
                          /*
                          Overlapping pie labels are not good. What this attempts to do is, prevent overlapping.
                          Each label location is hashed, and if a hash collision occurs, we assume an overlap.
                          Adjust the label's y-position to remove the overlap.
                          */
                          var center = labelsArc[i].centroid(d);
                          var percent = getSlicePercentage(d);
                          if (d.value && percent >= labelThreshold) {
                              var hashKey = createHashKey(center);
                              if (labelLocationHash[hashKey]) {
                                  center[1] -= avgHeight;
                              }
                              labelLocationHash[createHashKey(center)] = true;
                          }
                          return 'translate(' + center + ')'
                      }
                  });
  
                  pieLabels.select(".nv-label text")
                      .style('text-anchor', function(d,i) {
                          //center the text on it's origin or begin/end if orthogonal aligned
                          return labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle';
                      })
                      .text(function(d, i) {
                          var percent = getSlicePercentage(d);
                          var label = '';
                          if (!d.value || percent < labelThreshold) return '';
  
                          if(typeof labelType === 'function') {
                              label = labelType(d, i, {
                                  'key': getX(d.data),
                                  'value': getY(d.data),
                                  'percent': valueFormat(percent)
                              });
                          } else {
                              switch (labelType) {
                                  case 'key':
                                      label = getX(d.data);
                                      break;
                                  case 'value':
                                      label = valueFormat(getY(d.data));
                                      break;
                                  case 'percent':
                                      label = d3.format('%')(percent);
                                      break;
                              }
                          }
                          return label;
                      })
                  ;
  
                  if (hideOverlapLabels) {
                      pieLabels
                          .each(function (d, i) {
                              if (!this.getBBox) return;
                              var bb = this.getBBox(),
                              center = labelsArc[i].centroid(d);
                              var topLeft = {
                                x : center[0] + bb.x,
                                y : center[1] + bb.y
                              };
  
                              var topRight = {
                                x : topLeft.x + bb.width,
                                y : topLeft.y
                              };
  
                              var bottomLeft = {
                                x : topLeft.x,
                                y : topLeft.y + bb.height
                              };
  
                              var bottomRight = {
                                x : topLeft.x + bb.width,
                                y : topLeft.y + bb.height
                              };
  
                              d.visible = nv.utils.pointIsInArc(topLeft, d, arc) &&
                              nv.utils.pointIsInArc(topRight, d, arc) &&
                              nv.utils.pointIsInArc(bottomLeft, d, arc) &&
                              nv.utils.pointIsInArc(bottomRight, d, arc);
                          })
                          .style('display', function (d) {
                              return d.visible ? null : 'none';
                          })
                      ;
                  }
  
              }
  
  
              // Computes the angle of an arc, converting from radians to degrees.
              function angle(d) {
                  var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
                  return a > 90 ? a - 180 : a;
              }
  
              function arcTween(a, idx) {
                  a.endAngle = isNaN(a.endAngle) ? 0 : a.endAngle;
                  a.startAngle = isNaN(a.startAngle) ? 0 : a.startAngle;
                  if (!donut) a.innerRadius = 0;
                  var i = d3.interpolate(this._current, a);
                  this._current = i(0);
                  return function (t) {
                      return arcs[idx](i(t));
                  };
              }
          });
  
          renderWatch.renderEnd('pie immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          arcsRadius: { get: function () { return arcsRadius; }, set: function (_) { arcsRadius = _; } },
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLabels: {get: function(){return showLabels;}, set: function(_){showLabels=_;}},
          title:      {get: function(){return title;}, set: function(_){title=_;}},
          titleOffset:    {get: function(){return titleOffset;}, set: function(_){titleOffset=_;}},
          labelThreshold: {get: function(){return labelThreshold;}, set: function(_){labelThreshold=_;}},
          hideOverlapLabels: {get: function(){return hideOverlapLabels;}, set: function(_){hideOverlapLabels=_;}},
          valueFormat:    {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
          x:          {get: function(){return getX;}, set: function(_){getX=_;}},
          id:         {get: function(){return id;}, set: function(_){id=_;}},
          endAngle:   {get: function(){return endAngle;}, set: function(_){endAngle=_;}},
          startAngle: {get: function(){return startAngle;}, set: function(_){startAngle=_;}},
          padAngle:   {get: function(){return padAngle;}, set: function(_){padAngle=_;}},
          cornerRadius: {get: function(){return cornerRadius;}, set: function(_){cornerRadius=_;}},
          donutRatio:   {get: function(){return donutRatio;}, set: function(_){donutRatio=_;}},
          labelsOutside: {get: function(){return labelsOutside;}, set: function(_){labelsOutside=_;}},
          labelSunbeamLayout: {get: function(){return labelSunbeamLayout;}, set: function(_){labelSunbeamLayout=_;}},
          donut:              {get: function(){return donut;}, set: function(_){donut=_;}},
          growOnHover:        {get: function(){return growOnHover;}, set: function(_){growOnHover=_;}},
  
          // depreciated after 1.7.1
          pieLabelsOutside: {get: function(){return labelsOutside;}, set: function(_){
              labelsOutside=_;
              nv.deprecated('pieLabelsOutside', 'use labelsOutside instead');
          }},
          // depreciated after 1.7.1
          donutLabelsOutside: {get: function(){return labelsOutside;}, set: function(_){
              labelsOutside=_;
              nv.deprecated('donutLabelsOutside', 'use labelsOutside instead');
          }},
          // deprecated after 1.7.1
          labelFormat: {get: function(){ return valueFormat;}, set: function(_) {
              valueFormat=_;
              nv.deprecated('labelFormat','use valueFormat instead');
          }},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
              margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
              margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
              margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
          }},
          y: {get: function(){return getY;}, set: function(_){
              getY=d3.functor(_);
          }},
          color: {get: function(){return color;}, set: function(_){
              color=nv.utils.getColor(_);
          }},
          labelType:          {get: function(){return labelType;}, set: function(_){
              labelType= _ || 'key';
          }}
      });
  
      nv.utils.initOptions(chart);
      return chart;
  };
  nv.models.pieChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var pie = nv.models.pie();
      var legend = nv.models.legend();
      var tooltip = nv.models.tooltip();
  
      var margin = {top: 30, right: 20, bottom: 20, left: 20}
          , marginTop = null
          , width = null
          , height = null
          , showTooltipPercent = false
          , showLegend = true
          , legendPosition = "top"
          , color = nv.utils.defaultColor()
          , state = nv.utils.state()
          , defaultState = null
          , noData = null
          , duration = 250
          , dispatch = d3.dispatch('stateChange', 'changeState','renderEnd')
          ;
  
      tooltip
          .duration(0)
          .headerEnabled(false)
          .valueFormatter(function(d, i) {
              return pie.valueFormat()(d, i);
          });
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
  
      var stateGetter = function(data) {
          return function(){
              return {
                  active: data.map(function(d) { return !d.disabled })
              };
          }
      };
  
      var stateSetter = function(data) {
          return function(state) {
              if (state.active !== undefined) {
                  data.forEach(function (series, i) {
                      series.disabled = !state.active[i];
                  });
              }
          }
      };
  
      //============================================================
      // Chart function
      //------------------------------------------------------------
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(pie);
  
          selection.each(function(data) {
              var container = d3.select(this);
              nv.utils.initSVG(container);
  
              var that = this;
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() { container.transition().call(chart); };
              chart.container = this;
  
              state.setter(stateSetter(data), chart.update)
                  .getter(stateGetter(data))
                  .update();
  
              //set state.disabled
              state.disabled = data.map(function(d) { return !!d.disabled });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length) {
                  nv.utils.noData(chart, container);
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-pieWrap');
              gEnter.append('g').attr('class', 'nv-legendWrap');
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  if (legendPosition === "top") {
                      legend.width( availableWidth ).key(pie.x());
  
                      wrap.select('.nv-legendWrap')
                          .datum(data)
                          .call(legend);
  
                      if (!marginTop && legend.height() !== margin.top) {
                          margin.top = legend.height();
                          availableHeight = nv.utils.availableHeight(height, container, margin);
                      }
  
                      wrap.select('.nv-legendWrap')
                          .attr('transform', 'translate(0,' + (-margin.top) +')');
                  } else if (legendPosition === "right") {
                      var legendWidth = nv.models.legend().width();
                      if (availableWidth / 2 < legendWidth) {
                          legendWidth = (availableWidth / 2)
                      }
                      legend.height(availableHeight).key(pie.x());
                      legend.width(legendWidth);
                      availableWidth -= legend.width();
  
                      wrap.select('.nv-legendWrap')
                          .datum(data)
                          .call(legend)
                          .attr('transform', 'translate(' + (availableWidth) +',0)');
                  } else if (legendPosition === "bottom") {
                      legend.width( availableWidth ).key(pie.x());
                      wrap.select('.nv-legendWrap')
                          .datum(data)
                          .call(legend);
  
                      margin.bottom = legend.height();
                      availableHeight = nv.utils.availableHeight(height, container, margin);
                      wrap.select('.nv-legendWrap')
                          .attr('transform', 'translate(0,' + availableHeight +')');
                  }
              }
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              // Main Chart Component(s)
              pie.width(availableWidth).height(availableHeight);
              var pieWrap = g.select('.nv-pieWrap').datum([data]);
              d3.transition(pieWrap).call(pie);
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              legend.dispatch.on('stateChange', function(newState) {
                  for (var key in newState) {
                      state[key] = newState[key];
                  }
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              // Update chart from a state object passed to event handler
              dispatch.on('changeState', function(e) {
                  if (typeof e.disabled !== 'undefined') {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
                      state.disabled = e.disabled;
                  }
                  chart.update();
              });
          });
  
          renderWatch.renderEnd('pieChart immediate');
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      pie.dispatch.on('elementMouseover.tooltip', function(evt) {
          evt['series'] = {
              key: chart.x()(evt.data),
              value: chart.y()(evt.data),
              color: evt.color,
              percent: evt.percent
          };
          if (!showTooltipPercent) {
              delete evt.percent;
              delete evt.series.percent;
          }
          tooltip.data(evt).hidden(false);
      });
  
      pie.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      pie.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.legend = legend;
      chart.dispatch = dispatch;
      chart.pie = pie;
      chart.tooltip = tooltip;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      // use Object get/set functionality to map between vars and chart functions
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:              {get: function(){return width;},                set: function(_){width=_;}},
          height:             {get: function(){return height;},               set: function(_){height=_;}},
          noData:             {get: function(){return noData;},               set: function(_){noData=_;}},
          showTooltipPercent: {get: function(){return showTooltipPercent;},   set: function(_){showTooltipPercent=_;}},
          showLegend:         {get: function(){return showLegend;},           set: function(_){showLegend=_;}},
          legendPosition:     {get: function(){return legendPosition;},       set: function(_){legendPosition=_;}},
          defaultState:       {get: function(){return defaultState;},         set: function(_){defaultState=_;}},
  
          // options that require extra logic in the setter
          color: {get: function(){return color;}, set: function(_){
              color = _;
              legend.color(color);
              pie.color(color);
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              pie.duration(duration);
          }},
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }}
      });
      nv.utils.inheritOptions(chart, pie);
      nv.utils.initOptions(chart);
      return chart;
  };
  nv.models.sankey = function() {
      'use strict';
  
      // Sources:
      // - https://bost.ocks.org/mike/sankey/
      // - https://github.com/soxofaan/d3-plugin-captain-sankey
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var sankey = {},
          nodeWidth = 24,
          nodePadding = 8,
          size = [1, 1],
          nodes = [],
          links = [],
          sinksRight = true;
  
      var layout = function(iterations) {
          computeNodeLinks();
          computeNodeValues();
          computeNodeBreadths();
          computeNodeDepths(iterations);
      };
  
      var relayout = function() {
          computeLinkDepths();
      };
  
      // SVG path data generator, to be used as 'd' attribute on 'path' element selection.
      var link = function() {
          var curvature = .5;
  
          function link(d) {
  
              var x0 = d.source.x + d.source.dx,
                  x1 = d.target.x,
                  xi = d3.interpolateNumber(x0, x1),
                  x2 = xi(curvature),
                  x3 = xi(1 - curvature),
                  y0 = d.source.y + d.sy + d.dy / 2,
                  y1 = d.target.y + d.ty + d.dy / 2;
              var linkPath = 'M' + x0 + ',' + y0
                  + 'C' + x2 + ',' + y0
                  + ' ' + x3 + ',' + y1
                  + ' ' + x1 + ',' + y1;
              return linkPath;
          }
  
          link.curvature = function(_) {
              if (!arguments.length) return curvature;
              curvature = +_;
              return link;
          };
  
          return link;
      };
  
      // Y-position of the middle of a node.
      var center = function(node) {
          return node.y + node.dy / 2;
      };
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      // Populate the sourceLinks and targetLinks for each node.
      // Also, if the source and target are not objects, assume they are indices.
      function computeNodeLinks() {
          nodes.forEach(function(node) {
              // Links that have this node as source.
              node.sourceLinks = [];
              // Links that have this node as target.
              node.targetLinks = [];
          });
          links.forEach(function(link) {
              var source = link.source,
                  target = link.target;
              if (typeof source === 'number') source = link.source = nodes[link.source];
              if (typeof target === 'number') target = link.target = nodes[link.target];
              source.sourceLinks.push(link);
              target.targetLinks.push(link);
          });
      }
  
      // Compute the value (size) of each node by summing the associated links.
      function computeNodeValues() {
          nodes.forEach(function(node) {
              node.value = Math.max(
                  d3.sum(node.sourceLinks, value),
                  d3.sum(node.targetLinks, value)
              );
          });
      }
  
      // Iteratively assign the breadth (x-position) for each node.
      // Nodes are assigned the maximum breadth of incoming neighbors plus one;
      // nodes with no incoming links are assigned breadth zero, while
      // nodes with no outgoing links are assigned the maximum breadth.
      function computeNodeBreadths() {
          //
          var remainingNodes = nodes,
              nextNodes,
              x = 0;
  
          // Work from left to right.
          // Keep updating the breath (x-position) of nodes that are target of recently updated nodes.
          //
          while (remainingNodes.length && x < nodes.length) {
              nextNodes = [];
              remainingNodes.forEach(function(node) {
                  node.x = x;
                  node.dx = nodeWidth;
                  node.sourceLinks.forEach(function(link) {
                      if (nextNodes.indexOf(link.target) < 0) {
                          nextNodes.push(link.target);
                      }
                  });
              });
              remainingNodes = nextNodes;
              ++x;
              //
          }
  
          // Optionally move pure sinks always to the right.
          if (sinksRight) {
              moveSinksRight(x);
          }
  
          scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
      }
  
      function moveSourcesRight() {
          nodes.forEach(function(node) {
              if (!node.targetLinks.length) {
                  node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;
              }
          });
      }
  
      function moveSinksRight(x) {
          nodes.forEach(function(node) {
              if (!node.sourceLinks.length) {
                  node.x = x - 1;
              }
          });
      }
  
      function scaleNodeBreadths(kx) {
          nodes.forEach(function(node) {
              node.x *= kx;
          });
      }
  
      // Compute the depth (y-position) for each node.
      function computeNodeDepths(iterations) {
          // Group nodes by breath.
          var nodesByBreadth = d3.nest()
              .key(function(d) { return d.x; })
              .sortKeys(d3.ascending)
              .entries(nodes)
              .map(function(d) { return d.values; });
  
          //
          initializeNodeDepth();
          resolveCollisions();
          computeLinkDepths();
          for (var alpha = 1; iterations > 0; --iterations) {
              relaxRightToLeft(alpha *= .99);
              resolveCollisions();
              computeLinkDepths();
              relaxLeftToRight(alpha);
              resolveCollisions();
              computeLinkDepths();
          }
  
          function initializeNodeDepth() {
              // Calculate vertical scaling factor.
              var ky = d3.min(nodesByBreadth, function(nodes) {
                  return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
              });
  
              nodesByBreadth.forEach(function(nodes) {
                  nodes.forEach(function(node, i) {
                      node.y = i;
                      node.dy = node.value * ky;
                  });
              });
  
              links.forEach(function(link) {
                  link.dy = link.value * ky;
              });
          }
  
          function relaxLeftToRight(alpha) {
              nodesByBreadth.forEach(function(nodes, breadth) {
                  nodes.forEach(function(node) {
                      if (node.targetLinks.length) {
                          // Value-weighted average of the y-position of source node centers linked to this node.
                          var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
                          node.y += (y - center(node)) * alpha;
                      }
                  });
              });
  
              function weightedSource(link) {
                  return (link.source.y + link.sy + link.dy / 2) * link.value;
              }
          }
  
          function relaxRightToLeft(alpha) {
              nodesByBreadth.slice().reverse().forEach(function(nodes) {
                  nodes.forEach(function(node) {
                      if (node.sourceLinks.length) {
                          // Value-weighted average of the y-positions of target nodes linked to this node.
                          var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
                          node.y += (y - center(node)) * alpha;
                      }
                  });
              });
  
              function weightedTarget(link) {
                  return (link.target.y + link.ty + link.dy / 2) * link.value;
              }
          }
  
          function resolveCollisions() {
              nodesByBreadth.forEach(function(nodes) {
                  var node,
                      dy,
                      y0 = 0,
                      n = nodes.length,
                      i;
  
                  // Push any overlapping nodes down.
                  nodes.sort(ascendingDepth);
                  for (i = 0; i < n; ++i) {
                      node = nodes[i];
                      dy = y0 - node.y;
                      if (dy > 0) node.y += dy;
                      y0 = node.y + node.dy + nodePadding;
                  }
  
                  // If the bottommost node goes outside the bounds, push it back up.
                  dy = y0 - nodePadding - size[1];
                  if (dy > 0) {
                      y0 = node.y -= dy;
  
                      // Push any overlapping nodes back up.
                      for (i = n - 2; i >= 0; --i) {
                          node = nodes[i];
                          dy = node.y + node.dy + nodePadding - y0;
                          if (dy > 0) node.y -= dy;
                          y0 = node.y;
                      }
                  }
              });
          }
  
          function ascendingDepth(a, b) {
              return a.y - b.y;
          }
      }
  
      // Compute y-offset of the source endpoint (sy) and target endpoints (ty) of links,
      // relative to the source/target node's y-position.
      function computeLinkDepths() {
          nodes.forEach(function(node) {
              node.sourceLinks.sort(ascendingTargetDepth);
              node.targetLinks.sort(ascendingSourceDepth);
          });
          nodes.forEach(function(node) {
              var sy = 0, ty = 0;
              node.sourceLinks.forEach(function(link) {
                  link.sy = sy;
                  sy += link.dy;
              });
              node.targetLinks.forEach(function(link) {
                  link.ty = ty;
                  ty += link.dy;
              });
          });
  
          function ascendingSourceDepth(a, b) {
              return a.source.y - b.source.y;
          }
  
          function ascendingTargetDepth(a, b) {
              return a.target.y - b.target.y;
          }
      }
  
      // Value property accessor.
      function value(x) {
          return x.value;
      }
  
      sankey.options = nv.utils.optionsFunc.bind(sankey);
      sankey._options = Object.create({}, {
          nodeWidth:    {get: function(){return nodeWidth;},   set: function(_){nodeWidth=+_;}},
          nodePadding:  {get: function(){return nodePadding;}, set: function(_){nodePadding=_;}},
          nodes:        {get: function(){return nodes;},       set: function(_){nodes=_;}},
          links:        {get: function(){return links ;},      set: function(_){links=_;}},
          size:         {get: function(){return size;},        set: function(_){size=_;}},
          sinksRight:   {get: function(){return sinksRight;},  set: function(_){sinksRight=_;}},
  
          layout:       {get: function(){layout(32);},         set: function(_){layout(_);}},
          relayout:     {get: function(){relayout();},         set: function(_){}},
          center:       {get: function(){return center();},    set: function(_){
              if(typeof _ === 'function'){
                  center=_;
              }
          }},
          link:         {get: function(){return link();},      set: function(_){
              if(typeof _ === 'function'){
                  link=_;
              }
              return link();
          }}
      });
  
      nv.utils.initOptions(sankey);
  
      return sankey;
  };
  nv.models.sankeyChart = function() {
      "use strict";
  
      // Sources:
      // - https://bost.ocks.org/mike/sankey/
      // - https://github.com/soxofaan/d3-plugin-captain-sankey
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 5, right: 0, bottom: 5, left: 0}
          , sankey = nv.models.sankey()
          , width = 600
          , height = 400
          , nodeWidth = 36
          , nodePadding =  40
          , units = 'units'
          , center = undefined
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var formatNumber = d3.format(',.0f');    // zero decimal places
      var format = function(d) {
          return formatNumber(d) + ' ' + units;
      };
      var color = d3.scale.category20();
      var linkTitle = function(d){
          return d.source.name + ' → ' + d.target.name + '\n' + format(d.value);
      };
      var nodeFillColor = function(d){
          return d.color = color(d.name.replace(/ .*/, ''));
      };
      var nodeStrokeColor = function(d){
          return d3.rgb(d.color).darker(2);
      };
      var nodeTitle = function(d){
          return d.name + '\n' + format(d.value);
      };
  
      var showError = function(element, message) {
          element.append('text')
              .attr('x', 0)
              .attr('y', 0)
              .attr('class', 'nvd3-sankey-chart-error')
              .attr('text-anchor', 'middle')
              .text(message);
      };
  
      function chart(selection) {
          selection.each(function(data) {
  
              var testData = {
                  nodes:
                      [
                          {'node': 1, 'name': 'Test 1'},
                          {'node': 2, 'name': 'Test 2'},
                          {'node': 3, 'name': 'Test 3'},
                          {'node': 4, 'name': 'Test 4'},
                          {'node': 5, 'name': 'Test 5'},
                          {'node': 6, 'name': 'Test 6'}
                      ],
                  links:
                      [
                          {'source': 0, 'target': 1, 'value': 2295},
                          {'source': 0, 'target': 5, 'value': 1199},
                          {'source': 1, 'target': 2, 'value': 1119},
                          {'source': 1, 'target': 5, 'value': 1176},
                          {'source': 2, 'target': 3, 'value': 487},
                          {'source': 2, 'target': 5, 'value': 632},
                          {'source': 3, 'target': 4, 'value': 301},
                          {'source': 3, 'target': 5, 'value': 186}
                      ]
              };
  
              // Error handling
              var isDataValid = false;
              var dataAvailable = false;
  
              // check if data is valid
              if(
                  (typeof data['nodes'] === 'object' && data['nodes'].length) >= 0 &&
                  (typeof data['links'] === 'object' && data['links'].length) >= 0
              ){
                  isDataValid = true;
              }
  
              // check if data is available
              if(
                  data['nodes'] && data['nodes'].length > 0 &&
                  data['links'] && data['links'].length > 0
              ) {
                  dataAvailable = true;
              }
  
              // show error
              if(!isDataValid) {
                  console.error('NVD3 Sankey chart error:', 'invalid data format for', data);
                  console.info('Valid data format is: ', testData, JSON.stringify(testData));
                  showError(selection, 'Error loading chart, data is invalid');
                  return false;
              }
  
              // TODO use nv.utils.noData
              if(!dataAvailable) {
                  showError(selection, 'No data available');
                  return false;
              }
  
              // No errors, continue
  
              // append the svg canvas to the page
              var svg = selection.append('svg')
                  .attr('width', width)
                  .attr('height', height)
                  .append('g')
                  .attr('class', 'nvd3 nv-wrap nv-sankeyChart');
  
              // Set the sankey diagram properties
              sankey
                  .nodeWidth(nodeWidth)
                  .nodePadding(nodePadding)
                  .size([width, height]);
  
              var path = sankey.link();
  
              sankey
                  .nodes(data.nodes)
                  .links(data.links)
                  .layout(32)
                  .center(center);
  
              // add in the links
              var link = svg.append('g').selectAll('.link')
                  .data(data.links)
                  .enter().append('path')
                  .attr('class', 'link')
                  .attr('d', path)
                  .style('stroke-width', function(d) { return Math.max(1, d.dy); })
              .sort(function(a,b) { return b.dy - a.dy; });
  
              // add the link titles
              link.append('title')
                  .text(linkTitle);
  
              // add in the nodes
              var node = svg.append('g').selectAll('.node')
                  .data(data.nodes)
                  .enter().append('g')
                  .attr('class', 'node')
                  .attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
                  .call(
                      d3.behavior
                          .drag()
                          .origin(function(d) { return d; })
                          .on('dragstart', function() {
                              this.parentNode.appendChild(this);
                          })
                          .on('drag', dragmove)
                  );
  
              // add the rectangles for the nodes
              node.append('rect')
                  .attr('height', function(d) { return d.dy; })
                  .attr('width', sankey.nodeWidth())
                  .style('fill', nodeFillColor)
                  .style('stroke', nodeStrokeColor)
                  .append('title')
                  .text(nodeTitle);
  
              // add in the title for the nodes
              node.append('text')
                  .attr('x', -6)
                  .attr('y', function(d) { return d.dy / 2; })
                  .attr('dy', '.35em')
                  .attr('text-anchor', 'end')
                  .attr('transform', null)
                  .text(function(d) { return d.name; })
                  .filter(function(d) { return d.x < width / 2; })
                  .attr('x', 6 + sankey.nodeWidth())
                  .attr('text-anchor', 'start');
  
              // the function for moving the nodes
              function dragmove(d) {
                  d3.select(this).attr('transform',
                  'translate(' + d.x + ',' + (
                      d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
                  ) + ')');
                  sankey.relayout();
                  link.attr('d', path);
              }
          });
  
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          units:           {get: function(){return units;},       set: function(_){units=_;}},
          width:           {get: function(){return width;},       set: function(_){width=_;}},
          height:          {get: function(){return height;},      set: function(_){height=_;}},
          format:          {get: function(){return format;},      set: function(_){format=_;}},
          linkTitle:       {get: function(){return linkTitle;},   set: function(_){linkTitle=_;}},
          nodeWidth:       {get: function(){return nodeWidth;},   set: function(_){nodeWidth=_;}},
          nodePadding:     {get: function(){return nodePadding;}, set: function(_){nodePadding=_;}},
          center:          {get: function(){return center},       set: function(_){center=_}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          nodeStyle: {get: function(){return {};}, set: function(_){
              nodeFillColor   = _.fillColor   !== undefined ? _.fillColor   : nodeFillColor;
              nodeStrokeColor = _.strokeColor !== undefined ? _.strokeColor : nodeStrokeColor;
              nodeTitle       = _.title       !== undefined ? _.title       : nodeTitle;
          }}
  
      });
  
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.scatter = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin       = {top: 0, right: 0, bottom: 0, left: 0}
          , width        = null
          , height       = null
          , color        = nv.utils.defaultColor() // chooses color
          , pointBorderColor = null
          , id           = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't select one
          , container    = null
          , x            = d3.scale.linear()
          , y            = d3.scale.linear()
          , z            = d3.scale.linear() //linear because d3.svg.shape.size is treated as area
          , getX         = function(d) { return d.x } // accessor to get the x value
          , getY         = function(d) { return d.y } // accessor to get the y value
          , getSize      = function(d) { return d.size || 1} // accessor to get the point size
          , getShape     = function(d) { return d.shape || 'circle' } // accessor to get point shape
          , forceX       = [] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
          , forceY       = [] // List of numbers to Force into the Y scale
          , forceSize    = [] // List of numbers to Force into the Size scale
          , interactive  = true // If true, plots a voronoi overlay for advanced point intersection
          , pointActive  = function(d) { return !d.notActive } // any points that return false will be filtered out
          , padData      = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
          , padDataOuter = .1 //outerPadding to imitate ordinal scale outer padding
          , clipEdge     = false // if true, masks points within x and y scale
          , clipVoronoi  = true // if true, masks each point with a circle... can turn off to slightly increase performance
          , showVoronoi  = false // display the voronoi areas
          , clipRadius   = function() { return 25 } // function to get the radius for voronoi point clips
          , xDomain      = null // Override x domain (skips the calculation from data)
          , yDomain      = null // Override y domain
          , xRange       = null // Override x range
          , yRange       = null // Override y range
          , sizeDomain   = null // Override point size domain
          , sizeRange    = null
          , singlePoint  = false
          , dispatch     = d3.dispatch('elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
          , useVoronoi   = true
          , duration     = 250
          , interactiveUpdateDelay = 300
          , showLabels    = false
          ;
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var x0, y0, z0 // used to store previous scales
          , xDom, yDom // used to store previous domains
          , width0
          , height0
          , timeoutID
          , needsUpdate = false // Flag for when the points are visually updating, but the interactive layer is behind, to disable tooltips
          , renderWatch = nv.utils.renderWatch(dispatch, duration)
          , _sizeRange_def = [16, 256]
          , _cache = {}
          ;
  
      //============================================================
      // Diff and Cache Utilities
      //------------------------------------------------------------
      // getDiffs is used to filter unchanged points from the update
      // selection. It implicitly updates it's cache when called and
      // therefor the diff is based upon the previous invocation NOT
      // the previous update.
      //
      // getDiffs takes a point as its first argument followed by n
      // key getter pairs (d, [key, get... key, get]) this approach
      // was chosen for efficiency. (The filter will call it a LOT).
      //
      // It is important to call delCache on point exit to prevent a
      // memory leak. It is also needed to prevent invalid caches if
      // a new point uses the same series and point id key.
      //
      // Argument Performance Concerns:
      // - Object property lists for key getter pairs would be very
      // expensive (points * objects for the GC every update).
      // - ES6 function names for implicit keys would be nice but
      // they are not guaranteed to be unique.
      // - function.toString to obtain implicit keys is possible
      // but long object keys are not free (internal hash).
      // - Explicit key without objects are the most efficient.
  
      function getCache(d) {
          var key, val;
          key = d[0].series + ':' + d[1];
          val = _cache[key] = _cache[key] || {};
          return val;
      }
  
      function delCache(d) {
          var key, val;
          key = d[0].series + ':' + d[1];
          delete _cache[key];
      }
  
      function getDiffs(d) {
          var i, key, val,
              cache = getCache(d),
              diffs = false;
          for (i = 1; i < arguments.length; i += 2) {
              key = arguments[i];
              val = arguments[i + 1](d[0], d[1]);
              if (cache[key] !== val || !cache.hasOwnProperty(key)) {
                  cache[key] = val;
                  diffs = true;
              }
          }
          return diffs;
      }
  
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              container = d3.select(this);
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              nv.utils.initSVG(container);
  
              //add series index to each data point for reference
              data.forEach(function(series, i) {
                  series.values.forEach(function(point) {
                      point.series = i;
                  });
              });
  
              // Setup Scales
              var logScale = (typeof(chart.yScale().base) === "function"); // Only log scale has a method "base()"
              // remap and flatten the data for use in calculating the scales' domains
              var seriesData = (xDomain && yDomain && sizeDomain) ? [] : // if we know xDomain and yDomain and sizeDomain, no need to calculate.... if Size is constant remember to set sizeDomain to speed up performance
                  d3.merge(
                      data.map(function(d) {
                          return d.values.map(function(d,i) {
                              return { x: getX(d,i), y: getY(d,i), size: getSize(d,i) }
                          })
                      })
                  );
  
              x   .domain(xDomain || d3.extent(seriesData.map(function(d) { return d.x; }).concat(forceX)))
  
              if (padData && data[0])
                  x.range(xRange || [(availableWidth * padDataOuter +  availableWidth) / (2 *data[0].values.length), availableWidth - availableWidth * (1 + padDataOuter) / (2 * data[0].values.length)  ]);
              //x.range([availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
              else
                  x.range(xRange || [0, availableWidth]);
  
               if (logScale) {
                      var min = d3.min(seriesData.map(function(d) { if (d.y !== 0) return d.y; }));
                      y.clamp(true)
                          .domain(yDomain || d3.extent(seriesData.map(function(d) {
                              if (d.y !== 0) return d.y;
                              else return min * 0.1;
                          }).concat(forceY)))
                          .range(yRange || [availableHeight, 0]);
                  } else {
                          y.domain(yDomain || d3.extent(seriesData.map(function (d) { return d.y;}).concat(forceY)))
                          .range(yRange || [availableHeight, 0]);
                  }
  
              z   .domain(sizeDomain || d3.extent(seriesData.map(function(d) { return d.size }).concat(forceSize)))
                  .range(sizeRange || _sizeRange_def);
  
              // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
              singlePoint = x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1];
  
              if (x.domain()[0] === x.domain()[1])
                  x.domain()[0] ?
                      x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                      : x.domain([-1,1]);
  
              if (y.domain()[0] === y.domain()[1])
                  y.domain()[0] ?
                      y.domain([y.domain()[0] - y.domain()[0] * 0.01, y.domain()[1] + y.domain()[1] * 0.01])
                      : y.domain([-1,1]);
  
              if ( isNaN(x.domain()[0])) {
                  x.domain([-1,1]);
              }
  
              if ( isNaN(y.domain()[0])) {
                  y.domain([-1,1]);
              }
  
              x0 = x0 || x;
              y0 = y0 || y;
              z0 = z0 || z;
  
              var scaleDiff = x(1) !== x0(1) || y(1) !== y0(1) || z(1) !== z0(1);
  
              width0 = width0 || width;
              height0 = height0 || height;
  
              var sizeDiff = width0 !== width || height0 !== height;
  
              // Domain Diffs
  
              xDom = xDom || [];
              var domainDiff = xDom[0] !== x.domain()[0] || xDom[1] !== x.domain()[1];
              xDom = x.domain();
  
              yDom = yDom || [];
              domainDiff = domainDiff || yDom[0] !== y.domain()[0] || yDom[1] !== y.domain()[1];
              yDom = y.domain();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-scatter').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatter nv-chart-' + id);
              var defsEnter = wrapEnter.append('defs');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              wrap.classed('nv-single-point', singlePoint);
              gEnter.append('g').attr('class', 'nv-groups');
              gEnter.append('g').attr('class', 'nv-point-paths');
              wrapEnter.append('g').attr('class', 'nv-point-clips');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-edge-clip-' + id)
                  .append('rect')
                  .attr('transform', 'translate( -10, -10)');
  
              wrap.select('#nv-edge-clip-' + id + ' rect')
                  .attr('width', availableWidth + 20)
                  .attr('height', (availableHeight > 0) ? availableHeight + 20 : 0);
  
              g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');
  
              function updateInteractiveLayer() {
                  // Always clear needs-update flag regardless of whether or not
                  // we will actually do anything (avoids needless invocations).
                  needsUpdate = false;
  
                  if (!interactive) return false;
                  container.selectAll(".nv-point.hover").classed("hover", false);
  
                  // nuke all voronoi paths
                  wrap.select('.nv-point-paths').selectAll('path').remove();
  
                  // inject series and point index for reference into voronoi
                  if (useVoronoi === true) {
                      var vertices = d3.merge(data.map(function(group, groupIndex) {
                              return group.values
                                  .map(function(point, pointIndex) {
                                      // *Adding noise to make duplicates very unlikely
                                      // *Injecting series and point index for reference
                                      // *Adding a 'jitter' to the points, because there's an issue in d3.geom.voronoi.
                                      var pX = getX(point,pointIndex);
                                      var pY = getY(point,pointIndex);
  
                                      return [nv.utils.NaNtoZero(x(pX)) + Math.random() * 1e-4,
                                              nv.utils.NaNtoZero(y(pY)) + Math.random() * 1e-4,
                                          groupIndex,
                                          pointIndex, point];
                                  })
                                  .filter(function(pointArray, pointIndex) {
                                      return pointActive(pointArray[4], pointIndex); // Issue #237.. move filter to after map, so pointIndex is correct!
                                  })
                          })
                      );
  
                      if (vertices.length == 0) return false;  // No active points, we're done
                      if (vertices.length < 3) {
                          // Issue #283 - Adding 2 dummy points to the voronoi b/c voronoi requires min 3 points to work
                          vertices.push([x.range()[0] - 20, y.range()[0] - 20, null, null]);
                          vertices.push([x.range()[1] + 20, y.range()[1] + 20, null, null]);
                          vertices.push([x.range()[0] - 20, y.range()[0] + 20, null, null]);
                          vertices.push([x.range()[1] + 20, y.range()[1] - 20, null, null]);
                      }
  
                      // keep voronoi sections from going more than 10 outside of graph
                      // to avoid overlap with other things like legend etc
                      var bounds = d3.geom.polygon([
                          [-10,-10],
                          [-10,height + 10],
                          [width + 10,height + 10],
                          [width + 10,-10]
                      ]);
  
                      // delete duplicates from vertices - essential assumption for d3.geom.voronoi
                      var epsilon = 1e-4; // Uses 1e-4 to determine equivalence.
                      vertices = vertices.sort(function(a,b){return ((a[0] - b[0]) || (a[1] - b[1]))});
                      for (var i = 0; i < vertices.length - 1; ) {
                          if ((Math.abs(vertices[i][0] - vertices[i+1][0]) < epsilon) &&
                          (Math.abs(vertices[i][1] - vertices[i+1][1]) < epsilon)) {
                              vertices.splice(i+1, 1);
                          } else {
                              i++;
                          }
                      }
  
                      var voronoi = d3.geom.voronoi(vertices).map(function(d, i) {
                          if (d.length === 0) {
                              return null;
                          }
  
                          return {
                              'data': bounds.clip(d),
                              'series': vertices[i][2],
                              'point': vertices[i][3]
                          }
                      });
  
                      var pointPaths = wrap.select('.nv-point-paths').selectAll('path').data(voronoi);
                      var vPointPaths = pointPaths
                          .enter().append("svg:path")
                          .attr("d", function(d) {
                              if (!d || !d.data || d.data.length === 0)
                                  return 'M 0 0';
                              else
                                  return "M" + d.data.join(",") + "Z";
                          })
                          .attr("id", function(d,i) {
                              return "nv-path-"+i; })
                          .attr("clip-path", function(d,i) { return "url(#nv-clip-"+id+"-"+i+")"; })
                          ;
  
                      // good for debugging point hover issues
                      if (showVoronoi) {
                          vPointPaths.style("fill", d3.rgb(230, 230, 230))
                              .style('fill-opacity', 0.4)
                              .style('stroke-opacity', 1)
                              .style("stroke", d3.rgb(200,200,200));
                      }
  
                      if (clipVoronoi) {
                          // voronoi sections are already set to clip,
                          // just create the circles with the IDs they expect
                          wrap.select('.nv-point-clips').selectAll('*').remove(); // must do * since it has sub-dom
                          var pointClips = wrap.select('.nv-point-clips').selectAll('clipPath').data(vertices);
                          var vPointClips = pointClips
                              .enter().append("svg:clipPath")
                              .attr("id", function(d, i) { return "nv-clip-"+id+"-"+i;})
                              .append("svg:circle")
                              .attr('cx', function(d) { return d[0]; })
                              .attr('cy', function(d) { return d[1]; })
                              .attr('r', clipRadius);
                      }
  
                      var mouseEventCallback = function(el, d, mDispatch) {
                          if (needsUpdate) return 0;
                          var series = data[d.series];
                          if (series === undefined) return;
                          var point  = series.values[d.point];
                          point['color'] = color(series, d.series);
  
                          // standardize attributes for tooltip.
                          point['x'] = getX(point);
                          point['y'] = getY(point);
  
                          // can't just get box of event node since it's actually a voronoi polygon
                          var box = container.node().getBoundingClientRect();
                          var scrollTop  = window.pageYOffset || document.documentElement.scrollTop;
                          var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
  
                          var pos = {
                              left: x(getX(point, d.point)) + box.left + scrollLeft + margin.left + 10,
                              top: y(getY(point, d.point)) + box.top + scrollTop + margin.top + 10
                          };
  
                          mDispatch({
                              point: point,
                              series: series,
                              pos: pos,
                              relativePos: [x(getX(point, d.point)) + margin.left, y(getY(point, d.point)) + margin.top],
                              seriesIndex: d.series,
                              pointIndex: d.point,
                              event: d3.event,
                              element: el
                          });
                      };
  
                      pointPaths
                          .on('click', function(d) {
                              mouseEventCallback(this, d, dispatch.elementClick);
                          })
                          .on('dblclick', function(d) {
                              mouseEventCallback(this, d, dispatch.elementDblClick);
                          })
                          .on('mouseover', function(d) {
                              mouseEventCallback(this, d, dispatch.elementMouseover);
                          })
                          .on('mouseout', function(d, i) {
                              mouseEventCallback(this, d, dispatch.elementMouseout);
                          });
  
                  } else {
                      // add event handlers to points instead voronoi paths
                      wrap.select('.nv-groups').selectAll('.nv-group')
                          .selectAll('.nv-point')
                          //.data(dataWithPoints)
                          //.style('pointer-events', 'auto') // recativate events, disabled by css
                          .on('click', function(d,i) {
                              //nv.log('test', d, i);
                              if (needsUpdate || !data[d[0].series]) return 0; //check if this is a dummy point
                              var series = data[d[0].series],
                                  point  = series.values[i];
                              var element = this;
                              dispatch.elementClick({
                                  point: point,
                                  series: series,
                                  pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top], //TODO: make this pos base on the page
                                  relativePos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                                  seriesIndex: d[0].series,
                                  pointIndex: i,
                                  event: d3.event,
                                  element: element
                              });
                          })
                          .on('dblclick', function(d,i) {
                              if (needsUpdate || !data[d[0].series]) return 0; //check if this is a dummy point
                              var series = data[d[0].series],
                                  point  = series.values[i];
  
                              dispatch.elementDblClick({
                                  point: point,
                                  series: series,
                                  pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],//TODO: make this pos base on the page
                                  relativePos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                                  seriesIndex: d[0].series,
                                  pointIndex: i
                              });
                          })
                          .on('mouseover', function(d,i) {
                              if (needsUpdate || !data[d[0].series]) return 0; //check if this is a dummy point
                              var series = data[d[0].series],
                                  point  = series.values[i];
  
                              dispatch.elementMouseover({
                                  point: point,
                                  series: series,
                                  pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],//TODO: make this pos base on the page
                                  relativePos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                                  seriesIndex: d[0].series,
                                  pointIndex: i,
                                  color: color(d[0], i)
                              });
                          })
                          .on('mouseout', function(d,i) {
                              if (needsUpdate || !data[d[0].series]) return 0; //check if this is a dummy point
                              var series = data[d[0].series],
                                  point  = series.values[i];
  
                              dispatch.elementMouseout({
                                  point: point,
                                  series: series,
                                  pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],//TODO: make this pos base on the page
                                  relativePos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                                  seriesIndex: d[0].series,
                                  pointIndex: i,
                                  color: color(d[0], i)
                              });
                          });
                  }
              }
  
              needsUpdate = true;
              var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                  .data(function(d) { return d }, function(d) { return d.key });
              groups.enter().append('g')
                  .style('stroke-opacity', 1e-6)
                  .style('fill-opacity', 1e-6);
              groups.exit()
                  .remove();
              groups
                  .attr('class', function(d,i) {
                      return (d.classed || '') + ' nv-group nv-series-' + i;
                  })
                  .classed('nv-noninteractive', !interactive)
                  .classed('hover', function(d) { return d.hover });
              groups.watchTransition(renderWatch, 'scatter: groups')
                  .style('fill', function(d,i) { return color(d, i) })
                  .style('stroke', function(d,i) { return d.pointBorderColor || pointBorderColor || color(d, i) })
                  .style('stroke-opacity', 1)
                  .style('fill-opacity', .5);
  
              // create the points, maintaining their IDs from the original data set
              var points = groups.selectAll('path.nv-point')
                  .data(function(d) {
                      return d.values.map(
                          function (point, pointIndex) {
                              return [point, pointIndex]
                          }).filter(
                              function(pointArray, pointIndex) {
                                  return pointActive(pointArray[0], pointIndex)
                              })
                      });
              points.enter().append('path')
                  .attr('class', function (d) {
                      return 'nv-point nv-point-' + d[1];
                  })
                  .style('fill', function (d) { return d.color })
                  .style('stroke', function (d) { return d.color })
                  .attr('transform', function(d) {
                      return 'translate(' + nv.utils.NaNtoZero(x0(getX(d[0],d[1]))) + ',' + nv.utils.NaNtoZero(y0(getY(d[0],d[1]))) + ')'
                  })
                  .attr('d',
                      nv.utils.symbol()
                      .type(function(d) { return getShape(d[0]); })
                      .size(function(d) { return z(getSize(d[0],d[1])) })
              );
              points.exit().each(delCache).remove();
              groups.exit().selectAll('path.nv-point')
                  .watchTransition(renderWatch, 'scatter exit')
                  .attr('transform', function(d) {
                      return 'translate(' + nv.utils.NaNtoZero(x(getX(d[0],d[1]))) + ',' + nv.utils.NaNtoZero(y(getY(d[0],d[1]))) + ')'
                  })
                  .remove();
  
              //============================================================
              // Point Update Optimisation Notes
              //------------------------------------------------------------
              // The following update selections are filtered with getDiffs
              // (defined at the top of this file) this brings a performance
              // benefit for charts with large data sets that accumulate a
              // subset of changes or additions over time.
              //
              // Uneccesary and expensive DOM calls are avoided by culling
              // unchanged points from the selection in exchange for the
              // cheaper overhead of caching and diffing each point first.
              //
              // Due to the way D3 and NVD3 work, other global changes need
              // to be considered in addition to local point properties.
              // This is a potential source of bugs (if any of the global
              // changes that possibly affect points are missed).
  
              // Update Point Positions [x, y]
              points.filter(function (d) {
                  // getDiffs must always be called to update cache
                  return getDiffs(d, 'x', getX, 'y', getY) ||
                      scaleDiff || sizeDiff || domainDiff;
              })
              .watchTransition(renderWatch, 'scatter points')
              .attr('transform', function (d) {
                  return 'translate(' +
                      nv.utils.NaNtoZero(x(getX(d[0], d[1]))) + ',' +
                      nv.utils.NaNtoZero(y(getY(d[0], d[1]))) + ')'
              });
  
              // Update Point Appearance [shape, size]
              points.filter(function (d) {
                  // getDiffs must always be called to update cache
                  return getDiffs(d, 'shape', getShape, 'size', getSize) ||
                      scaleDiff || sizeDiff || domainDiff;
              })
              .watchTransition(renderWatch, 'scatter points')
              .attr('d', nv.utils.symbol()
                  .type(function (d) { return getShape(d[0]) })
                  .size(function (d) { return z(getSize(d[0], d[1])) })
              );
  
              // add label a label to scatter chart
              if(showLabels)
              {
                  var titles =  groups.selectAll('.nv-label')
                      .data(function(d) {
                          return d.values.map(
                              function (point, pointIndex) {
                                  return [point, pointIndex]
                              }).filter(
                                  function(pointArray, pointIndex) {
                                      return pointActive(pointArray[0], pointIndex)
                                  })
                          });
  
                  titles.enter().append('text')
                      .style('fill', function (d,i) {
                          return d.color })
                      .style('stroke-opacity', 0)
                      .style('fill-opacity', 1)
                      .attr('transform', function(d) {
                          var dx = nv.utils.NaNtoZero(x0(getX(d[0],d[1]))) + Math.sqrt(z(getSize(d[0],d[1]))/Math.PI) + 2;
                          return 'translate(' + dx + ',' + nv.utils.NaNtoZero(y0(getY(d[0],d[1]))) + ')';
                      })
                      .text(function(d,i){
                          return d[0].label;});
  
                  titles.exit().remove();
                  groups.exit().selectAll('path.nv-label')
                      .watchTransition(renderWatch, 'scatter exit')
                      .attr('transform', function(d) {
                          var dx = nv.utils.NaNtoZero(x(getX(d[0],d[1])))+ Math.sqrt(z(getSize(d[0],d[1]))/Math.PI)+2;
                          return 'translate(' + dx + ',' + nv.utils.NaNtoZero(y(getY(d[0],d[1]))) + ')';
                      })
                      .remove();
                 titles.each(function(d) {
                    d3.select(this)
                      .classed('nv-label', true)
                      .classed('nv-label-' + d[1], false)
                      .classed('hover',false);
                  });
                  titles.watchTransition(renderWatch, 'scatter labels')
                      .text(function(d,i){ 
                          return d[0].label;})
                      .attr('transform', function(d) {
                          var dx = nv.utils.NaNtoZero(x(getX(d[0],d[1])))+ Math.sqrt(z(getSize(d[0],d[1]))/Math.PI)+2;
                          return 'translate(' + dx + ',' + nv.utils.NaNtoZero(y(getY(d[0],d[1]))) + ')'
                      });
              }
  
              // Delay updating the invisible interactive layer for smoother animation
              if( interactiveUpdateDelay )
              {
                  clearTimeout(timeoutID); // stop repeat calls to updateInteractiveLayer
                  timeoutID = setTimeout(updateInteractiveLayer, interactiveUpdateDelay );
              }
              else
              {
                  updateInteractiveLayer();
              }
  
              //store old scales for use in transitions on update
              x0 = x.copy();
              y0 = y.copy();
              z0 = z.copy();
  
              width0 = width;
              height0 = height;
  
          });
          renderWatch.renderEnd('scatter immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      // utility function calls provided by this chart
      chart._calls = new function() {
          this.clearHighlights = function () {
              nv.dom.write(function() {
                  container.selectAll(".nv-point.hover").classed("hover", false);
              });
              return null;
          };
          this.highlightPoint = function (seriesIndex, pointIndex, isHoverOver) {
              nv.dom.write(function() {
                  container.select('.nv-groups')
                    .selectAll(".nv-series-" + seriesIndex)
                    .selectAll(".nv-point-" + pointIndex)
                    .classed("hover", isHoverOver);
              });
          };
      };
  
      // trigger calls from events too
      dispatch.on('elementMouseover.point', function(d) {
          if (interactive) chart._calls.highlightPoint(d.seriesIndex,d.pointIndex,true);
      });
  
      dispatch.on('elementMouseout.point', function(d) {
          if (interactive) chart._calls.highlightPoint(d.seriesIndex,d.pointIndex,false);
      });
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:        {get: function(){return width;}, set: function(_){width=_;}},
          height:       {get: function(){return height;}, set: function(_){height=_;}},
          xScale:       {get: function(){return x;}, set: function(_){x=_;}},
          yScale:       {get: function(){return y;}, set: function(_){y=_;}},
          pointScale:   {get: function(){return z;}, set: function(_){z=_;}},
          xDomain:      {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain:      {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          pointDomain:  {get: function(){return sizeDomain;}, set: function(_){sizeDomain=_;}},
          xRange:       {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:       {get: function(){return yRange;}, set: function(_){yRange=_;}},
          pointRange:   {get: function(){return sizeRange;}, set: function(_){sizeRange=_;}},
          forceX:       {get: function(){return forceX;}, set: function(_){forceX=_;}},
          forceY:       {get: function(){return forceY;}, set: function(_){forceY=_;}},
          forcePoint:   {get: function(){return forceSize;}, set: function(_){forceSize=_;}},
          interactive:  {get: function(){return interactive;}, set: function(_){interactive=_;}},
          pointActive:  {get: function(){return pointActive;}, set: function(_){pointActive=_;}},
          padDataOuter: {get: function(){return padDataOuter;}, set: function(_){padDataOuter=_;}},
          padData:      {get: function(){return padData;}, set: function(_){padData=_;}},
          clipEdge:     {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
          clipVoronoi:  {get: function(){return clipVoronoi;}, set: function(_){clipVoronoi=_;}},
          clipRadius:   {get: function(){return clipRadius;}, set: function(_){clipRadius=_;}},
          showVoronoi:   {get: function(){return showVoronoi;}, set: function(_){showVoronoi=_;}},
          id:           {get: function(){return id;}, set: function(_){id=_;}},
          interactiveUpdateDelay: {get:function(){return interactiveUpdateDelay;}, set: function(_){interactiveUpdateDelay=_;}},
          showLabels: {get: function(){return showLabels;}, set: function(_){ showLabels = _;}},
          pointBorderColor: {get: function(){return pointBorderColor;}, set: function(_){pointBorderColor=_;}},
  
          // simple functor options
          x:     {get: function(){return getX;}, set: function(_){getX = d3.functor(_);}},
          y:     {get: function(){return getY;}, set: function(_){getY = d3.functor(_);}},
          pointSize: {get: function(){return getSize;}, set: function(_){getSize = d3.functor(_);}},
          pointShape: {get: function(){return getShape;}, set: function(_){getShape = d3.functor(_);}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
          }},
          color: {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          useVoronoi: {get: function(){return useVoronoi;}, set: function(_){
              useVoronoi = _;
              if (useVoronoi === false) {
                  clipVoronoi = false;
              }
          }}
      });
  
      nv.utils.initOptions(chart);
      return chart;
  };
  
  nv.models.scatterChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var scatter      = nv.models.scatter()
          , xAxis        = nv.models.axis()
          , yAxis        = nv.models.axis()
          , legend       = nv.models.legend()
          , distX        = nv.models.distribution()
          , distY        = nv.models.distribution()
          , tooltip      = nv.models.tooltip()
          ;
  
      var margin       = {top: 30, right: 20, bottom: 50, left: 75}
          , marginTop = null
          , width        = null
          , height       = null
          , container    = null
          , color        = nv.utils.defaultColor()
          , x            = scatter.xScale()
          , y            = scatter.yScale()
          , showDistX    = false
          , showDistY    = false
          , showLegend   = true
          , showXAxis    = true
          , showYAxis    = true
          , rightAlignYAxis = false
          , state = nv.utils.state()
          , defaultState = null
          , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd')
          , noData       = null
          , duration = 250
          , showLabels    = false
          ;
  
      scatter.xScale(x).yScale(y);
      xAxis.orient('bottom').tickPadding(10);
      yAxis
          .orient((rightAlignYAxis) ? 'right' : 'left')
          .tickPadding(10)
      ;
      distX.axis('x');
      distY.axis('y');
      tooltip
          .headerFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          })
          .valueFormatter(function(d, i) {
              return yAxis.tickFormat()(d, i);
          });
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var x0, y0
          , renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      var stateGetter = function(data) {
          return function(){
              return {
                  active: data.map(function(d) { return !d.disabled })
              };
          }
      };
  
      var stateSetter = function(data) {
          return function(state) {
              if (state.active !== undefined)
                  data.forEach(function(series,i) {
                      series.disabled = !state.active[i];
                  });
          }
      };
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(scatter);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
          if (showDistX) renderWatch.models(distX);
          if (showDistY) renderWatch.models(distY);
  
          selection.each(function(data) {
              var that = this;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
  
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() {
                  if (duration === 0)
                      container.call(chart);
                  else
                      container.transition().duration(duration).call(chart);
              };
              chart.container = this;
  
              state
                  .setter(stateSetter(data), chart.update)
                  .getter(stateGetter(data))
                  .update();
  
              // DEPRECATED set state.disableddisabled
              state.disabled = data.map(function(d) { return !!d.disabled });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              // Display noData message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container);
                  renderWatch.renderEnd('scatter immediate');
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              // Setup Scales
              x = scatter.xScale();
              y = scatter.yScale();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              // background for pointer events
              gEnter.append('rect').attr('class', 'nvd3 nv-background').style("pointer-events","none");
  
              gEnter.append('g').attr('class', 'nv-x nv-axis');
              gEnter.append('g').attr('class', 'nv-y nv-axis');
              gEnter.append('g').attr('class', 'nv-scatterWrap');
              gEnter.append('g').attr('class', 'nv-regressionLinesWrap');
              gEnter.append('g').attr('class', 'nv-distWrap');
              gEnter.append('g').attr('class', 'nv-legendWrap');
  
              if (rightAlignYAxis) {
                  g.select(".nv-y.nv-axis")
                      .attr("transform", "translate(" + availableWidth + ",0)");
              }
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  var legendWidth = availableWidth;
                  legend.width(legendWidth);
  
                  wrap.select('.nv-legendWrap')
                      .datum(data)
                      .call(legend);
  
                  if (!marginTop && legend.height() !== margin.top) {
                      margin.top = legend.height();
                      availableHeight = nv.utils.availableHeight(height, container, margin);
                  }
  
                  wrap.select('.nv-legendWrap')
                      .attr('transform', 'translate(0' + ',' + (-margin.top) +')');
              }
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              // Main Chart Component(s)
              scatter
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(data.map(function(d,i) {
                      d.color = d.color || color(d, i);
                      return d.color;
                  }).filter(function(d,i) { return !data[i].disabled }))
                  .showLabels(showLabels);
  
              wrap.select('.nv-scatterWrap')
                  .datum(data.filter(function(d) { return !d.disabled }))
                  .call(scatter);
  
  
              wrap.select('.nv-regressionLinesWrap')
                  .attr('clip-path', 'url(#nv-edge-clip-' + scatter.id() + ')');
  
              var regWrap = wrap.select('.nv-regressionLinesWrap').selectAll('.nv-regLines')
                  .data(function (d) {
                      return d;
                  });
  
              regWrap.enter().append('g').attr('class', 'nv-regLines');
  
              var regLine = regWrap.selectAll('.nv-regLine')
                  .data(function (d) {
                      return [d]
                  });
  
              regLine.enter()
                  .append('line').attr('class', 'nv-regLine')
                  .style('stroke-opacity', 0);
  
              // don't add lines unless we have slope and intercept to use
              regLine.filter(function(d) {
                  return d.intercept && d.slope;
              })
                  .watchTransition(renderWatch, 'scatterPlusLineChart: regline')
                  .attr('x1', x.range()[0])
                  .attr('x2', x.range()[1])
                  .attr('y1', function (d, i) {
                      return y(x.domain()[0] * d.slope + d.intercept)
                  })
                  .attr('y2', function (d, i) {
                      return y(x.domain()[1] * d.slope + d.intercept)
                  })
                  .style('stroke', function (d, i, j) {
                      return color(d, j)
                  })
                  .style('stroke-opacity', function (d, i) {
                      return (d.disabled || typeof d.slope === 'undefined' || typeof d.intercept === 'undefined') ? 0 : 1
                  });
  
              // Setup Axes
              if (showXAxis) {
                  xAxis
                      .scale(x)
                      ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize( -availableHeight , 0);
  
                  g.select('.nv-x.nv-axis')
                      .attr('transform', 'translate(0,' + y.range()[0] + ')')
                      .call(xAxis);
              }
  
              if (showYAxis) {
                  yAxis
                      .scale(y)
                      ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                      .tickSize( -availableWidth, 0);
  
                  g.select('.nv-y.nv-axis')
                      .call(yAxis);
              }
  
              // Setup Distribution
              distX
                  .getData(scatter.x())
                  .scale(x)
                  .width(availableWidth)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled }));
              gEnter.select('.nv-distWrap').append('g')
                  .attr('class', 'nv-distributionX');
              g.select('.nv-distributionX')
                  .attr('transform', 'translate(0,' + y.range()[0] + ')')
                  .datum(data.filter(function(d) { return !d.disabled }))
                  .call(distX)
                  .style('opacity', function() { return showDistX ? '1' : '1e-6'; })
                  .watchTransition(renderWatch, 'scatterPlusLineChart')
                  .style('opacity', function() { return showDistX ? '1' : '1e-6'; })
  
  
              distY
                  .getData(scatter.y())
                  .scale(y)
                  .width(availableHeight)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled }));
              gEnter.select('.nv-distWrap').append('g')
                  .attr('class', 'nv-distributionY');
              g.select('.nv-distributionY')
                  .attr('transform', 'translate(' + (rightAlignYAxis ? availableWidth : -distY.size() ) + ',0)')
                  .datum(data.filter(function(d) { return !d.disabled }))
                  .call(distY)
                  .style('opacity', function() { return showDistY ? '1' : '1e-6'; })
                  .watchTransition(renderWatch, 'scatterPlusLineChart')
                  .style('opacity', function() { return showDistY ? '1' : '1e-6'; })
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              legend.dispatch.on('stateChange', function(newState) {
                  for (var key in newState)
                      state[key] = newState[key];
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              // Update chart from a state object passed to event handler
              dispatch.on('changeState', function(e) {
                  if (typeof e.disabled !== 'undefined') {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
                      state.disabled = e.disabled;
                  }
                  chart.update();
              });
  
              // mouseover needs availableHeight so we just keep scatter mouse events inside the chart block
              scatter.dispatch.on('elementMouseout.tooltip', function(evt) {
                  tooltip.hidden(true);
                  container.select('.nv-chart-' + scatter.id() + ' .nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex)
                      .attr('y1', 0);
                  container.select('.nv-chart-' + scatter.id() + ' .nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex)
                      .attr('x2', distY.size());
              });
  
              scatter.dispatch.on('elementMouseover.tooltip', function(evt) {
                  container.select('.nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex)
                      .attr('y1', evt.relativePos[1] - availableHeight);
                  container.select('.nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex)
                      .attr('x2', evt.relativePos[0] + distX.size());
                  tooltip.data(evt).hidden(false);
              });
  
              //store old scales for use in transitions on update
              x0 = x.copy();
              y0 = y.copy();
  
          });
  
          renderWatch.renderEnd('scatter with line immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.scatter = scatter;
      chart.legend = legend;
      chart.xAxis = xAxis;
      chart.yAxis = yAxis;
      chart.distX = distX;
      chart.distY = distY;
      chart.tooltip = tooltip;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          container:  {get: function(){return container;}, set: function(_){container=_;}},
          showDistX:  {get: function(){return showDistX;}, set: function(_){showDistX=_;}},
          showDistY:  {get: function(){return showDistY;}, set: function(_){showDistY=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          showXAxis:  {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis:  {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          defaultState:     {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
          noData:     {get: function(){return noData;}, set: function(_){noData=_;}},
          duration:   {get: function(){return duration;}, set: function(_){duration=_;}},
          showLabels: {get: function(){return showLabels;}, set: function(_){showLabels=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( (_) ? 'right' : 'left');
          }},
          color: {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              legend.color(color);
              distX.color(color);
              distY.color(color);
          }}
      });
  
      nv.utils.inheritOptions(chart, scatter);
      nv.utils.initOptions(chart);
      return chart;
  };
  
  nv.models.sparkline = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 2, right: 0, bottom: 2, left: 0}
          , width = 400
          , height = 32
          , container = null
          , animate = true
          , x = d3.scale.linear()
          , y = d3.scale.linear()
          , getX = function(d) { return d.x }
          , getY = function(d) { return d.y }
          , color = nv.utils.getColor(['#000'])
          , xDomain
          , yDomain
          , xRange
          , yRange
          , showMinMaxPoints = true
          , showCurrentPoint = true
          , dispatch = d3.dispatch('renderEnd')
          ;
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
      
      function chart(selection) {
          renderWatch.reset();
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right,
                  availableHeight = height - margin.top - margin.bottom;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
  
              // Setup Scales
              x   .domain(xDomain || d3.extent(data, getX ))
                  .range(xRange || [0, availableWidth]);
  
              y   .domain(yDomain || d3.extent(data, getY ))
                  .range(yRange || [availableHeight, 0]);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-sparkline').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparkline');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
  
              var paths = wrap.selectAll('path')
                  .data(function(d) { return [d] });
              paths.enter().append('path');
              paths.exit().remove();
              paths
                  .style('stroke', function(d,i) { return d.color || color(d, i) })
                  .attr('d', d3.svg.line()
                      .x(function(d,i) { return x(getX(d,i)) })
                      .y(function(d,i) { return y(getY(d,i)) })
              );
  
              // TODO: Add CURRENT data point (Need Min, Mac, Current / Most recent)
              var points = wrap.selectAll('circle.nv-point')
                  .data(function(data) {
                      var yValues = data.map(function(d, i) { return getY(d,i); });
                      function pointIndex(index) {
                          if (index != -1) {
                              var result = data[index];
                              result.pointIndex = index;
                              return result;
                          } else {
                              return null;
                          }
                      }
                      var maxPoint = pointIndex(yValues.lastIndexOf(y.domain()[1])),
                          minPoint = pointIndex(yValues.indexOf(y.domain()[0])),
                          currentPoint = pointIndex(yValues.length - 1);
                      return [(showMinMaxPoints ? minPoint : null), (showMinMaxPoints ? maxPoint : null), (showCurrentPoint ? currentPoint : null)].filter(function (d) {return d != null;});
                  });
              points.enter().append('circle');
              points.exit().remove();
              points
                  .attr('cx', function(d,i) { return x(getX(d,d.pointIndex)) })
                  .attr('cy', function(d,i) { return y(getY(d,d.pointIndex)) })
                  .attr('r', 2)
                  .attr('class', function(d,i) {
                      return getX(d, d.pointIndex) == x.domain()[1] ? 'nv-point nv-currentValue' :
                              getY(d, d.pointIndex) == y.domain()[0] ? 'nv-point nv-minValue' : 'nv-point nv-maxValue'
                  });
          });
          
          renderWatch.renderEnd('sparkline immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:            {get: function(){return width;}, set: function(_){width=_;}},
          height:           {get: function(){return height;}, set: function(_){height=_;}},
          xDomain:          {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
          yDomain:          {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
          xRange:           {get: function(){return xRange;}, set: function(_){xRange=_;}},
          yRange:           {get: function(){return yRange;}, set: function(_){yRange=_;}},
          xScale:           {get: function(){return x;}, set: function(_){x=_;}},
          yScale:           {get: function(){return y;}, set: function(_){y=_;}},
          animate:          {get: function(){return animate;}, set: function(_){animate=_;}},
          showMinMaxPoints: {get: function(){return showMinMaxPoints;}, set: function(_){showMinMaxPoints=_;}},
          showCurrentPoint: {get: function(){return showCurrentPoint;}, set: function(_){showCurrentPoint=_;}},
  
          //functor options
          x: {get: function(){return getX;}, set: function(_){getX=d3.functor(_);}},
          y: {get: function(){return getY;}, set: function(_){getY=d3.functor(_);}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }}
      });
  
      chart.dispatch = dispatch;
      nv.utils.initOptions(chart);
      return chart;
  };
  
  nv.models.sparklinePlus = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var sparkline = nv.models.sparkline();
  
      var margin = {top: 15, right: 100, bottom: 10, left: 50}
          , width = null
          , height = null
          , x
          , y
          , index = []
          , paused = false
          , xTickFormat = d3.format(',r')
          , yTickFormat = d3.format(',.2f')
          , showLastValue = true
          , alignValue = true
          , rightAlignValue = false
          , noData = null
          , dispatch = d3.dispatch('renderEnd')
          ;
          
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(sparkline);
          selection.each(function(data) {
              var container = d3.select(this);
              nv.utils.initSVG(container);
  
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() { container.call(chart); };
              chart.container = this;
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length) {
                  nv.utils.noData(chart, container)
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              var currentValue = sparkline.y()(data[data.length-1], data.length-1);
  
              // Setup Scales
              x = sparkline.xScale();
              y = sparkline.yScale();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-sparklineplus').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparklineplus');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-sparklineWrap');
              gEnter.append('g').attr('class', 'nv-valueWrap');
              gEnter.append('g').attr('class', 'nv-hoverArea');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              // Main Chart Component(s)
              var sparklineWrap = g.select('.nv-sparklineWrap');
  
              sparkline.width(availableWidth).height(availableHeight);
              sparklineWrap.call(sparkline);
  
              if (showLastValue) {
                  var valueWrap = g.select('.nv-valueWrap');
                  var value = valueWrap.selectAll('.nv-currentValue')
                      .data([currentValue]);
  
                  value.enter().append('text').attr('class', 'nv-currentValue')
                      .attr('dx', rightAlignValue ? -8 : 8)
                      .attr('dy', '.9em')
                      .style('text-anchor', rightAlignValue ? 'end' : 'start');
  
                  value
                      .attr('x', availableWidth + (rightAlignValue ? margin.right : 0))
                      .attr('y', alignValue ? function (d) {
                          return y(d)
                      } : 0)
                      .style('fill', sparkline.color()(data[data.length - 1], data.length - 1))
                      .text(yTickFormat(currentValue));
              }
  
              gEnter.select('.nv-hoverArea').append('rect')
                  .on('mousemove', sparklineHover)
                  .on('click', function() { paused = !paused })
                  .on('mouseout', function() { index = []; updateValueLine(); });
  
              g.select('.nv-hoverArea rect')
                  .attr('transform', function(d) { return 'translate(' + -margin.left + ',' + -margin.top + ')' })
                  .attr('width', availableWidth + margin.left + margin.right)
                  .attr('height', availableHeight + margin.top);
  
              //index is currently global (within the chart), may or may not keep it that way
              function updateValueLine() {
                  if (paused) return;
  
                  var hoverValue = g.selectAll('.nv-hoverValue').data(index);
  
                  var hoverEnter = hoverValue.enter()
                      .append('g').attr('class', 'nv-hoverValue')
                      .style('stroke-opacity', 0)
                      .style('fill-opacity', 0);
  
                  hoverValue.exit()
                      .transition().duration(250)
                      .style('stroke-opacity', 0)
                      .style('fill-opacity', 0)
                      .remove();
  
                  hoverValue
                      .attr('transform', function(d) { return 'translate(' + x(sparkline.x()(data[d],d)) + ',0)' })
                      .transition().duration(250)
                      .style('stroke-opacity', 1)
                      .style('fill-opacity', 1);
  
                  if (!index.length) return;
  
                  hoverEnter.append('line')
                      .attr('x1', 0)
                      .attr('y1', -margin.top)
                      .attr('x2', 0)
                      .attr('y2', availableHeight);
  
                  hoverEnter.append('text').attr('class', 'nv-xValue')
                      .attr('x', -6)
                      .attr('y', -margin.top)
                      .attr('text-anchor', 'end')
                      .attr('dy', '.9em');
  
                  g.select('.nv-hoverValue .nv-xValue')
                      .text(xTickFormat(sparkline.x()(data[index[0]], index[0])));
  
                  hoverEnter.append('text').attr('class', 'nv-yValue')
                      .attr('x', 6)
                      .attr('y', -margin.top)
                      .attr('text-anchor', 'start')
                      .attr('dy', '.9em');
  
                  g.select('.nv-hoverValue .nv-yValue')
                      .text(yTickFormat(sparkline.y()(data[index[0]], index[0])));
              }
  
              function sparklineHover() {
                  if (paused) return;
  
                  var pos = d3.mouse(this)[0] - margin.left;
  
                  function getClosestIndex(data, x) {
                      var distance = Math.abs(sparkline.x()(data[0], 0) - x);
                      var closestIndex = 0;
                      for (var i = 0; i < data.length; i++){
                          if (Math.abs(sparkline.x()(data[i], i) - x) < distance) {
                              distance = Math.abs(sparkline.x()(data[i], i) - x);
                              closestIndex = i;
                          }
                      }
                      return closestIndex;
                  }
  
                  index = [getClosestIndex(data, Math.round(x.invert(pos)))];
                  updateValueLine();
              }
  
          });
          renderWatch.renderEnd('sparklinePlus immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.sparkline = sparkline;
  
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:           {get: function(){return width;}, set: function(_){width=_;}},
          height:          {get: function(){return height;}, set: function(_){height=_;}},
          xTickFormat:     {get: function(){return xTickFormat;}, set: function(_){xTickFormat=_;}},
          yTickFormat:     {get: function(){return yTickFormat;}, set: function(_){yTickFormat=_;}},
          showLastValue:   {get: function(){return showLastValue;}, set: function(_){showLastValue=_;}},
          alignValue:      {get: function(){return alignValue;}, set: function(_){alignValue=_;}},
          rightAlignValue: {get: function(){return rightAlignValue;}, set: function(_){rightAlignValue=_;}},
          noData:          {get: function(){return noData;}, set: function(_){noData=_;}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }}
      });
  
      nv.utils.inheritOptions(chart, sparkline);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.stackedArea = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 960
          , height = 500
          , color = nv.utils.defaultColor() // a function that computes the color
          , id = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't selet one
          , container = null
          , getX = function(d) { return d.x } // accessor to get the x value from a data point
          , getY = function(d) { return d.y } // accessor to get the y value from a data point
          , defined = function(d,i) { return !isNaN(getY(d,i)) && getY(d,i) !== null } // allows a line to be not continuous when it is not defined
          , style = 'stack'
          , offset = 'zero'
          , order = 'default'
          , interpolate = 'linear'  // controls the line interpolation
          , clipEdge = false // if true, masks lines within x and y scale
          , x //can be accessed via chart.xScale()
          , y //can be accessed via chart.yScale()
          , scatter = nv.models.scatter()
          , duration = 250
          , dispatch =  d3.dispatch('areaClick', 'areaMouseover', 'areaMouseout','renderEnd', 'elementClick', 'elementMouseover', 'elementMouseout')
          ;
  
      scatter
          .pointSize(2.2) // default size
          .pointDomain([2.2, 2.2]) // all the same size by default
      ;
  
      /************************************
       * offset:
       *   'wiggle' (stream)
       *   'zero' (stacked)
       *   'expand' (normalize to 100%)
       *   'silhouette' (simple centered)
       *
       * order:
       *   'inside-out' (stream)
       *   'default' (input order)
       ************************************/
  
      var renderWatch = nv.utils.renderWatch(dispatch, duration);
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(scatter);
          selection.each(function(data) {
              var availableWidth = width - margin.left - margin.right,
                  availableHeight = height - margin.top - margin.bottom;
  
              container = d3.select(this);
              nv.utils.initSVG(container);
  
              // Setup Scales
              x = scatter.xScale();
              y = scatter.yScale();
  
              var dataRaw = data;
              // Injecting point index into each point because d3.layout.stack().out does not give index
              data.forEach(function(aseries, i) {
                  aseries.seriesIndex = i;
                  aseries.values = aseries.values.map(function(d, j) {
                      d.index = j;
                      d.seriesIndex = i;
                      return d;
                  });
              });
  
              var dataFiltered = data.filter(function(series) {
                  return !series.disabled;
              });
  
              data = d3.layout.stack()
                  .order(order)
                  .offset(offset)
                  .values(function(d) { return d.values })  //TODO: make values customizeable in EVERY model in this fashion
                  .x(getX)
                  .y(getY)
                  .out(function(d, y0, y) {
                      d.display = {
                          y: y,
                          y0: y0
                      };
                  })
              (dataFiltered);
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-stackedarea').data([data]);
              var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedarea');
              var defsEnter = wrapEnter.append('defs');
              var gEnter = wrapEnter.append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-areaWrap');
              gEnter.append('g').attr('class', 'nv-scatterWrap');
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
              
              // If the user has not specified forceY, make sure 0 is included in the domain
              // Otherwise, use user-specified values for forceY
              if (scatter.forceY().length == 0) {
                  scatter.forceY().push(0);
              }
              
              scatter
                  .width(availableWidth)
                  .height(availableHeight)
                  .x(getX)
                  .y(function(d) {
                      if (d.display !== undefined) { return d.display.y + d.display.y0; }
                  })
                  .color(data.map(function(d,i) {
                      d.color = d.color || color(d, d.seriesIndex);
                      return d.color;
                  }));
  
              var scatterWrap = g.select('.nv-scatterWrap')
                  .datum(data);
  
              scatterWrap.call(scatter);
  
              defsEnter.append('clipPath')
                  .attr('id', 'nv-edge-clip-' + id)
                  .append('rect');
  
              wrap.select('#nv-edge-clip-' + id + ' rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');
  
              var area = d3.svg.area()
                  .defined(defined)
                  .x(function(d,i)  { return x(getX(d,i)) })
                  .y0(function(d) {
                      return y(d.display.y0)
                  })
                  .y1(function(d) {
                      return y(d.display.y + d.display.y0)
                  })
                  .interpolate(interpolate);
  
              var zeroArea = d3.svg.area()
                  .defined(defined)
                  .x(function(d,i)  { return x(getX(d,i)) })
                  .y0(function(d) { return y(d.display.y0) })
                  .y1(function(d) { return y(d.display.y0) });
  
              var path = g.select('.nv-areaWrap').selectAll('path.nv-area')
                  .data(function(d) { return d });
  
              path.enter().append('path').attr('class', function(d,i) { return 'nv-area nv-area-' + i })
                  .attr('d', function(d,i){
                      return zeroArea(d.values, d.seriesIndex);
                  })
                  .on('mouseover', function(d,i) {
                      d3.select(this).classed('hover', true);
                      dispatch.areaMouseover({
                          point: d,
                          series: d.key,
                          pos: [d3.event.pageX, d3.event.pageY],
                          seriesIndex: d.seriesIndex
                      });
                  })
                  .on('mouseout', function(d,i) {
                      d3.select(this).classed('hover', false);
                      dispatch.areaMouseout({
                          point: d,
                          series: d.key,
                          pos: [d3.event.pageX, d3.event.pageY],
                          seriesIndex: d.seriesIndex
                      });
                  })
                  .on('click', function(d,i) {
                      d3.select(this).classed('hover', false);
                      dispatch.areaClick({
                          point: d,
                          series: d.key,
                          pos: [d3.event.pageX, d3.event.pageY],
                          seriesIndex: d.seriesIndex
                      });
                  });
  
              path.exit().remove();
              path.style('fill', function(d,i){
                      return d.color || color(d, d.seriesIndex)
                  })
                  .style('stroke', function(d,i){ return d.color || color(d, d.seriesIndex) });
              path.watchTransition(renderWatch,'stackedArea path')
                  .attr('d', function(d,i) {
                      return area(d.values,i)
                  });
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              scatter.dispatch.on('elementMouseover.area', function(e) {
                  g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', true);
              });
              scatter.dispatch.on('elementMouseout.area', function(e) {
                  g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', false);
              });
  
              //Special offset functions
              chart.d3_stackedOffset_stackPercent = function(stackData) {
                  var n = stackData.length,    //How many series
                      m = stackData[0].length,     //how many points per series
                      i,
                      j,
                      o,
                      y0 = [];
  
                  for (j = 0; j < m; ++j) { //Looping through all points
                      for (i = 0, o = 0; i < dataRaw.length; i++) { //looping through all series
                          o += getY(dataRaw[i].values[j]); //total y value of all series at a certian point in time.
                      }
  
                      if (o) for (i = 0; i < n; i++) { //(total y value of all series at point in time i) != 0
                          stackData[i][j][1] /= o;
                      } else { //(total y value of all series at point in time i) == 0
                          for (i = 0; i < n; i++) {
                              stackData[i][j][1] = 0;
                          }
                      }
                  }
                  for (j = 0; j < m; ++j) y0[j] = 0;
                  return y0;
              };
  
          });
  
          renderWatch.renderEnd('stackedArea immediate');
          return chart;
      }
  
      //============================================================
      // Global getters and setters
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.scatter = scatter;
  
      scatter.dispatch.on('elementClick', function(){ dispatch.elementClick.apply(this, arguments); });
      scatter.dispatch.on('elementMouseover', function(){ dispatch.elementMouseover.apply(this, arguments); });
      scatter.dispatch.on('elementMouseout', function(){ dispatch.elementMouseout.apply(this, arguments); });
  
      chart.interpolate = function(_) {
          if (!arguments.length) return interpolate;
          interpolate = _;
          return chart;
      };
  
      chart.duration = function(_) {
          if (!arguments.length) return duration;
          duration = _;
          renderWatch.reset(duration);
          scatter.duration(duration);
          return chart;
      };
  
      chart.dispatch = dispatch;
      chart.scatter = scatter;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          defined: {get: function(){return defined;}, set: function(_){defined=_;}},
          clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
          offset:      {get: function(){return offset;}, set: function(_){offset=_;}},
          order:    {get: function(){return order;}, set: function(_){order=_;}},
          interpolate:    {get: function(){return interpolate;}, set: function(_){interpolate=_;}},
  
          // simple functor options
          x:     {get: function(){return getX;}, set: function(_){getX = d3.functor(_);}},
          y:     {get: function(){return getY;}, set: function(_){getY = d3.functor(_);}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
          }},
          style: {get: function(){return style;}, set: function(_){
              style = _;
              switch (style) {
                  case 'stack':
                      chart.offset('zero');
                      chart.order('default');
                      break;
                  case 'stream':
                      chart.offset('wiggle');
                      chart.order('inside-out');
                      break;
                  case 'stream-center':
                      chart.offset('silhouette');
                      chart.order('inside-out');
                      break;
                  case 'expand':
                      chart.offset('expand');
                      chart.order('default');
                      break;
                  case 'stack_percent':
                      chart.offset(chart.d3_stackedOffset_stackPercent);
                      chart.order('default');
                      break;
              }
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              scatter.duration(duration);
          }}
      });
  
      nv.utils.inheritOptions(chart, scatter);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.stackedAreaChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var stacked = nv.models.stackedArea()
          , xAxis = nv.models.axis()
          , yAxis = nv.models.axis()
          , legend = nv.models.legend()
          , controls = nv.models.legend()
          , interactiveLayer = nv.interactiveGuideline()
          , tooltip = nv.models.tooltip()
          , focus = nv.models.focus(nv.models.stackedArea())
          ;
  
      var margin = {top: 10, right: 25, bottom: 50, left: 60}
          , marginTop = null
          , width = null
          , height = null
          , color = nv.utils.defaultColor()
          , showControls = true
          , showLegend = true
          , legendPosition = 'top'
          , showXAxis = true
          , showYAxis = true
          , rightAlignYAxis = false
          , focusEnable = false
          , useInteractiveGuideline = false
          , showTotalInTooltip = true
          , totalLabel = 'TOTAL'
          , x //can be accessed via chart.xScale()
          , y //can be accessed via chart.yScale()
          , state = nv.utils.state()
          , defaultState = null
          , noData = null
          , dispatch = d3.dispatch('stateChange', 'changeState','renderEnd')
          , controlWidth = 250
          , controlOptions = ['Stacked','Stream','Expanded']
          , controlLabels = {}
          , duration = 250
          ;
  
      state.style = stacked.style();
      xAxis.orient('bottom').tickPadding(7);
      yAxis.orient((rightAlignYAxis) ? 'right' : 'left');
  
      tooltip
          .headerFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          })
          .valueFormatter(function(d, i) {
              return yAxis.tickFormat()(d, i);
          });
  
      interactiveLayer.tooltip
          .headerFormatter(function(d, i) {
              return xAxis.tickFormat()(d, i);
          })
          .valueFormatter(function(d, i) {
              return d == null ? "N/A" : yAxis.tickFormat()(d, i);
          });
  
      var oldYTickFormat = null,
          oldValueFormatter = null;
  
      controls.updateState(false);
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
      var style = stacked.style();
  
      var stateGetter = function(data) {
          return function(){
              return {
                  active: data.map(function(d) { return !d.disabled }),
                  style: stacked.style()
              };
          }
      };
  
      var stateSetter = function(data) {
          return function(state) {
              if (state.style !== undefined)
                  style = state.style;
              if (state.active !== undefined)
                  data.forEach(function(series,i) {
                      series.disabled = !state.active[i];
                  });
          }
      };
  
      var percentFormatter = d3.format('%');
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(stacked);
          if (showXAxis) renderWatch.models(xAxis);
          if (showYAxis) renderWatch.models(yAxis);
  
          selection.each(function(data) {
              var container = d3.select(this),
                  that = this;
              nv.utils.initSVG(container);
  
              var availableWidth = nv.utils.availableWidth(width, container, margin),
                  availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);
  
              chart.update = function() { container.transition().duration(duration).call(chart); };
              chart.container = this;
  
              state
                  .setter(stateSetter(data), chart.update)
                  .getter(stateGetter(data))
                  .update();
  
              // DEPRECATED set state.disabled
              state.disabled = data.map(function(d) { return !!d.disabled });
  
              if (!defaultState) {
                  var key;
                  defaultState = {};
                  for (key in state) {
                      if (state[key] instanceof Array)
                          defaultState[key] = state[key].slice(0);
                      else
                          defaultState[key] = state[key];
                  }
              }
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                  nv.utils.noData(chart, container)
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
              // Setup Scales
              x = stacked.xScale();
              y = stacked.yScale();
  
              // Setup containers and skeleton of chart
              var wrap = container.selectAll('g.nv-wrap.nv-stackedAreaChart').data([data]);
              var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedAreaChart').append('g');
              var g = wrap.select('g');
  
              gEnter.append('g').attr('class', 'nv-legendWrap');
              gEnter.append('g').attr('class', 'nv-controlsWrap');
  
              var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
              focusEnter.append('g').attr('class', 'nv-background').append('rect');
              focusEnter.append('g').attr('class', 'nv-x nv-axis');
              focusEnter.append('g').attr('class', 'nv-y nv-axis');
              focusEnter.append('g').attr('class', 'nv-stackedWrap');
              focusEnter.append('g').attr('class', 'nv-interactive');
  
              // g.select("rect").attr("width",availableWidth).attr("height",availableHeight);
  
              var contextEnter = gEnter.append('g').attr('class', 'nv-focusWrap');
  
              // Legend
              if (!showLegend) {
                  g.select('.nv-legendWrap').selectAll('*').remove();
              } else {
                  var legendWidth = (showControls && legendPosition === 'top') ? availableWidth - controlWidth : availableWidth;
  
                  legend.width(legendWidth);
                  g.select('.nv-legendWrap').datum(data).call(legend);
  
                  if (legendPosition === 'bottom') {
                    var xAxisHeight = xAxis.height();
                       margin.bottom = Math.max(legend.height() + xAxisHeight, margin.bottom);
                       availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);
                    var legendTop = availableHeight + xAxisHeight;
                      g.select('.nv-legendWrap')
                          .attr('transform', 'translate(0,' + legendTop +')');
                  } else if (legendPosition === 'top') {
                      if (!marginTop && margin.top != legend.height()) {
                          margin.top = legend.height();
                          availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);
                      }
  
                      g.select('.nv-legendWrap')
                        .attr('transform', 'translate(' + (availableWidth-legendWidth) + ',' + (-margin.top) +')');
                  }
              }
  
              // Controls
              if (!showControls) {
                   g.select('.nv-controlsWrap').selectAll('*').remove();
              } else {
                  var controlsData = [
                      {
                          key: controlLabels.stacked || 'Stacked',
                          metaKey: 'Stacked',
                          disabled: stacked.style() != 'stack',
                          style: 'stack'
                      },
                      {
                          key: controlLabels.stream || 'Stream',
                          metaKey: 'Stream',
                          disabled: stacked.style() != 'stream',
                          style: 'stream'
                      },
                      {
                          key: controlLabels.stream_center || 'Stream Center',
                          metaKey: 'Stream_Center',
                          disabled: stacked.style() != 'stream_center',
                          style: 'stream-center'
                      },
                      {
                          key: controlLabels.expanded || 'Expanded',
                          metaKey: 'Expanded',
                          disabled: stacked.style() != 'expand',
                          style: 'expand'
                      },
                      {
                          key: controlLabels.stack_percent || 'Stack %',
                          metaKey: 'Stack_Percent',
                          disabled: stacked.style() != 'stack_percent',
                          style: 'stack_percent'
                      }
                  ];
  
                  controlWidth = (controlOptions.length/3) * 260;
                  controlsData = controlsData.filter(function(d) {
                      return controlOptions.indexOf(d.metaKey) !== -1;
                  });
  
                  controls
                      .width( controlWidth )
                      .color(['#444', '#444', '#444']);
  
                  g.select('.nv-controlsWrap')
                      .datum(controlsData)
                      .call(controls);
  
                  var requiredTop = Math.max(controls.height(), showLegend && (legendPosition === 'top') ? legend.height() : 0);
  
                  if ( margin.top != requiredTop ) {
                      margin.top = requiredTop;
                      availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);
                  }
  
                  g.select('.nv-controlsWrap')
                      .attr('transform', 'translate(0,' + (-margin.top) +')');
              }
  
              wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
  
              if (rightAlignYAxis) {
                  g.select(".nv-y.nv-axis")
                      .attr("transform", "translate(" + availableWidth + ",0)");
              }
  
              //Set up interactive layer
              if (useInteractiveGuideline) {
                  interactiveLayer
                      .width(availableWidth)
                      .height(availableHeight)
                      .margin({left: margin.left, top: margin.top})
                      .svgContainer(container)
                      .xScale(x);
                  wrap.select(".nv-interactive").call(interactiveLayer);
              }
  
              g.select('.nv-focus .nv-background rect')
                  .attr('width', availableWidth)
                  .attr('height', availableHeight);
  
              stacked
                  .width(availableWidth)
                  .height(availableHeight)
                  .color(data.map(function(d,i) {
                      return d.color || color(d, i);
                  }).filter(function(d,i) { return !data[i].disabled; }));
  
              var stackedWrap = g.select('.nv-focus .nv-stackedWrap')
                  .datum(data.filter(function(d) { return !d.disabled; }));
  
              // Setup Axes
              if (showXAxis) {
                  xAxis.scale(x)
                      ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                      .tickSize( -availableHeight, 0);
              }
  
              if (showYAxis) {
                  var ticks;
                  if (stacked.offset() === 'wiggle') {
                      ticks = 0;
                  }
                  else {
                      ticks = nv.utils.calcTicksY(availableHeight/36, data);
                  }
                  yAxis.scale(y)
                      ._ticks(ticks)
                      .tickSize(-availableWidth, 0);
              }
  
              //============================================================
              // Update Axes
              //============================================================
              function updateXAxis() {
                  if(showXAxis) {
                      g.select('.nv-focus .nv-x.nv-axis')
                          .attr('transform', 'translate(0,' + availableHeight + ')')
                          .transition()
                          .duration(duration)
                          .call(xAxis)
                          ;
                  }
              }
  
              function updateYAxis() {
                  if(showYAxis) {
                      if (stacked.style() === 'expand' || stacked.style() === 'stack_percent') {
                          var currentFormat = yAxis.tickFormat();
  
                          if ( !oldYTickFormat || currentFormat !== percentFormatter )
                              oldYTickFormat = currentFormat;
  
                          //Forces the yAxis to use percentage in 'expand' mode.
                          yAxis.tickFormat(percentFormatter);
                      }
                      else {
                          if (oldYTickFormat) {
                              yAxis.tickFormat(oldYTickFormat);
                              oldYTickFormat = null;
                          }
                      }
  
                      g.select('.nv-focus .nv-y.nv-axis')
                      .transition().duration(0)
                      .call(yAxis);
                  }
              }
  
              //============================================================
              // Update Focus
              //============================================================
              if(!focusEnable) {
                  stackedWrap.transition().call(stacked);
                  updateXAxis();
                  updateYAxis();
              } else {
                  focus.width(availableWidth);
                  g.select('.nv-focusWrap')
                      .attr('transform', 'translate(0,' + ( availableHeight + margin.bottom + focus.margin().top) + ')')
                      .datum(data.filter(function(d) { return !d.disabled; }))
                      .call(focus);
                  var extent = focus.brush.empty() ? focus.xDomain() : focus.brush.extent();
                  if(extent !== null){
                      onBrush(extent);
                  }
              }
  
              //============================================================
              // Event Handling/Dispatching (in chart's scope)
              //------------------------------------------------------------
  
              stacked.dispatch.on('areaClick.toggle', function(e) {
                  if (data.filter(function(d) { return !d.disabled }).length === 1)
                      data.forEach(function(d) {
                          d.disabled = false;
                      });
                  else
                      data.forEach(function(d,i) {
                          d.disabled = (i != e.seriesIndex);
                      });
  
                  state.disabled = data.map(function(d) { return !!d.disabled });
                  dispatch.stateChange(state);
  
                  chart.update();
              });
  
              legend.dispatch.on('stateChange', function(newState) {
                  for (var key in newState)
                      state[key] = newState[key];
                  dispatch.stateChange(state);
                  chart.update();
              });
  
              controls.dispatch.on('legendClick', function(d,i) {
                  if (!d.disabled) return;
  
                  controlsData = controlsData.map(function(s) {
                      s.disabled = true;
                      return s;
                  });
                  d.disabled = false;
  
                  stacked.style(d.style);
  
  
                  state.style = stacked.style();
                  dispatch.stateChange(state);
  
                  chart.update();
              });
  
              interactiveLayer.dispatch.on('elementMousemove', function(e) {
                  stacked.clearHighlights();
                  var singlePoint, pointIndex, pointXLocation, allData = [], valueSum = 0, allNullValues = true, atleastOnePoint = false;
                  data
                      .filter(function(series, i) {
                          series.seriesIndex = i;
                          return !series.disabled;
                      })
                      .forEach(function(series,i) {
                          pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                          var point = series.values[pointIndex];
                          var pointYValue = chart.y()(point, pointIndex);
                          if (pointYValue != null && pointYValue > 0) {
                              stacked.highlightPoint(i, pointIndex, true);
                              atleastOnePoint = true;
                          }
  
                          // Draw at least one point if all values are zero.
                          if (i === (data.length - 1) && !atleastOnePoint) {
                              stacked.highlightPoint(i, pointIndex, true);
                          }
                          if (typeof point === 'undefined') return;
                          if (typeof singlePoint === 'undefined') singlePoint = point;
                          if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
  
                          //If we are in 'expand' mode, use the stacked percent value instead of raw value.
                          var tooltipValue = (stacked.style() == 'expand') ? point.display.y : chart.y()(point,pointIndex);
                          allData.push({
                              key: series.key,
                              value: tooltipValue,
                              color: color(series,series.seriesIndex),
                              point: point
                          });
  
                          if (showTotalInTooltip && stacked.style() != 'expand' && tooltipValue != null) {
                            valueSum += tooltipValue;
                            allNullValues = false;
                          };
                      });
  
                  allData.reverse();
  
                  //Highlight the tooltip entry based on which stack the mouse is closest to.
                  if (allData.length > 2) {
                      var yValue = chart.yScale().invert(e.mouseY);
                      var yDistMax = Infinity, indexToHighlight = null;
                      allData.forEach(function(series,i) {
  
                          //To handle situation where the stacked area chart is negative, we need to use absolute values
                          //when checking if the mouse Y value is within the stack area.
                          yValue = Math.abs(yValue);
                          var stackedY0 = Math.abs(series.point.display.y0);
                          var stackedY = Math.abs(series.point.display.y);
                          if ( yValue >= stackedY0 && yValue <= (stackedY + stackedY0))
                          {
                              indexToHighlight = i;
                              return;
                          }
                      });
                      if (indexToHighlight != null)
                          allData[indexToHighlight].highlight = true;
                  }
  
                  //If we are not in 'expand' mode, add a 'Total' row to the tooltip.
                  if (showTotalInTooltip && stacked.style() != 'expand' && allData.length >= 2 && !allNullValues) {
                      allData.push({
                          key: totalLabel,
                          value: valueSum,
                          total: true
                      });
                  }
  
                  var xValue = chart.x()(singlePoint,pointIndex);
  
                  var valueFormatter = interactiveLayer.tooltip.valueFormatter();
                  // Keeps track of the tooltip valueFormatter if the chart changes to expanded view
                  if (stacked.style() === 'expand' || stacked.style() === 'stack_percent') {
                      if ( !oldValueFormatter ) {
                          oldValueFormatter = valueFormatter;
                      }
                      //Forces the tooltip to use percentage in 'expand' mode.
                      valueFormatter = d3.format(".1%");
                  }
                  else {
                      if (oldValueFormatter) {
                          valueFormatter = oldValueFormatter;
                          oldValueFormatter = null;
                      }
                  }
  
                  interactiveLayer.tooltip
                      .valueFormatter(valueFormatter)
                      .data(
                      {
                          value: xValue,
                          series: allData
                      }
                  )();
  
                  interactiveLayer.renderGuideLine(pointXLocation);
  
              });
  
              interactiveLayer.dispatch.on("elementMouseout",function(e) {
                  stacked.clearHighlights();
              });
  
              /* Update `main' graph on brush update. */
              focus.dispatch.on("onBrush", function(extent) {
                  onBrush(extent);
              });
  
              // Update chart from a state object passed to event handler
              dispatch.on('changeState', function(e) {
  
                  if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
                      data.forEach(function(series,i) {
                          series.disabled = e.disabled[i];
                      });
  
                      state.disabled = e.disabled;
                  }
  
                  if (typeof e.style !== 'undefined') {
                      stacked.style(e.style);
                      style = e.style;
                  }
  
                  chart.update();
              });
  
              //============================================================
              // Functions
              //------------------------------------------------------------
  
              function onBrush(extent) {
                  // Update Main (Focus)
                  var stackedWrap = g.select('.nv-focus .nv-stackedWrap')
                      .datum(
                      data.filter(function(d) { return !d.disabled; })
                          .map(function(d,i) {
                              return {
                                  key: d.key,
                                  area: d.area,
                                  classed: d.classed,
                                  values: d.values.filter(function(d,i) {
                                      return stacked.x()(d,i) >= extent[0] && stacked.x()(d,i) <= extent[1];
                                  }),
                                  disableTooltip: d.disableTooltip
                              };
                          })
                  );
                  stackedWrap.transition().duration(duration).call(stacked);
  
                  // Update Main (Focus) Axes
                  updateXAxis();
                  updateYAxis();
              }
  
          });
  
          renderWatch.renderEnd('stacked Area chart immediate');
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      stacked.dispatch.on('elementMouseover.tooltip', function(evt) {
          evt.point['x'] = stacked.x()(evt.point);
          evt.point['y'] = stacked.y()(evt.point);
          tooltip.data(evt).hidden(false);
      });
  
      stacked.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true)
      });
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.stacked = stacked;
      chart.legend = legend;
      chart.controls = controls;
      chart.xAxis = xAxis;
      chart.x2Axis = focus.xAxis;
      chart.yAxis = yAxis;
      chart.y2Axis = focus.yAxis;
      chart.interactiveLayer = interactiveLayer;
      chart.tooltip = tooltip;
      chart.focus = focus;
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
          legendPosition: {get: function(){return legendPosition;}, set: function(_){legendPosition=_;}},
          showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
          showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
          defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
          noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
          showControls:    {get: function(){return showControls;}, set: function(_){showControls=_;}},
          controlLabels:    {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
          controlOptions:    {get: function(){return controlOptions;}, set: function(_){controlOptions=_;}},
          showTotalInTooltip:      {get: function(){return showTotalInTooltip;}, set: function(_){showTotalInTooltip=_;}},
          totalLabel:      {get: function(){return totalLabel;}, set: function(_){totalLabel=_;}},
          focusEnable:    {get: function(){return focusEnable;}, set: function(_){focusEnable=_;}},
          focusHeight:     {get: function(){return focus.height();}, set: function(_){focus.height(_);}},
          brushExtent: {get: function(){return focus.brushExtent();}, set: function(_){focus.brushExtent(_);}},
  
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              if (_.top !== undefined) {
                  margin.top = _.top;
                  marginTop = _.top;
              }
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
          }},
          focusMargin: {get: function(){return focus.margin}, set: function(_){
              focus.margin.top    = _.top    !== undefined ? _.top    : focus.margin.top;
              focus.margin.right  = _.right  !== undefined ? _.right  : focus.margin.right;
              focus.margin.bottom = _.bottom !== undefined ? _.bottom : focus.margin.bottom;
              focus.margin.left   = _.left   !== undefined ? _.left   : focus.margin.left;
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              stacked.duration(duration);
              xAxis.duration(duration);
              yAxis.duration(duration);
          }},
          color:  {get: function(){return color;}, set: function(_){
              color = nv.utils.getColor(_);
              legend.color(color);
              stacked.color(color);
              focus.color(color);
          }},
          x: {get: function(){return stacked.x();}, set: function(_){
              stacked.x(_);
              focus.x(_);
          }},
          y: {get: function(){return stacked.y();}, set: function(_){
              stacked.y(_);
              focus.y(_);
          }},
          rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
              rightAlignYAxis = _;
              yAxis.orient( rightAlignYAxis ? 'right' : 'left');
          }},
          useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
              useInteractiveGuideline = !!_;
              chart.interactive(!_);
              chart.useVoronoi(!_);
              stacked.scatter.interactive(!_);
          }}
      });
  
      nv.utils.inheritOptions(chart, stacked);
      nv.utils.initOptions(chart);
  
      return chart;
  };
  
  nv.models.stackedAreaWithFocusChart = function() {
    return nv.models.stackedAreaChart()
      .margin({ bottom: 30 })
      .focusEnable( true );
  };
  // based on http://bl.ocks.org/kerryrodden/477c1bfb081b783f80ad
  nv.models.sunburst = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var margin = {top: 0, right: 0, bottom: 0, left: 0}
          , width = 600
          , height = 600
          , mode = "count"
          , modes = {count: function(d) { return 1; }, value: function(d) { return d.value || d.size }, size: function(d) { return d.value || d.size }}
          , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
          , container = null
          , color = nv.utils.defaultColor()
          , showLabels = false
          , labelFormat = function(d){if(mode === 'count'){return d.name + ' #' + d.value}else{return d.name + ' ' + (d.value || d.size)}}
          , labelThreshold = 0.02
          , sort = function(d1, d2){return d1.name > d2.name;}
          , key = function(d,i){
              if (d.parent !== undefined) {
                  return d.name + '-' + d.parent.name + '-' + i;
              } else {
                  return d.name;
              }
          }
          , groupColorByParent = true
          , duration = 500
          , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMousemove', 'elementMouseover', 'elementMouseout', 'renderEnd');
  
      //============================================================
      // aux functions and setup
      //------------------------------------------------------------
  
      var x = d3.scale.linear().range([0, 2 * Math.PI]);
      var y = d3.scale.sqrt();
  
      var partition = d3.layout.partition().sort(sort);
  
      var node, availableWidth, availableHeight, radius;
      var prevPositions = {};
  
      var arc = d3.svg.arc()
          .startAngle(function(d) {return Math.max(0, Math.min(2 * Math.PI, x(d.x))) })
          .endAngle(function(d) {return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))) })
          .innerRadius(function(d) {return Math.max(0, y(d.y)) })
          .outerRadius(function(d) {return Math.max(0, y(d.y + d.dy)) });
  
      function rotationToAvoidUpsideDown(d) {
          var centerAngle = computeCenterAngle(d);
          if(centerAngle > 90){
              return 180;
          }
          else {
              return 0;
          }
      }
  
      function computeCenterAngle(d) {
          var startAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x)));
          var endAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
          var centerAngle = (((startAngle + endAngle) / 2) * (180 / Math.PI)) - 90;
          return centerAngle;
      }
  
      function computeNodePercentage(d) {
          var startAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x)));
          var endAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
          return (endAngle - startAngle) / (2 * Math.PI);
      }
  
      function labelThresholdMatched(d) {
          var startAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x)));
          var endAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
  
          var size = endAngle - startAngle;
          return size > labelThreshold;
      }
  
      // When zooming: interpolate the scales.
      function arcTweenZoom(e,i) {
          var xd = d3.interpolate(x.domain(), [node.x, node.x + node.dx]),
          yd = d3.interpolate(y.domain(), [node.y, 1]),
          yr = d3.interpolate(y.range(), [node.y ? 20 : 0, radius]);
  
          if (i === 0) {
              return function() {return arc(e);}
          }
          else {
              return function (t) {
                  x.domain(xd(t));
                  y.domain(yd(t)).range(yr(t));
                  return arc(e);
              }
          };
      }
  
      function arcTweenUpdate(d) {
          var ipo = d3.interpolate({x: d.x0, dx: d.dx0, y: d.y0, dy: d.dy0}, d);
  
          return function (t) {
              var b = ipo(t);
  
              d.x0 = b.x;
              d.dx0 = b.dx;
              d.y0 = b.y;
              d.dy0 = b.dy;
  
              return arc(b);
          };
      }
  
      function updatePrevPosition(node) {
          var k = key(node);
          if(! prevPositions[k]) prevPositions[k] = {};
          var pP = prevPositions[k];
          pP.dx = node.dx;
          pP.x = node.x;
          pP.dy = node.dy;
          pP.y = node.y;
      }
  
      function storeRetrievePrevPositions(nodes) {
          nodes.forEach(function(n){
              var k = key(n);
              var pP = prevPositions[k];
              //console.log(k,n,pP);
              if( pP ){
                  n.dx0 = pP.dx;
                  n.x0 = pP.x;
                  n.dy0 = pP.dy;
                  n.y0 = pP.y;
              }
              else {
                  n.dx0 = n.dx;
                  n.x0 = n.x;
                  n.dy0 = n.dy;
                  n.y0 = n.y;
              }
              updatePrevPosition(n);
          });
      }
  
      function zoomClick(d) {
          var labels = container.selectAll('text')
          var path = container.selectAll('path')
  
          // fade out all text elements
          labels.transition().attr("opacity",0);
  
          // to allow reference to the new center node
          node = d;
  
          path.transition()
              .duration(duration)
              .attrTween("d", arcTweenZoom)
              .each('end', function(e) {
                  // partially taken from here: http://bl.ocks.org/metmajer/5480307
                  // check if the animated element's data e lies within the visible angle span given in d
                  if(e.x >= d.x && e.x < (d.x + d.dx) ){
                      if(e.depth >= d.depth){
                          // get a selection of the associated text element
                          var parentNode = d3.select(this.parentNode);
                          var arcText = parentNode.select('text');
  
                          // fade in the text element and recalculate positions
                          arcText.transition().duration(duration)
                          .text( function(e){return labelFormat(e) })
                          .attr("opacity", function(d){
                              if(labelThresholdMatched(d)) {
                                  return 1;
                              }
                              else {
                                  return 0;
                              }
                          })
                          .attr("transform", function() {
                              var width = this.getBBox().width;
                              if(e.depth === 0)
                              return "translate(" + (width / 2 * - 1) + ",0)";
                              else if(e.depth === d.depth){
                                  return "translate(" + (y(e.y) + 5) + ",0)";
                              }
                              else {
                                  var centerAngle = computeCenterAngle(e);
                                  var rotation = rotationToAvoidUpsideDown(e);
                                  if (rotation === 0) {
                                      return 'rotate('+ centerAngle +')translate(' + (y(e.y) + 5) + ',0)';
                                  }
                                  else {
                                      return 'rotate('+ centerAngle +')translate(' + (y(e.y) + width + 5) + ',0)rotate(' + rotation + ')';
                                  }
                              }
                          });
                      }
                  }
              })
      }
  
      //============================================================
      // chart function
      //------------------------------------------------------------
      var renderWatch = nv.utils.renderWatch(dispatch);
  
      function chart(selection) {
          renderWatch.reset();
  
          selection.each(function(data) {
              container = d3.select(this);
              availableWidth = nv.utils.availableWidth(width, container, margin);
              availableHeight = nv.utils.availableHeight(height, container, margin);
              radius = Math.min(availableWidth, availableHeight) / 2;
  
              y.range([0, radius]);
  
              // Setup containers and skeleton of chart
              var wrap = container.select('g.nvd3.nv-wrap.nv-sunburst');
              if( !wrap[0][0] ) {
                  wrap = container.append('g')
                      .attr('class', 'nvd3 nv-wrap nv-sunburst nv-chart-' + id)
                      .attr('transform', 'translate(' + ((availableWidth / 2) + margin.left + margin.right) + ',' + ((availableHeight / 2) + margin.top + margin.bottom) + ')');
              } else {
                  wrap.attr('transform', 'translate(' + ((availableWidth / 2) + margin.left + margin.right) + ',' + ((availableHeight / 2) + margin.top + margin.bottom) + ')');
              }
  
              container.on('click', function (d, i) {
                  dispatch.chartClick({
                      data: d,
                      index: i,
                      pos: d3.event,
                      id: id
                  });
              });
  
              partition.value(modes[mode] || modes["count"]);
  
              //reverse the drawing order so that the labels of inner
              //arcs are drawn on top of the outer arcs.
              var nodes = partition.nodes(data[0]).reverse()
  
              storeRetrievePrevPositions(nodes);
              var cG = wrap.selectAll('.arc-container').data(nodes, key)
  
              //handle new datapoints
              var cGE = cG.enter()
                  .append("g")
                  .attr("class",'arc-container')
  
              cGE.append("path")
                  .attr("d", arc)
                  .style("fill", function (d) {
                      if (d.color) {
                          return d.color;
                      }
                      else if (groupColorByParent) {
                          return color((d.children ? d : d.parent).name);
                      }
                      else {
                          return color(d.name);
                      }
                  })
                  .style("stroke", "#FFF")
                  .on("click", function(d,i){
                      zoomClick(d);
                      dispatch.elementClick({
                          data: d,
                          index: i
                      })
                  })
                  .on('mouseover', function(d,i){
                      d3.select(this).classed('hover', true).style('opacity', 0.8);
                      dispatch.elementMouseover({
                          data: d,
                          color: d3.select(this).style("fill"),
                          percent: computeNodePercentage(d)
                      });
                  })
                  .on('mouseout', function(d,i){
                      d3.select(this).classed('hover', false).style('opacity', 1);
                      dispatch.elementMouseout({
                          data: d
                      });
                  })
                  .on('mousemove', function(d,i){
                      dispatch.elementMousemove({
                          data: d
                      });
                  });
  
              ///Iterating via each and selecting based on the this
              ///makes it work ... a cG.selectAll('path') doesn't.
              ///Without iteration the data (in the element) didn't update.
              cG.each(function(d){
                  d3.select(this).select('path')
                      .transition()
                      .duration(duration)
                      .attrTween('d', arcTweenUpdate);
              });
  
              if(showLabels){
                  //remove labels first and add them back
                  cG.selectAll('text').remove();
  
                  //this way labels are on top of newly added arcs
                  cG.append('text')
                      .text( function(e){ return labelFormat(e)})
                      .transition()
                      .duration(duration)
                      .attr("opacity", function(d){
                          if(labelThresholdMatched(d)) {
                              return 1;
                          }
                          else {
                              return 0;
                          }
                      })
                      .attr("transform", function(d) {
                          var width = this.getBBox().width;
                          if(d.depth === 0){
                              return "rotate(0)translate(" + (width / 2 * -1) + ",0)";
                          }
                          else {
                              var centerAngle = computeCenterAngle(d);
                              var rotation = rotationToAvoidUpsideDown(d);
                              if (rotation === 0) {
                                  return 'rotate('+ centerAngle +')translate(' + (y(d.y) + 5) + ',0)';
                              }
                              else {
                                  return 'rotate('+ centerAngle +')translate(' + (y(d.y) + width + 5) + ',0)rotate(' + rotation + ')';
                              }
                          }
                      });
              }
  
              //zoom out to the center when the data is updated.
              zoomClick(nodes[nodes.length - 1])
  
  
              //remove unmatched elements ...
              cG.exit()
                  .transition()
                  .duration(duration)
                  .attr('opacity',0)
                  .each('end',function(d){
                      var k = key(d);
                      prevPositions[k] = undefined;
                  })
                  .remove();
          });
  
  
          renderWatch.renderEnd('sunburst immediate');
          return chart;
      }
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      chart.dispatch = dispatch;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          width:      {get: function(){return width;}, set: function(_){width=_;}},
          height:     {get: function(){return height;}, set: function(_){height=_;}},
          mode:       {get: function(){return mode;}, set: function(_){mode=_;}},
          id:         {get: function(){return id;}, set: function(_){id=_;}},
          duration:   {get: function(){return duration;}, set: function(_){duration=_;}},
          groupColorByParent: {get: function(){return groupColorByParent;}, set: function(_){groupColorByParent=!!_;}},
          showLabels: {get: function(){return showLabels;}, set: function(_){showLabels=!!_}},
          labelFormat: {get: function(){return labelFormat;}, set: function(_){labelFormat=_}},
          labelThreshold: {get: function(){return labelThreshold;}, set: function(_){labelThreshold=_}},
          sort: {get: function(){return sort;}, set: function(_){sort=_}},
          key: {get: function(){return key;}, set: function(_){key=_}},
          // options that require extra logic in the setter
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    != undefined ? _.top    : margin.top;
              margin.right  = _.right  != undefined ? _.right  : margin.right;
              margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   != undefined ? _.left   : margin.left;
          }},
          color: {get: function(){return color;}, set: function(_){
              color=nv.utils.getColor(_);
          }}
      });
  
      nv.utils.initOptions(chart);
      return chart;
  };
  nv.models.sunburstChart = function() {
      "use strict";
  
      //============================================================
      // Public Variables with Default Settings
      //------------------------------------------------------------
  
      var sunburst = nv.models.sunburst();
      var tooltip = nv.models.tooltip();
  
      var margin = {top: 30, right: 20, bottom: 20, left: 20}
          , width = null
          , height = null
          , color = nv.utils.defaultColor()
          , showTooltipPercent = false
          , id = Math.round(Math.random() * 100000)
          , defaultState = null
          , noData = null
          , duration = 250
          , dispatch = d3.dispatch('stateChange', 'changeState','renderEnd');
  
  
      //============================================================
      // Private Variables
      //------------------------------------------------------------
  
      var renderWatch = nv.utils.renderWatch(dispatch);
  
      tooltip
          .duration(0)
          .headerEnabled(false)
          .valueFormatter(function(d){return d;});
  
      //============================================================
      // Chart function
      //------------------------------------------------------------
  
      function chart(selection) {
          renderWatch.reset();
          renderWatch.models(sunburst);
  
          selection.each(function(data) {
              var container = d3.select(this);
  
              nv.utils.initSVG(container);
  
              var availableWidth = nv.utils.availableWidth(width, container, margin);
              var availableHeight = nv.utils.availableHeight(height, container, margin);
  
              chart.update = function() {
                  if (duration === 0) {
                      container.call(chart);
                  } else {
                      container.transition().duration(duration).call(chart);
                  }
              };
              chart.container = container;
  
              // Display No Data message if there's nothing to show.
              if (!data || !data.length) {
                  nv.utils.noData(chart, container);
                  return chart;
              } else {
                  container.selectAll('.nv-noData').remove();
              }
  
              sunburst.width(availableWidth).height(availableHeight).margin(margin);
              container.call(sunburst);
          });
  
          renderWatch.renderEnd('sunburstChart immediate');
          return chart;
      }
  
      //============================================================
      // Event Handling/Dispatching (out of chart's scope)
      //------------------------------------------------------------
  
      sunburst.dispatch.on('elementMouseover.tooltip', function(evt) {
          evt.series = {
              key: evt.data.name,
              value: (evt.data.value || evt.data.size),
              color: evt.color,
              percent: evt.percent
          };
          if (!showTooltipPercent) {
              delete evt.percent;
              delete evt.series.percent;
          }
          tooltip.data(evt).hidden(false);
      });
  
      sunburst.dispatch.on('elementMouseout.tooltip', function(evt) {
          tooltip.hidden(true);
      });
  
      sunburst.dispatch.on('elementMousemove.tooltip', function(evt) {
          tooltip();
      });
  
      //============================================================
      // Expose Public Variables
      //------------------------------------------------------------
  
      // expose chart's sub-components
      chart.dispatch = dispatch;
      chart.sunburst = sunburst;
      chart.tooltip = tooltip;
      chart.options = nv.utils.optionsFunc.bind(chart);
  
      // use Object get/set functionality to map between vars and chart functions
      chart._options = Object.create({}, {
          // simple options, just get/set the necessary values
          noData:             {get: function(){return noData;},               set: function(_){noData=_;}},
          defaultState:       {get: function(){return defaultState;},         set: function(_){defaultState=_;}},
          showTooltipPercent: {get: function(){return showTooltipPercent;},   set: function(_){showTooltipPercent=_;}},
  
          // options that require extra logic in the setter
          color: {get: function(){return color;}, set: function(_){
              color = _;
              sunburst.color(color);
          }},
          duration: {get: function(){return duration;}, set: function(_){
              duration = _;
              renderWatch.reset(duration);
              sunburst.duration(duration);
          }},
          margin: {get: function(){return margin;}, set: function(_){
              margin.top    = _.top    !== undefined ? _.top    : margin.top;
              margin.right  = _.right  !== undefined ? _.right  : margin.right;
              margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
              margin.left   = _.left   !== undefined ? _.left   : margin.left;
              sunburst.margin(margin);
          }}
      });
      nv.utils.inheritOptions(chart, sunburst);
      nv.utils.initOptions(chart);
      return chart;
  
  };
  
  nv.version = "1.8.6-dev";
  })();
  //# sourceMappingURL=nv.d3.js.map</script>
  <script>
  /* Inspired by Lee Byron's test data generator. */
  function stream_layers(n, m, o) {
    if (arguments.length < 3) o = 0;
    function bump(a) {
      var x = 1 / (.1 + Math.random()),
          y = 2 * Math.random() - .5,
          z = 10 / (.1 + Math.random());
      for (var i = 0; i < m; i++) {
        var w = (i / m - y) * z;
        a[i] += x * Math.exp(-w * w);
      }
    }
    return d3.range(n).map(function() {
        var a = [], i;
        for (i = 0; i < m; i++) a[i] = o + o * Math.random();
        for (i = 0; i < 5; i++) bump(a);
        return a.map(stream_index);
      });
  }
  
  /* Another layer generator using gamma distributions. */
  function stream_waves(n, m) {
    return d3.range(n).map(function(i) {
      return d3.range(m).map(function(j) {
          var x = 20 * j / m - i / 3;
          return 2 * x * Math.exp(-.5 * x);
        }).map(stream_index);
      });
  }
  
  function stream_index(d, i) {
    return {x: i, y: Math.max(0, d)};
  }
  
  </script>
  <script>HTMLWidgets.widget({
  
    name: 'MultibarHorizontal',
  
    type: 'output',
  
    factory: function(el, width, height) {
  
      // TODO: define shared variables for this instance
  
      return {
  
        renderValue: function(x) {
  
          var newSvg = document.getElementById(el.id);
          newSvg.innerHTML += '<div id="chart1" class="with-3d-shadow with-transitions" style="height: 60vh; width: 80vh;"><svg></svg></div>';
  
          var long_short_data = x.data;
  
          var chart;
          nv.addGraph(function() {
              chart = nv.models.multiBarHorizontalChart()
                  .x(function(d) { return d.label })
                  .y(function(d) { return d.value })
                  .yErr(function(d) { return [-Math.abs(d.value * Math.random() * 0.3), Math.abs(d.value * Math.random() * 0.3)] })
                  .barColor(d3.scale.category20().range())
                  .duration(250)
                  .margin({left: 100})
                  .stacked(true);
  
              chart.yAxis.tickFormat(d3.format(',.2f'));
  
              chart.yAxis.axisLabel('Y Axis');
              chart.xAxis.axisLabel('X Axis').axisLabelDistance(20);
  
              d3.select('#chart1 svg')
                  .datum(long_short_data)
                  .call(chart);
  
              nv.utils.windowResize(chart.update);
  
              chart.dispatch.on('stateChange', function(e) { nv.log('New State:', JSON.stringify(e)); });
              chart.state.dispatch.on('change', function(state){
                  nv.log('state', JSON.stringify(state));
              });
              return chart;
          });
  
  
        },
  
        resize: function(width, height) {
  
          // TODO: code to re-render the widget with a new size
  
        }
  
      };
    }
  });
  </script>

  <!-- =======================================================
  * Template Name: OnePage
  * Updated: Sep 18 2023 with Bootstrap v5.3.2
  * Template URL: https://bootstrapmade.com/onepage-multipurpose-bootstrap-template/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body>

  <!-- ======= Header ======= -->
  <header id="header" class="fixed-top">
    <div class="container d-flex align-items-center justify-content-between">

      <h1 class="logo"><a href="index.html">Kamila Kolpashnikova</a></h1>
      <!-- Uncomment below if you prefer to use an image logo -->
      <!-- <a href="index.html" class="logo"><img src="assets/img/logo.png" alt="" class="img-fluid"></a>-->

      <nav id="navbar" class="navbar">
        <ul>
          <li><a class="nav-link scrollto active" href="index.html">Home</a></li>
        </ul>
        <i class="bi bi-list mobile-nav-toggle"></i>
      </nav><!-- .navbar -->

    </div>
  </header><!-- End Header -->

  <main id="main">

    <!-- ======= Breadcrumbs ======= -->
    <section id="breadcrumbs" class="breadcrumbs">
      <div class="container">

        <div class="d-flex justify-content-between align-items-center">
          <h2>Portfolio Details</h2>
          <ol>
            <li><a href="index.html">Home</a></li>
            <li>Portfolio Details</li>
          </ol>
        </div>

      </div>
    </section><!-- End Breadcrumbs -->

    <!-- ======= Portfolio Details Section ======= -->
    <section id="portfolio-details" class="portfolio-details">
      <div class="container">

        <div class="row gy-4">

          <div class="col-lg-8">
            <div id="htmlwidget_container">
              <div id="htmlwidget-7df515aecc32b7901eac" style="width:auto;height:500px;" class="MultibarHorizontal html-widget"></div>
            </div>
          
          </div>

          <div class="col-lg-4">
            <div class="portfolio-info">
              <h3>Project information</h3>
              <ul>
                <li><strong>Category</strong>: Web visualization</li>
                <li><strong>Software</strong>: JavaScript</li>
                <li><strong>Project URL</strong>: <a href="http://www.wipsociology.org/2022/10/27/can-the-differences-in-economic-resources-explain-the-gender-gap-in-housework/#more-3028" target="_blank">Work In Progress Article</a></li>
              </ul>
            </div>
            <div class="portfolio-description">
                <h2>Analysis of Gender Gap in Housework Time</h2>

                <h3>Description:</h3>
                <p>In a paper published in the Social Science Journal, we delve deep into the intricacies 
                    of the gender gap in housework time. Utilizing the American Time Use Survey Data Extract Builder 
                    (ATUS-X) data spanning from 2003 to 2019, we shed light on the influence of economic resources 
                    on this gender gap. This figure, a visual representation from our study, 
                    elucidates that economic resources can account for approximately 40% of the gender discrepancy 
                    in housework durations.</p>
                
                <h3>Data Source:</h3>
                <p>The analysis is anchored in the data extracted from the American Time Use Survey Data Extract 
                    Builder (ATUS-X), 2003 to 2019.</p>
                
                <h3>Key Insights:</h3>
                <p>The visualization of model coefficients underscores the significant role of economic resources in shaping the gender gap 
                    in housework. Specifically:</p>
                <ul>
                    <li>Economic resources play a substantial role in shared housework tasks 
                        like shopping and those predominantly associated with women, such as cooking and cleaning.</li>
                    <li>On the flip side, these resources offer minimal explanatory power 
                        when it comes to tasks that have cultural ties with men, like maintenance and repairs.</li>
                </ul>
                
                <h3>Significance:</h3>
                <p>This research and the revelations from this figure provide pivotal insights for sociologists, 
                    economists, and policymakers. Understanding the driving factors behind the gender gap 
                    in housework can inform policy decisions, workplace practices, and societal shifts 
                    towards a more equitable distribution of domestic tasks.</p>
                
                <h3>Visualization Details:</h3>
                <p>This visualization employs a combination of interactive bar graphs to depict the 
                    relationship between economic resources and the gender gap in various housework tasks. 
                    The visual representation allows for a clear comparison of how different factors weigh 
                    in on housework time across genders.</p>
            </div>
          </div>

        </div>

      </div>
    </section><!-- End Portfolio Details Section -->

  </main><!-- End #main -->

   <!-- ======= Footer ======= -->
   <footer id="footer">

    <div class="footer-top">
      <div class="container">
        <div class="row">

          <div class="col-lg-3 col-md-6 footer-contact">
            <h3>Kamila Kolpashnikova</h3>
            <p>
              Assistant Professor <br>
              Western University<br>
              London, ON <br><br>
              <strong>Email:</strong> kkolpash [at] uwo.ca<br>
            </p>
          </div>

        </div>
      </div>
    </div>

    <div class="container d-md-flex py-4">

      <div class="me-md-auto text-center text-md-start">
        <div class="copyright">
          &copy; Copyright <strong><span>Kamila Kolpashnikova</span></strong>. All Rights Reserved
        </div>
        <div class="credits">
          <!-- All the links in the footer should remain intact. -->
          <!-- You can delete the links only if you purchased the pro version. -->
          <!-- Licensing information: https://bootstrapmade.com/license/ -->
          <!-- Purchase the pro version with working PHP/AJAX contact form: https://bootstrapmade.com/onepage-multipurpose-bootstrap-template/ -->
          Designed by <a href="https://bootstrapmade.com/">BootstrapMade</a>
        </div>
      </div>
      <div class="social-links text-center text-md-right pt-3 pt-md-0">
        <a href="www.linkedin.com/in/kamilakolpashnikova" class="linkedin"><i class="bx bxl-linkedin"></i></a>
      </div>
    </div>
  </footer><!-- End Footer -->

  <div id="preloader"></div>
  <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>

  <!-- Vendor JS Files -->
  <script src="assets/vendor/purecounter/purecounter_vanilla.js"></script>
  <script src="assets/vendor/aos/aos.js"></script>
  <script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="assets/vendor/glightbox/js/glightbox.min.js"></script>
  <script src="assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="assets/vendor/swiper/swiper-bundle.min.js"></script>
  <script src="assets/vendor/php-email-form/validate.js"></script>
  <script type="application/json" data-for="htmlwidget-7df515aecc32b7901eac">{"x":{"data":[{"key":"Work Hours","values":[{"label":"Total","value":0.2048},{"label":"Cooking","value":0.1017},{"label":"Cleaning","value":0.1001},{"label":"Shopping","value":0.1799},{"label":"Maintenance","value":-0.1846}]},{"key":"SP: Work Hours","values":[{"label":"Total","value":0.0521},{"label":"Cooking","value":0.0115},{"label":"Cleaning","value":0.0332},{"label":"Shopping","value":0.076},{"label":"Maintenance","value":-0.0485}]},{"key":"Log(Income)","values":[{"label":"Total","value":0.0002},{"label":"Cooking","value":0.0007},{"label":"Cleaning","value":-0.0001},{"label":"Shopping","value":-0.0004},{"label":"Maintenance","value":0.0003}]},{"key":"Employed","values":[{"label":"Total","value":0.0921},{"label":"Cooking","value":0.0716},{"label":"Cleaning","value":0.0651},{"label":"Shopping","value":0.0247},{"label":"Maintenance","value":-0.0112}]},{"key":"SP: Employed","values":[{"label":"Total","value":0.0221},{"label":"Cooking","value":0.0311},{"label":"Cleaning","value":0.0126},{"label":"Shopping","value":-0.019},{"label":"Maintenance","value":0.0088}]},{"key":"Her Earnings","values":[{"label":"Total","value":-0.0078},{"label":"Cooking","value":-0.0036},{"label":"Cleaning","value":-0.0051},{"label":"Shopping","value":-0.0081},{"label":"Maintenance","value":0.0048}]},{"key":"Other","values":[{"label":"Total","value":-0.0202},{"label":"Cooking","value":-0.0133},{"label":"Cleaning","value":-0.0097},{"label":"Shopping","value":-0.0113},{"label":"Maintenance","value":0.0145}]}],"message":"works"},"evals":[],"jsHooks":[]}</script>
  <script type="application/htmlwidget-sizing" data-for="htmlwidget-7df515aecc32b7901eac">{"viewer":{"width":450,"height":350,"padding":15,"fill":true},"browser":{"width":960,"height":500,"padding":40,"fill":false}}</script>
  

  <!-- Template Main JS File -->
  <script src="assets/js/main.js"></script>

</body>

</html>